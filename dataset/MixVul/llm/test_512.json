[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcRecordDispatch(ClientPtr client)\n{\n    REQUEST(xReq);\n\n    switch (stuff->data) {\n    case X_RecordQueryVersion:\n        return ProcRecordQueryVersion(client);\n    case X_RecordCreateContext:\n        return ProcRecordCreateContext(client);\n    case X_RecordRegisterClients:\n        return ProcRecordRegisterClients(client);\n    case X_RecordUnregisterClients:\n        return ProcRecordUnregisterClients(client);\n    case X_RecordGetContext:\n        return ProcRecordGetContext(client);\n    case X_RecordEnableContext:\n        return ProcRecordEnableContext(client);\n    case X_RecordDisableContext:\n        return ProcRecordDisableContext(client);\n    case X_RecordFreeContext:\n        return ProcRecordFreeContext(client);\n    default:\n        return BadRequest;\n    }\n}                               /* ProcRecordDispatch */",
        "output": "0",
        "idx": 754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}",
        "output": "1",
        "idx": 3557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_copy(uint8_t *frame, int width, int height,\n\n                       const uint8_t *src, const uint8_t *src_end)\n\n{\n\n    const int size = width * height;\n\n\n\n    if (src_end - src < size)\n\n        return -1;\n\n    bytestream_get_buffer(&src, frame, size);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstV, dstU, src1, width);\n\n}\n",
        "output": "0",
        "idx": 1534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)\n\n{\n\n    unsigned nz = idx >> 12;\n\n\n\n    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));\n\n\n\n    return dst + 4;\n\n}\n",
        "output": "1",
        "idx": 1000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int term_addstr(TERM_WINDOW *window, const char *str)\n{\n\tint len, raw_len;\n\tunichar tmp;\n\tconst char *ptr;\n\n\tif (vcmove) term_move_real();\n\n\tlen = 0;\n\traw_len = strlen(str);\n\n\t/* The string length depends on the terminal encoding */\n\n\tptr = str;\n\n\tif (term_type == TERM_TYPE_UTF8) {\n\t\twhile (*ptr != '\\0') {\n\t\t\ttmp = g_utf8_get_char(ptr);\n\t\t\tlen += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;\n\t\t\tptr = g_utf8_next_char(ptr);\n\t\t}\n\t} else\n\t\tlen = raw_len;\n\n        term_printed_text(len);\n\n\t/* Use strlen() here since we need the number of raw bytes */\n\tfwrite(str, 1, raw_len, window->term->out);\n\n\treturn len;\n}",
        "output": "1",
        "idx": 1007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void isis_notif_lsp_error(const struct isis_circuit *circuit,\n\t\t\t  const uint8_t *lsp_id, const char *raw_pdu,\n\t\t\t  size_t raw_pdu_len,\n\t\t\t  __attribute__((unused)) uint32_t offset,\n\t\t\t  __attribute__((unused)) uint8_t tlv_type)\n{\n\tconst char *xpath = \"/frr-isisd:lsp-error-detected\";\n\tstruct list *arguments = yang_data_list_new();\n\tchar xpath_arg[XPATH_MAXLEN];\n\tstruct yang_data *data;\n\tstruct isis_area *area = circuit->area;\n\n\tnotif_prep_instance_hdr(xpath, area, \"default\", arguments);\n\tnotif_prepr_iface_hdr(xpath, circuit, arguments);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/lsp-id\", xpath);\n\tdata = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));\n\tlistnode_add(arguments, data);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/raw-pdu\", xpath);\n\tdata = yang_data_new(xpath_arg, raw_pdu);\n\tlistnode_add(arguments, data);\n\t/* ignore offset and tlv_type which cannot be set properly */\n\n\thook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);\n\n\tnb_notification_send(xpath, arguments);\n}",
        "output": "1",
        "idx": 5237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __poll_t iowarrior_poll(struct file *file, poll_table * wait)\n{\n\tstruct iowarrior *dev = file->private_data;\n\t__poll_t mask = 0;\n\n\tif (!dev->present)\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tpoll_wait(file, &dev->read_wait, wait);\n\tpoll_wait(file, &dev->write_wait, wait);\n\n\tif (!dev->present)\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tif (read_index(dev) != -1)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}",
        "output": "0",
        "idx": 1289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 blkg_prfill_rwstat_field(struct seq_file *sf,\n\t\t\t\t    struct blkg_policy_data *pd, int off)\n{\n\tstruct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);\n\n\treturn __blkg_prfill_rwstat(sf, pd, &rwstat);\n}",
        "output": "0",
        "idx": 190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {\n\t\tsapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_GET];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_GET]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_GET] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\t\n\treturn 0; /* don't rearm */\n}",
        "output": "1",
        "idx": 2268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)\n{\n    FDrive *cur_drv = get_cur_drv(fdctrl);\n\n    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {\n        /* Command parameters done */\n        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {\n            fdctrl->fifo[0] = fdctrl->fifo[1];\n            fdctrl->fifo[2] = 0;\n            fdctrl->fifo[3] = 0;\n            fdctrl_set_fifo(fdctrl, 4);\n        } else {\n            fdctrl_reset_fifo(fdctrl);\n        }\n    } else if (fdctrl->data_len > 7) {\n        /* ERROR */\n        fdctrl->fifo[0] = 0x80 |\n            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);\n        fdctrl_set_fifo(fdctrl, 1);\n    }\n}",
        "output": "1",
        "idx": 5051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void x25_kill_by_neigh(struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\n\twrite_lock_bh(&x25_list_lock);\n\n\tsk_for_each(s, &x25_list)\n\t\tif (x25_sk(s)->neighbour == nb)\n\t\t\tx25_disconnect(s, ENETUNREACH, 0, 0);\n\n\twrite_unlock_bh(&x25_list_lock);\n\n\t/* Remove any related forwards */\n\tx25_clear_forward_by_dev(nb->dev);\n}",
        "output": "1",
        "idx": 5871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void close_connection(h2o_http2_conn_t *conn)\n{\n    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;\n\n    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {\n        /* there is a pending write, let on_write_complete actually close the connection */\n    } else {\n        close_connection_now(conn);\n    }\n}",
        "output": "1",
        "idx": 2952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "task_function_call(struct task_struct *p, remote_function_f func, void *info)\n{\n\tstruct remote_function_call data = {\n\t\t.p\t= p,\n\t\t.func\t= func,\n\t\t.info\t= info,\n\t\t.ret\t= -EAGAIN,\n\t};\n\tint ret;\n\n\tfor (;;) {\n\t\tret = smp_call_function_single(task_cpu(p), remote_function,\n\t\t\t\t\t       &data, 1);\n\t\tif (!ret)\n\t\t\tret = data.ret;\n\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n\n    size_t len)\n\n{\n\n    hwaddr mapped_len = 0;\n\n    struct iovec *ventry;\n\n    assert(pkt);\n\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n\n\n    if (!len) {\n\n        return true;\n\n     }\n\n\n\n    ventry = &pkt->raw[pkt->raw_frags];\n\n    mapped_len = len;\n\n\n\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n\n    ventry->iov_len = mapped_len;\n\n    pkt->raw_frags += !!ventry->iov_base;\n\n\n\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n",
        "output": "0",
        "idx": 2797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 4266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n",
        "output": "0",
        "idx": 3974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qbus_list_bus(DeviceState *dev, char *dest, int len)\n\n{\n\n    BusState *child;\n\n    const char *sep = \" \";\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\",\n\n                    dev->id ? dev->id : dev->info->name);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name);\n\n        sep = \", \";\n\n    }\n\n}\n",
        "output": "0",
        "idx": 11
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vnc_zrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    vs->zrle.type = VNC_ENCODING_ZRLE;\n    return zrle_send_framebuffer_update(vs, x, y, w, h);\n}",
        "output": "1",
        "idx": 99
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}",
        "output": "1",
        "idx": 2603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}",
        "output": "1",
        "idx": 2300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual bool str_needs_quotes() { return TRUE; }",
        "output": "0",
        "idx": 800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned int ldb_get_flags(struct ldb_context *ldb)\n{\n\treturn ldb->flags;\n}",
        "output": "0",
        "idx": 5965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gui_bg_default(void)\n{\n    if (gui_get_lightness(gui.back_pixel) < 127)\n\treturn (char_u *)\"dark\";\n    return (char_u *)\"light\";\n}",
        "output": "0",
        "idx": 4007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(hash_update_file)\n{\n\tzval *zhash, *zcontext = NULL;\n\tphp_hash_data *hash;\n\tphp_stream_context *context;\n\tphp_stream *stream;\n\tchar *filename, buf[1024];\n\tint filename_len, n;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|r\", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", REPORT_ERRORS, NULL, context);\n\tif (!stream) {\n\t\t/* Stream will report errors opening file */\n\t\tRETURN_FALSE;\n\t}\n\n\twhile ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {\n\t\thash->ops->hash_update(hash->context, (unsigned char *) buf, n);\n\t}\n\tphp_stream_close(stream);\n\n\tRETURN_TRUE;\n}",
        "output": "1",
        "idx": 4349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbTightExtensionClientClose(rfbClientPtr cl, void* data) {\n\n\tif(data != NULL)\n\t\tfree(data);\n\n}",
        "output": "1",
        "idx": 2356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)\n{\n\tGList **list;\n\n\tlist = callback_data;\n\t*list = g_list_prepend (*list, g_strdup (key));\n}",
        "output": "0",
        "idx": 4633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    GetBitContext bits;\n\n    AACADTSHeaderInfo hdr;\n\n    int size;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp;\n\n\n\n    tmp.u64 = av_be2ne64(state);\n\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n\n\n\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n\n        return 0;\n\n    *need_next_header = 0;\n\n    *new_frame_start  = 1;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n\n    hdr_info->samples     = hdr.samples;\n\n    hdr_info->bit_rate    = hdr.bit_rate;\n\n    return size;\n\n}\n",
        "output": "1",
        "idx": 2546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qb_rb_chunk_write(struct qb_ringbuffer_s * rb, const void *data, size_t len)\n{\n\tchar *dest = qb_rb_chunk_alloc(rb, len);\n\tint32_t res = 0;\n\n\tif (rb == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (dest == NULL) {\n\t\treturn -errno;\n\t}\n\n\tmemcpy(dest, data, len);\n\n\tres = qb_rb_chunk_commit(rb, len);\n\tif (res < 0) {\n\t\treturn res;\n\t}\n\n\treturn len;\n}",
        "output": "0",
        "idx": 6296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Mounter::umount(const QString &mountPoint, int pid)\n{\n    if (calledFromDBus()) {\n        registerPid(pid);\n    }\n\n    if (mpOk(mountPoint)) {\n        QProcess *proc=new QProcess(this);\n        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));\n        proc->start(\"umount\", QStringList() << mountPoint);\n        proc->setProperty(\"mp\", mountPoint);\n        proc->setProperty(\"pid\", pid);\n        procCount++;\n    } else {\n        emit umountStatus(mountPoint, pid, -1);\n    }\n}",
        "output": "1",
        "idx": 540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}",
        "output": "1",
        "idx": 2593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\treturn -1;\n}",
        "output": "1",
        "idx": 5342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sys_var *find_sys_var(THD *thd, const char *str, size_t length)\n{\n  return find_sys_var_ex(thd, str, length, false, false);\n}",
        "output": "0",
        "idx": 3800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\ttimer_stats_timer_set_start_info(timer);\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\tspin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\tspin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}",
        "output": "1",
        "idx": 5875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;",
        "output": "1",
        "idx": 4690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hardware_disable(void)\n{\n\tvmclear_local_loaded_vmcss();\n\n\tif (cpu_vmxoff())\n\t\tkvm_spurious_fault();\n\n\tintel_pt_handle_vmx(0);\n}",
        "output": "0",
        "idx": 3273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void dccp_event_ack_sent(struct sock *sk)\n{\n\tinet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);\n}",
        "output": "0",
        "idx": 1469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,\n\t\t\t\t\t\t\t uint8_t *dst,const uint8_t *src,\n\t\t\t\t\t\t\t int dstpitch,int srcpitch,\n\t\t\t\t\t\t\t int bltwidth,int bltheight)\n{\n    int x,y;\n    uint8_t p1, p2;\n    dstpitch += bltwidth;\n    srcpitch += bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x+=2) {\n\t    p1 = *(dst-1);\n\t    p2 = *dst;\n            ROP_OP(&p1, *(src - 1));\n            ROP_OP(&p2, *src);\n\t    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {\n\t\t*(dst-1) = p1;\n\t\t*dst = p2;\n\t    }\n            dst-=2;\n            src-=2;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}",
        "output": "1",
        "idx": 4941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  struct kvm_run *kvm_run)\n{\n\treturn (!vcpu->arch.irq_summary &&\n\t\tkvm_run->request_interrupt_window &&\n\t\tvcpu->arch.interrupt_window_open &&\n\t\t(kvm_x86_ops->get_rflags(vcpu) & X86_EFLAGS_IF));\n}",
        "output": "0",
        "idx": 1732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QString *qstring_from_substr(const char *str, int start, int end)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = g_malloc(sizeof(*qstring));\n\n\n\n    qstring->length = end - start + 1;\n\n    qstring->capacity = qstring->length;\n\n\n\n    qstring->string = g_malloc(qstring->capacity + 1);\n\n    memcpy(qstring->string, str + start, qstring->length);\n\n    qstring->string[qstring->length] = 0;\n\n\n\n    QOBJECT_INIT(qstring, &qstring_type);\n\n\n\n    return qstring;\n\n}\n",
        "output": "0",
        "idx": 1350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)\n{\n    const char* cLabelFld;\n    char Type[256], Label[256];\n    int nTable;\n\n    _cmsAssert(hIT8 != NULL);\n\n    if (cField != NULL && *cField == 0)\n            cField = \"LABEL\";\n\n    if (cField == NULL)\n            cField = \"LABEL\";\n\n    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);\n    if (!cLabelFld) return -1;\n\n    if (sscanf(cLabelFld, \"%255s %d %255s\", Label, &nTable, Type) != 3)\n            return -1;\n\n    if (ExpectedType != NULL && *ExpectedType == 0)\n        ExpectedType = NULL;\n\n    if (ExpectedType) {\n\n        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;\n    }\n\n    return cmsIT8SetTable(hIT8, nTable);\n}",
        "output": "0",
        "idx": 4321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n",
        "output": "1",
        "idx": 858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n",
        "output": "1",
        "idx": 18
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
        "output": "0",
        "idx": 1859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold void init_atrac3_transforms(ATRAC3Context *q) {\n\n    float enc_window[256];\n\n    int i;\n\n\n\n    /* Generate the mdct window, for details see\n\n     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */\n\n    for (i=0 ; i<256; i++)\n\n        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;\n\n\n\n    if (!mdct_window[0])\n\n        for (i=0 ; i<256; i++) {\n\n            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);\n\n            mdct_window[511-i] = mdct_window[i];\n\n        }\n\n\n\n    /* Initialize the MDCT transform. */\n\n    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);\n\n}\n",
        "output": "1",
        "idx": 5397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_lswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    int start = rD(ctx->opcode);\n\n    int ra = rA(ctx->opcode);\n\n    int nr;\n\n\n\n    if (nb == 0)\n\n        nb = 32;\n\n    nr = (nb + 3) / 4;\n\n    if (unlikely(lsw_reg_in_range(start, nr, ra))) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(start);\n\n    gen_helper_lsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n",
        "output": "1",
        "idx": 963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)\n\n{\n\n    FILE* f;\n\n    char line[1024];\n\n    char  cmd[1024];\n\n    FFServerIPAddressACL *acl = NULL;\n\n    int line_num = 0;\n\n    const char *p;\n\n\n\n    f = fopen(stream->dynamic_acl, \"r\");\n\n    if (!f) {\n\n        perror(stream->dynamic_acl);\n\n        return NULL;\n\n    }\n\n\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n\n\n\n    /* Build ACL */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL)\n\n            break;\n\n        line_num++;\n\n        p = line;\n\n        while (av_isspace(*p))\n\n            p++;\n\n        if (*p == '\\0' || *p == '#')\n\n            continue;\n\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);\n\n    }\n\n    fclose(f);\n\n    return acl;\n\n}\n",
        "output": "0",
        "idx": 5794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void buildFinishedTLS(SSL& ssl, Finished& fin, const opaque* sender) \n{\n    opaque handshake_hash[FINISHED_SZ];\n\n    ssl.useHashes().use_MD5().get_digest(handshake_hash);\n    ssl.useHashes().use_SHA().get_digest(&handshake_hash[MD5_LEN]);\n\n    const opaque* side;\n    if ( strncmp((const char*)sender, (const char*)client, SIZEOF_SENDER) == 0)\n        side = tls_client;\n    else\n        side = tls_server;\n\n    PRF(fin.set_md5(), TLS_FINISHED_SZ, \n        ssl.getSecurity().get_connection().master_secret_, SECRET_LEN, \n        side, FINISHED_LABEL_SZ, \n        handshake_hash, FINISHED_SZ);\n\n    fin.set_length(TLS_FINISHED_SZ);  // shorter length for TLS\n}",
        "output": "0",
        "idx": 6032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n",
        "output": "0",
        "idx": 3171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void perf_event_exit_cpu(int cpu) { }",
        "output": "1",
        "idx": 780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stonith_set_config_file(Stonith* s, const char * configname)\n{\n\tFILE *\t\tcfgfile;\n\n\tchar\t\tline[1024];\n\n\tif ((cfgfile = fopen(configname, \"r\")) == NULL)  {\n\t\tLOG(PIL_CRIT, \"Cannot open %s\", configname);\n\t\treturn(S_BADCONFIG);\n\t}\n\twhile (fgets(line, sizeof(line), cfgfile) != NULL){\n\t\tint\tlen;\n\t\t\n\t\tif (*line == '#' || *line == '\\n' || *line == EOS) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t/*remove the new line in the end*/\n\t\tlen = strnlen(line, sizeof(line)-1);\n\t\tif (line[len-1] == '\\n'){\n\t\t\tline[len-1] = '\\0';\n\t\t}else{\n\t\t\tline[len] = '\\0';\n\t\t}\n\t\n\t\tfclose(cfgfile);\n\t\treturn stonith_set_config_info(s, line);\n\t}\n\tfclose(cfgfile);\n\treturn S_BADCONFIG;\n}",
        "output": "0",
        "idx": 5781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\n\t/* We can reliably put at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\tassert(n >= 0 && n < 32);\n\t/* Ensure that only the bits to be output are nonzero. */\n\tassert(!(v & (~JAS_ONES(n))));\n\n\t/* Put the desired number of bits to the specified bit stream. */\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 2853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n",
        "output": "0",
        "idx": 3464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tBOOL isNotHmacSession = (*target < HMAC_SESSION_FIRST ) || (*target > HMAC_SESSION_LAST);\n\tBOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST);\n\tBOOL isNotLegalPwd = (*target != TPM_RS_PW) || !allowPwd;\n\tif (isNotHmacSession &&\n\t    isNotPolicySession &&\n\t    isNotLegalPwd) {\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HBasicBlock::Verify() {\n  // Check that every block is finished.\n  ASSERT(IsFinished());\n  ASSERT(block_id() >= 0);\n\n  // Check that the incoming edges are in edge split form.\n  if (predecessors_.length() > 1) {\n    for (int i = 0; i < predecessors_.length(); ++i) {\n      ASSERT(predecessors_[i]->end()->SecondSuccessor() == NULL);\n    }\n  }\n}",
        "output": "0",
        "idx": 1812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}",
        "output": "1",
        "idx": 1851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\t\n\tobject->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}",
        "output": "1",
        "idx": 4015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL ber_read_universal_tag(wStream* s, BYTE tag, BOOL pc)\n{\n\tBYTE byte;\n\n\tif(Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte != (BER_CLASS_UNIV | BER_PC(pc) | (BER_TAG_MASK & tag)))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 4618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case 128:\n\t  case 256:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 4926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_compressor(int type)\n{\n\tstruct compressor_entry *ce;\n\tstruct compressor *cp = NULL;\n\n\tspin_lock(&compressor_list_lock);\n\tce = find_comp_entry(type);\n\tif (ce) {\n\t\tcp = ce->comp;\n\t\tif (!try_module_get(cp->owner))\n\t\t\tcp = NULL;\n\t}\n\tspin_unlock(&compressor_list_lock);\n\treturn cp;\n}",
        "output": "0",
        "idx": 3294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {\n  ASSERT(call->arguments()->length() == 0);\n  if (function_state()->outer() != NULL) {\n    // We are generating graph for inlined function.\n    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN\n        ? graph()->GetConstantTrue()\n        : graph()->GetConstantFalse();\n    return ast_context()->ReturnValue(value);\n  } else {\n    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,\n                                        call->id());\n  }\n}",
        "output": "0",
        "idx": 5042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "srs_set_separator(srs_t *srs, char value)\n{\n\tif (strchr(srs_separators, value) == NULL)\n\t\treturn SRS_ESEPARATORINVALID;\n\tsrs->separator = value;\n\treturn SRS_SUCCESS;\n}",
        "output": "0",
        "idx": 3278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {\n    _createBuiltinRolesForDBIfNeeded(dbname);\n\n    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName(\"\", dbname));\n    std::string afterDB = dbname;\n    afterDB.push_back('\\0');\n    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName(\"\", afterDB));\n    return makeRoleNameIterator(lower, upper);\n}",
        "output": "0",
        "idx": 163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n\n{\n\n    int res = 0;\n\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n\n        return AVERROR_INVALIDDATA;\n\n    while (--n >= 0) {\n\n        res <<= 1;\n\n        if (s->bit_index == 0) {\n\n            s->bit_index = 7 + (*s->buf != 0xff);\n\n            s->buf++;\n\n        }\n\n        s->bit_index--;\n\n        res |= (*s->buf >> s->bit_index) & 1;\n\n    }\n\n    return res;\n\n}\n",
        "output": "1",
        "idx": 2304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    if (!txdb.EraseTxIndex(*this))\n        return error(\"DisconnectInputs() : EraseTxPos failed\");\n\n    return true;\n}",
        "output": "1",
        "idx": 1923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void disas_a64_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t insn;\n\n\n\n    insn = arm_ldl_code(env, s->pc, s->bswap_code);\n\n    s->insn = insn;\n\n    s->pc += 4;\n\n\n\n    switch ((insn >> 24) & 0x1f) {\n\n    default:\n\n        unallocated_encoding(s);\n\n        break;\n\n    }\n\n\n\n    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {\n\n        /* go through the main loop for single step */\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encode_frame(FlacEncodeContext *s)\n\n{\n\n    int ch, count;\n\n\n\n    count = count_frame_header(s);\n\n\n\n    for (ch = 0; ch < s->channels; ch++)\n\n        count += encode_residual_ch(s, ch);\n\n\n\n    count += (8 - (count & 7)) & 7; // byte alignment\n\n    count += 16;                    // CRC-16\n\n\n\n    return count >> 3;\n\n}\n",
        "output": "1",
        "idx": 6033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GetHeriarchy(\n\t     TPMI_DH_OBJECT   handle         // IN :object handle\n\t     )\n{\n    OBJECT          *object = HandleToObject(handle);\n    return ObjectGetHierarchy(object);\n}",
        "output": "0",
        "idx": 4628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_ppp_heuristic_guess(netdissect_options *ndo,\n                            register const u_char *p, u_int length)\n{\n    switch(EXTRACT_16BITS(p)) {\n    case PPP_IP :\n    case PPP_OSI :\n    case PPP_MPLS_UCAST :\n    case PPP_MPLS_MCAST :\n    case PPP_IPCP :\n    case PPP_OSICP :\n    case PPP_MPLSCP :\n    case PPP_LCP :\n    case PPP_PAP :\n    case PPP_CHAP :\n    case PPP_ML :\n    case PPP_IPV6 :\n    case PPP_IPV6CP :\n        ppp_print(ndo, p, length);\n        break;\n\n    default:\n        return 0; /* did not find a ppp header */\n        break;\n    }\n    return 1; /* we printed a ppp packet */\n}",
        "output": "0",
        "idx": 3710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}",
        "output": "1",
        "idx": 5890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int standard_decode_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0;\n\n\n\n    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);\n\n    skip_bits(gb, 2); //framecnt unused\n\n    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);\n\n    v->s.pict_type = get_bits(gb, 1);\n\n    if (v->s.avctx->max_b_frames)\n\n    {\n\n        if (!v->s.pict_type)\n\n        {\n\n            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;\n\n            else v->s.pict_type = B_TYPE;\n\n        }\n\n        else v->s.pict_type = P_TYPE;\n\n    }\n\n    else v->s.pict_type++;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case I_TYPE: status = decode_i_picture_header(v); break;\n\n    case P_TYPE: status = decode_p_picture_primary_header(v); break;\n\n    case BI_TYPE:\n\n    case B_TYPE: status = decode_b_picture_primary_header(v); break;\n\n    }\n\n\n\n    if (status == FRAME_SKIPED)\n\n    {\n\n      av_log(v->s.avctx, AV_LOG_INFO, \"Skipping frame...\\n\");\n\n      return status;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int process_open(ProcessHandle process, const char *fname) {\n\tint rv = process_open_nofail(process, fname);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot open /proc/%d/%s: %s\\n\", process->pid, fname, strerror(errno));\n\t\texit(1);\n\t}\n\n\treturn rv;\n}",
        "output": "1",
        "idx": 5330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int display_open(void *handle, void *device)\n{\n\n    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));\n    if (img == NULL)\n        return -1;\n    memset(img, 0, sizeof(IMAGE));\n\n    if (first_image == NULL) {\n        gdk_rgb_init();\n        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());\n        gtk_widget_set_default_visual(gdk_rgb_get_visual());\n    }\n\n    /* add to list */\n    if (first_image)\n        img->next = first_image;\n    first_image = img;\n\n    /* remember device and handle */\n    img->handle = handle;\n    img->device = device;\n\n    /* create window */\n    window_create(img);\n\n    gtk_main_iteration_do(FALSE);\n    return 0;\n}",
        "output": "1",
        "idx": 1607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFAnnotationObjectHelper::getFlags()\n{\n    QPDFObjectHandle flags_obj = this->oh.getKey(\"/F\");\n    return flags_obj.isInteger() ? flags_obj.getIntValue() : 0;\n}",
        "output": "1",
        "idx": 786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *GetLocaleMonitorMessage(const char *text)\n{\n  char\n    message[MaxTextExtent],\n    tag[MaxTextExtent];\n\n  const char\n    *locale_message;\n\n  register char\n    *p;\n\n  (void) CopyMagickString(tag,text,MaxTextExtent);\n  p=strrchr(tag,'/');\n  if (p != (char *) NULL)\n    *p='\\0';\n  (void) FormatLocaleString(message,MaxTextExtent,\"Monitor/%s\",tag);\n  locale_message=GetLocaleMessage(message);\n  if (locale_message == message)\n    return(text);\n  return(locale_message);\n}",
        "output": "0",
        "idx": 3371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 5362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n\n{\n\n    int i;\n\n\n\n    if ((p[1] & 0xF) == 3) {\n\n        /* NAA designator type */\n\n        if (p[3] != 8) {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = ldq_be_p(p + 4);\n\n        return 0;\n\n    }\n\n\n\n    if ((p[1] & 0xF) == 8) {\n\n        /* SCSI name string designator type */\n\n        if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) {\n\n            return -EINVAL;\n\n        }\n\n        if (p[3] > 20 && p[24] != ',') {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = 0;\n\n        for (i = 8; i < 24; i++) {\n\n            char c = toupper(p[i]);\n\n            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);\n\n            *p_wwn = (*p_wwn << 4) | c;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -EINVAL;\n\n}\n",
        "output": "1",
        "idx": 5470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 2898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n",
        "output": "1",
        "idx": 822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_chroma_qp(H264Context *h, int t, int qscale){\n\n    return h->pps.chroma_qp_table[t][qscale];\n\n}\n",
        "output": "0",
        "idx": 4849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_language) \n{\n    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 2786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));",
        "output": "1",
        "idx": 4948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n\n  // Evaluate the content setting rules before\n  // IsWhitelistedForContentSettings(); if there is only the default rule\n  // allowing all scripts, it's quicker this way.\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}",
        "output": "1",
        "idx": 3662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int svg_probe(AVProbeData *p)\n{\n    const uint8_t *b = p->buf;\n    const uint8_t *end = p->buf + p->buf_size;\n    if (memcmp(p->buf, \"<?xml\", 5))\n        return 0;\n    while (b < end) {\n        b += ff_subtitles_next_line(b);\n        if (b >= end - 4)\n            return 0;\n        if (!memcmp(b, \"<svg\", 4))\n            return AVPROBE_SCORE_EXTENSION + 1;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 2140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_w32_stat(const char *path, struct stat *st)\n{\n    const char *p;\n    char *buf1, *s, *end;\n    int len;\n    int ret;\n\n    if (!path || !st) {\n\terrno = EFAULT;\n\treturn -1;\n    }\n    buf1 = ALLOCA_N(char, strlen(path) + 2);\n    for (p = path, s = buf1; *p; p++, s++) {\n\tif (*p == '/')\n\t    *s = '\\\\';\n\telse\n\t    *s = *p;\n    }\n    *s = '\\0';\n    len = s - buf1;\n    if (!len || '\\\"' == *(--s)) {\n\terrno = ENOENT;\n\treturn -1;\n    }\n    end = CharPrev(buf1, buf1 + len);\n\n    if (isUNCRoot(buf1)) {\n\tif (*end == '.')\n\t    *end = '\\0';\n\telse if (*end != '\\\\')\n\t    strcat(buf1, \"\\\\\");\n    } else if (*end == '\\\\' || *end == ':')\n\tstrcat(buf1, \".\");\n\n    ret = stat(buf1, st);\n    if (ret == 0) {\n\tst->st_mode &= ~(S_IWGRP | S_IWOTH);\n    }\n    return ret;\n}",
        "output": "0",
        "idx": 5590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "activate_callback (GList    *files,\n                   gpointer  callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    GList *l, *next;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    parameters->files_handle = NULL;\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n\n        if (file_was_not_mounted (file))\n        {\n            if (parameters->tried_mounting)\n            {\n                launch_location_free (location);\n                parameters->locations = g_list_delete_link (parameters->locations, l);\n            }\n            else\n            {\n                parameters->not_mounted = g_list_prepend (parameters->not_mounted,\n                                                          nautilus_file_ref (file));\n            }\n            continue;\n        }\n    }\n\n\n    if (parameters->not_mounted != NULL)\n    {\n        activation_mount_not_mounted (parameters);\n    }\n    else\n    {\n        activate_files (parameters);\n    }\n}",
        "output": "0",
        "idx": 3353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_header(GArray *linker, GArray *table_data,\n\n             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n\n             const char *oem_table_id)\n\n{\n\n    memcpy(&h->signature, sig, 4);\n\n    h->length = cpu_to_le32(len);\n\n    h->revision = rev;\n\n    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n\n\n\n    if (oem_table_id) {\n\n        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n\n    } else {\n\n        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n\n        memcpy(h->oem_table_id + 4, sig, 4);\n\n    }\n\n\n\n    h->oem_revision = cpu_to_le32(1);\n\n    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n\n    h->asl_compiler_revision = cpu_to_le32(1);\n\n    h->checksum = 0;\n\n    /* Checksum to be filled in by Guest linker */\n\n    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,\n\n                                    table_data->data, h, len, &h->checksum);\n\n}\n",
        "output": "0",
        "idx": 937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {\n  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(GetParam()));\n  http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(GetParam()));\n  client_ = std::make_unique<TestClientConnectionImpl>(\n      client_connection_, client_callbacks_, stats_store_, client_http2_options_,\n      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());\n  server_ = std::make_unique<TestServerConnectionImpl>(\n      server_connection_, server_callbacks_, stats_store_, server_http2_options_,\n      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);\n\n  for (int i = 0; i < 101; ++i) {\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n\n    TestRequestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers);\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n    request_encoder_->encodeHeaders(request_headers, true);\n  }\n}",
        "output": "1",
        "idx": 1752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      DSA_Signature_Operation(const DSA_PrivateKey& dsa,\n                              const std::string& emsa,\n                              RandomNumberGenerator& rng) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n\n         m_b = BigInt::random_integer(rng, 2, dsa.group_q());\n         m_b_inv = inverse_mod(m_b, dsa.group_q());\n         }",
        "output": "0",
        "idx": 5867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    MemInStream(const void* data, int len, bool deleteWhenDone_=false)\n      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)\n    {\n      ptr = start;\n      end = start + len;\n    }",
        "output": "1",
        "idx": 2055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 28
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}",
        "output": "1",
        "idx": 5963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n",
        "output": "1",
        "idx": 2311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_bin_load_io_at_offset_as(RBin *bin, RIODesc *desc, ut64 baseaddr, ut64 loadaddr, int xtr_idx, ut64 offset, const char *name) {\n#if 1\n\t// adding file_sz to help reduce the performance impact on the system\n\t// in this case the number of bytes read will be limited to 2MB (MIN_LOAD_SIZE)\n\t// if it fails, the whole file is loaded.\n\tconst ut64 MAX_LOAD_SIZE = 128 * (1 << 10 << 10);\n\tint res = r_bin_load_io_at_offset_as_sz (bin, desc, baseaddr,\n\t\tloadaddr, xtr_idx, offset, name, MAX_LOAD_SIZE);\n\tif (res)\n\t\treturn res;\n#endif\n\treturn r_bin_load_io_at_offset_as_sz (bin, desc, baseaddr,\n\t\tloadaddr, xtr_idx, offset, name, UT64_MAX);\n}",
        "output": "0",
        "idx": 1544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    double d;\n\n    char *ptr;\n\n    FdMigrationState *s;\n\n    const char *value = qdict_get_str(qdict, \"value\");\n\n\n\n    d = strtod(value, &ptr);\n\n    switch (*ptr) {\n\n    case 'G': case 'g':\n\n        d *= 1024;\n\n    case 'M': case 'm':\n\n        d *= 1024;\n\n    case 'K': case 'k':\n\n        d *= 1024;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    max_throttle = (uint32_t)d;\n\n    s = migrate_to_fms(current_migration);\n\n\n\n    if (s) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n    \n\n}\n",
        "output": "0",
        "idx": 1727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_chroma_format(AVCodecContext *avctx)\n\n{\n\n    int num_formats = sizeof(schro_pixel_format_map) /\n\n                      sizeof(schro_pixel_format_map[0]);\n\n    int idx;\n\n\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    for (idx = 0; idx < num_formats; ++idx) {\n\n        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {\n\n            p_schro_params->format->chroma_format =\n\n                            schro_pixel_format_map[idx].schro_pix_fmt;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR,\n\n           \"This codec currently only supports planar YUV 4:2:0, 4:2:2\"\n\n           \" and 4:4:4 formats.\\n\");\n\n\n\n    return -1;\n\n}\n",
        "output": "1",
        "idx": 2047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n",
        "output": "0",
        "idx": 5427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    MiscState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr & LED_MAXADDR;\n\n    MISC_DPRINTF(\"Write diagnostic LED reg 0x\" TARGET_FMT_plx \" =  %x\\n\", addr,\n\n                 val);\n\n    switch (saddr) {\n\n    case 0:\n\n        s->leds = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtnl_group_changelink(struct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ProcessHandle switch_to_sandbox(ProcessHandle parent) {\n\t// firejail forks many children, identify the sandbox child\n\t// using a pidfile created by the sandbox parent\n\tpid_t pid = read_sandbox_pidfile(process_get_pid(parent));\n\n\t// pin the sandbox child\n\tfmessage(\"Switching to pid %d, the first child process inside the sandbox\\n\", pid);\n\tProcessHandle sandbox = pin_child_process(parent, pid);\n\n\treturn sandbox;\n}",
        "output": "0",
        "idx": 4240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
        "output": "1",
        "idx": 1736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */\n{\n\t/* parameters */\n\tchar\t\t\t *regex;\t\t\t/* Regular expression */\n\tchar\t\t\t *subject;\t\t\t/* String to match against */\n\tint\t\t\t\t  regex_len;\n\tint\t\t\t\t  subject_len;\n\tpcre_cache_entry *pce;\t\t\t\t/* Compiled regular expression */\n\tzval\t\t\t *subpats = NULL;\t/* Array for subpatterns */\n\tlong\t\t\t  flags = 0;\t\t/* Match control flags */\n\tlong\t\t\t  start_offset = 0;\t/* Where the new search starts */\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|zll\", &regex, &regex_len,\n\t\t\t\t\t\t\t  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\t/* Compile regex or get it from cache. */\n\tif ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_pcre_match_impl(pce, subject, subject_len, return_value, subpats, \n\t\tglobal, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);\n}",
        "output": "1",
        "idx": 6176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n",
        "output": "0",
        "idx": 3589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UrlQuery::UrlQuery(const std::string& encoded_str) {\n  if (!encoded_str.empty()) {\n    // Split into key value pairs separated by '&'.\n    for (std::size_t i = 0; i != std::string::npos;) {\n      std::size_t j = encoded_str.find_first_of('&', i);\n\n      std::string kv;\n      if (j == std::string::npos) {\n        kv = encoded_str.substr(i);\n        i = std::string::npos;\n      } else {\n        kv = encoded_str.substr(i, j - i);\n        i = j + 1;\n      }\n\n      string_view key;\n      string_view value;\n      if (SplitKV(kv, '=', false, &key, &value)) {\n        parameters_.push_back(\n            { Url::DecodeUnsafe(key), Url::DecodeUnsafe(value) });\n      }\n    }\n  }\n}",
        "output": "0",
        "idx": 946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n",
        "output": "1",
        "idx": 2188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n",
        "output": "1",
        "idx": 6283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void downmix_3f_2r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void g_dhcp_server_stop(GDHCPServer *dhcp_server)\n{\n\t/* Save leases, before stop; load them before start */\n\tsave_lease(dhcp_server);\n\n\tif (dhcp_server->listener_watch > 0) {\n\t\tg_source_remove(dhcp_server->listener_watch);\n\t\tdhcp_server->listener_watch = 0;\n\t}\n\n\tdhcp_server->listener_channel = NULL;\n\n\tdhcp_server->started = FALSE;\n}",
        "output": "0",
        "idx": 5511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {\n  auto rc = sqliteAuthorizer(\n      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(\n      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_OK, rc);\n}",
        "output": "0",
        "idx": 3399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool con_is_visible(const struct vc_data *vc)\n{\n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn *vc->vc_display_fg == vc;\n}",
        "output": "0",
        "idx": 136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qemu_suspend_requested(void)\n\n{\n\n    int r = suspend_requested;\n\n    suspend_requested = 0;\n\n    return r;\n\n}\n",
        "output": "0",
        "idx": 967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\n\t/* First copy data that has already been decoded and buffered. */\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\n\t/* Decode some more. */\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\n\tpflac->ptr = NULL ;\n\n\treturn pflac->pos ;\n} /* flac_read_loop */",
        "output": "1",
        "idx": 4855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)\n{\n\tif (copy_from_user(kp, up, sizeof(*up)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "output": "1",
        "idx": 4915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)\n{\n    /* create the t2 structure */\n    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));\n    if (!l_t2) {\n        return NULL;\n    }\n\n    l_t2->image = p_image;\n    l_t2->cp = p_cp;\n\n    return l_t2;\n}",
        "output": "0",
        "idx": 3462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n",
        "output": "0",
        "idx": 1356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void acpi_build_update(void *build_opaque, uint32_t offset)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = 1;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    assert(acpi_data_len(tables.table_data) == build_state->table_size);\n\n    memcpy(build_state->table_ram, tables.table_data->data,\n\n           build_state->table_size);\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n",
        "output": "1",
        "idx": 5732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntop_del_hash_redis(lua_State* vm) {\n  char *key, *member;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  redis->hashDel(key, member);\n\n  return(CONST_LUA_OK);\n}",
        "output": "0",
        "idx": 2577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "armpmu_event_set_period(struct perf_event *event,\n\t\t\tstruct hw_perf_event *hwc,\n\t\t\tint idx)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\ts64 left = local64_read(&hwc->period_left);\n\ts64 period = hwc->sample_period;\n\tint ret = 0;\n\n\tif (unlikely(left <= -period)) {\n\t\tleft = period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\n\tif (unlikely(left <= 0)) {\n\t\tleft += period;\n\t\tlocal64_set(&hwc->period_left, left);\n\t\thwc->last_period = period;\n\t\tret = 1;\n\t}\n\n\t/*\n\t * Limit the maximum period to prevent the counter value\n\t * from overtaking the one we are about to program. In\n\t * effect we are reducing max_period to account for\n\t * interrupt latency (and we are being very conservative).\n\t */\n\tif (left > (armpmu->max_period >> 1))\n\t\tleft = armpmu->max_period >> 1;\n\n\tlocal64_set(&hwc->prev_count, (u64)-left);\n\n\tarmpmu->write_counter(idx, (u64)(-left) & 0xffffffff);\n\n\tperf_event_update_userpage(event);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}",
        "output": "1",
        "idx": 3965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void asyncCloseClientOnOutputBufferLimitReached(client *c) {\n    if (!c->conn) return; /* It is unsafe to free fake clients. */\n    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));\n    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;\n    if (checkClientOutputBufferLimits(c)) {\n        sds client = catClientInfoString(sdsempty(),c);\n\n        freeClientAsync(c);\n        serverLog(LL_WARNING,\"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.\", client);\n        sdsfree(client);\n    }\n}",
        "output": "0",
        "idx": 3424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,\n                              const T& a4, const T& a5, const T& a6, const T& a7,\n                              const T& a8) {\n      CImg<T> r(9,1);\n      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8;\n      return r;\n    }",
        "output": "0",
        "idx": 96
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n",
        "output": "1",
        "idx": 577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DispatcherThread::OnNotify()\n{\n\t// this could unlock during the dispatch, but OnResult isn't expected to take that long\n\tthis->LockQueue();\n\tfor(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)\n\t{\n\t\tMySQLresult* res = i->r;\n\t\tif (res->err.code == SQL::SUCCESS)\n\t\t\ti->q->OnResult(*res);\n\t\telse\n\t\t\ti->q->OnError(res->err);\n\t\tdelete i->q;\n\t\tdelete i->r;\n\t}\n\tParent->rq.clear();\n\tthis->UnlockQueue();\n}",
        "output": "0",
        "idx": 5625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svm_free_nested(struct vcpu_svm *svm)\n{\n\tif (!svm->nested.initialized)\n\t\treturn;\n\n\tsvm_vcpu_free_msrpm(svm->nested.msrpm);\n\tsvm->nested.msrpm = NULL;\n\n\t__free_page(virt_to_page(svm->nested.vmcb02.ptr));\n\tsvm->nested.vmcb02.ptr = NULL;\n\n\t/*\n\t * When last_vmcb12_gpa matches the current vmcb12 gpa,\n\t * some vmcb12 fields are not loaded if they are marked clean\n\t * in the vmcb12, since in this case they are up to date already.\n\t *\n\t * When the vmcb02 is freed, this optimization becomes invalid.\n\t */\n\tsvm->nested.last_vmcb12_gpa = INVALID_GPA;\n\n\tsvm->nested.initialized = false;\n}",
        "output": "0",
        "idx": 2471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void compute_images_mse_16bit(PSNRContext *s,\n\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n\n                        int w, int h, double mse[4])\n\n{\n\n    int i, c, j;\n\n\n\n    for (c = 0; c < s->nb_components; c++) {\n\n        const int outw = s->planewidth[c];\n\n        const int outh = s->planeheight[c];\n\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n\n        const int ref_linesize = ref_linesizes[c] / 2;\n\n        const int main_linesize = main_linesizes[c] / 2;\n\n        uint64_t m = 0;\n\n\n\n        for (i = 0; i < outh; i++) {\n\n            for (j = 0; j < outw; j++)\n\n                m += pow2(main_line[j] - ref_line[j]);\n\n            ref_line += ref_linesize;\n\n            main_line += main_linesize;\n\n        }\n\n        mse[c] = m / (double)(outw * outh);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 5230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void wake_futex(struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\t/*\n\t * We set q->lock_ptr = NULL _before_ we wake up the task. If\n\t * a non futex wake up happens on another CPU then the task\n\t * might exit and p would dereference a non existing task\n\t * struct. Prevent this by holding a reference on p across the\n\t * wake up.\n\t */\n\tget_task_struct(p);\n\n\tplist_del(&q->list, &q->list.plist);\n\t/*\n\t * The waiting task can free the futex_q as soon as\n\t * q->lock_ptr = NULL is written, without taking any locks. A\n\t * memory barrier is required here to prevent the following\n\t * store to lock_ptr from getting ahead of the plist_del.\n\t */\n\tsmp_wmb();\n\tq->lock_ptr = NULL;\n\n\twake_up_state(p, TASK_NORMAL);\n\tput_task_struct(p);\n}",
        "output": "0",
        "idx": 4826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)\n{\n\tglue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));\n}",
        "output": "0",
        "idx": 3651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void PngImage::writeMetadata()\n    {\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::AutoPtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n\n        doWriteMetadata(*tempIo); // may throw\n        io_->close();\n        io_->transfer(*tempIo); // may throw\n\n    } // PngImage::writeMetadata",
        "output": "0",
        "idx": 3967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool LBPEvaluator::Feature :: read(const FileNode& node )\n{\n    FileNode rnode = node[CC_RECT];\n    FileNodeIterator it = rnode.begin();\n    it >> rect.x >> rect.y >> rect.width >> rect.height;\n    return true;\n}",
        "output": "1",
        "idx": 3936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n",
        "output": "1",
        "idx": 563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}",
        "output": "1",
        "idx": 2496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {\n    if (!time) {\n      return {};\n    }\n\n    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -\n                                                                start_time_monotonic_);\n  }",
        "output": "0",
        "idx": 2713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}",
        "output": "1",
        "idx": 3169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void io_req_drop_files(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->inflight_lock, flags);\n\tlist_del(&req->inflight_entry);\n\tif (waitqueue_active(&ctx->inflight_wait))\n\t\twake_up(&ctx->inflight_wait);\n\tspin_unlock_irqrestore(&ctx->inflight_lock, flags);\n\treq->flags &= ~REQ_F_INFLIGHT;\n\treq->work.files = NULL;\n}",
        "output": "1",
        "idx": 2788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void clear_file(struct inode *inode, int type)\n{\n\tF2FS_I(inode)->i_advise &= ~type;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}",
        "output": "0",
        "idx": 3657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n",
        "output": "0",
        "idx": 1067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void kvm_mmu_notifier_release(struct mmu_notifier *mn,\n\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tkvm_arch_flush_shadow_all(kvm);\n\tsrcu_read_unlock(&kvm->srcu, idx);",
        "output": "1",
        "idx": 1646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)\n\n{\n\n    InputStream  *ist = s->opaque;\n\n    DXVA2Context *ctx = ist->hwaccel_ctx;\n\n\n\n    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);\n\n}\n",
        "output": "0",
        "idx": 350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,\n\n                hwaddr addr, int *miny, int *maxy)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int src_width, dest_width;\n\n    drawfn fn = NULL;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->xres * s->dest_width;\n\n    *miny = 0;\n\n    framebuffer_update_display(surface, s->sysmem,\n\n                               addr, s->xres, s->yres,\n\n                               src_width, dest_width, s->dest_width,\n\n                               s->invalidated,\n\n                               fn, s->dma_ch[0].palette, miny, maxy);\n\n}\n",
        "output": "0",
        "idx": 5802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t\n\t*data = &iterator->current;\n}",
        "output": "1",
        "idx": 2012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool const_item() const { return used_tables() == 0; }",
        "output": "1",
        "idx": 2045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool set_off_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, unsigned long flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\t/*\n\t * Always use on-slab management when SLAB_NOLEAKTRACE\n\t * to avoid recursive calls into kmemleak.\n\t */\n\tif (flags & SLAB_NOLEAKTRACE)\n\t\treturn false;\n\n\t/*\n\t * Size is large, assume best to place the slab management obj\n\t * off-slab (should allow better packing of objs).\n\t */\n\tleft = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\t/*\n\t * If the slab has been placed off-slab, and we have enough space then\n\t * move it on-slab. This is at the expense of any extra colouring.\n\t */\n\tif (left >= cachep->num * sizeof(freelist_idx_t))\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
        "output": "0",
        "idx": 5709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bpf_map_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE) {\n\t\tmutex_lock(&map->freeze_mutex);\n\t\tmap->writecnt--;\n\t\tmutex_unlock(&map->freeze_mutex);\n\t}\n}",
        "output": "1",
        "idx": 2965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n",
        "output": "0",
        "idx": 683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "m4_mkstemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  mkstemp_helper (obs, ARG (1));\n}",
        "output": "1",
        "idx": 3397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)\n{\n\tstruct buf *work = 0;\n\tstruct footnote_item *item;\n\tstruct footnote_ref *ref;\n\n\tif (footnotes->count == 0)\n\t\treturn;\n\n\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n\n\titem = footnotes->head;\n\twhile (item) {\n\t\tref = item->ref;\n\t\tparse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);\n\t\titem = item->next;\n\t}\n\n\tif (rndr->cb.footnotes)\n\t\trndr->cb.footnotes(ob, work, rndr->opaque);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n}",
        "output": "0",
        "idx": 4191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContents::IncrementCapturerCount(gin::Arguments* args) {\n  gfx::Size size;\n  bool stay_hidden = false;\n  bool stay_awake = false;\n\n  // get size arguments if they exist\n  args->GetNext(&size);\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n  // get stayAwake arguments if they exist\n  args->GetNext(&stay_awake);\n\n  ignore_result(\n      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));\n}",
        "output": "0",
        "idx": 5281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n",
        "output": "0",
        "idx": 314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n",
        "output": "0",
        "idx": 2944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int h2_task_pre_conn(conn_rec* c, void *arg)\n{\n    h2_ctx *ctx;\n    \n    if (!c->master) {\n        return OK;\n    }\n    \n    ctx = h2_ctx_get(c, 0);\n    (void)arg;\n    if (ctx->task) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,\n                      \"h2_h2, pre_connection, found stream task\");\n        ap_add_input_filter(\"H2_SLAVE_IN\", NULL, NULL, c);\n        ap_add_output_filter(\"H2_PARSE_H1\", NULL, NULL, c);\n        ap_add_output_filter(\"H2_SLAVE_OUT\", NULL, NULL, c);\n    }\n    return OK;\n}",
        "output": "1",
        "idx": 2804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)\n\n{\n\n    uint32_t scratch = 0;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n\n\n    for (; buf < buf_end - 3; buf += 4)\n\n        scratch ^= *((const uint32_t*)buf);\n\n\n\n    scratch = xor_32_to_8(scratch);\n\n\n\n    for (; buf < buf_end; buf++)\n\n\n\n\n    return scratch;\n\n}",
        "output": "1",
        "idx": 5670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zzip_mem_disk_findfile(ZZIP_MEM_DISK* dir, \n                       char* filename, ZZIP_DISK_ENTRY* after,\n\t\t       zzip_strcmp_fn_t compare) {\n    return zzip_disk_findfile(dir->disk, filename, after, compare); }",
        "output": "1",
        "idx": 5455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
        "output": "1",
        "idx": 5847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    bool _empty() override {\n      return peering_queue.empty();\n    }",
        "output": "0",
        "idx": 6310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n",
        "output": "1",
        "idx": 2493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pte_numa(pte_t pte)\n{\n\treturn (pte_flags(pte) &\n\t\t(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;\n}",
        "output": "0",
        "idx": 3774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex\n{\n    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);\n    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n\n    report.arguments[0] = start_col;\n    report.arguments[1] = stop_col;\n\n    memcpy(&report.arguments[2], rgb_data, row_length);\n\n    return report;\n}",
        "output": "1",
        "idx": 5658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tstrcpy(term_cmd_buf, term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_printf(\"\\n\");\n\n    term_print_cmdline(term_cmd_buf);\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n",
        "output": "1",
        "idx": 5614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}",
        "output": "1",
        "idx": 4365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\tput_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
        "output": "0",
        "idx": 2169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,\n\n                           QEMUSGList *sg, uint64_t sector,\n\n                           void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,\n\n                       DMA_DIRECTION_TO_DEVICE);\n\n}\n",
        "output": "0",
        "idx": 1920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDF::removePage(QPDFObjectHandle page)\n{\n    int pos = findPage(page); // also ensures flat /Pages\n    QTC::TC(\"qpdf\", \"QPDF remove page\",\n            (pos == 0) ? 0 :                            // remove at beginning\n            (pos == static_cast<int>(\n                this->m->all_pages.size() - 1)) ? 1 :   // end\n            2);                                         // remove in middle\n\n    QPDFObjectHandle pages = getRoot().getKey(\"/Pages\");\n    QPDFObjectHandle kids = pages.getKey(\"/Kids\");\n\n    kids.eraseItem(pos);\n    int npages = kids.getArrayNItems();\n    pages.replaceKey(\"/Count\", QPDFObjectHandle::newInteger(npages));\n    this->m->all_pages.erase(this->m->all_pages.begin() + pos);\n    assert(this->m->all_pages.size() == static_cast<size_t>(npages));\n    this->m->pageobj_to_pages_pos.erase(page.getObjGen());\n    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));\n    for (int i = pos; i < npages; ++i)\n    {\n        insertPageobjToPage(this->m->all_pages.at(i), i, false);\n    }\n}",
        "output": "1",
        "idx": 5372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntop_has_geoip(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);\n  return(CONST_LUA_OK);\n}",
        "output": "0",
        "idx": 5668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */\n{\n\tsmart_str_appendl(buf, \"s:\", 2);\n\tsmart_str_append_long(buf, len);\n\tsmart_str_appendl(buf, \":\\\"\", 2);\n\tsmart_str_appendl(buf, str, len);\n\tsmart_str_appendl(buf, \"\\\";\", 2);\n}",
        "output": "0",
        "idx": 5815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lexer_current_is_literal (parser_context_t *context_p, /**< context */\n                          const lexer_lit_location_t *right_ident_p) /**< identifier */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n  lexer_lit_location_t *left_ident_p = &context_p->token.lit_location;\n\n  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);\n\n  if (left_ident_p->length != right_ident_p->length)\n  {\n    return false;\n  }\n\n  if (!left_ident_p->has_escape && !right_ident_p->has_escape)\n  {\n    return memcmp (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;\n  }\n\n  return lexer_compare_identifiers (context_p, left_ident_p, right_ident_p);\n} /* lexer_current_is_literal */",
        "output": "1",
        "idx": 5578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n",
        "output": "1",
        "idx": 4087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n",
        "output": "1",
        "idx": 5773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_attribute_9(TERMTYPE2 *tp, int flag)\n{\n    const char *value;\n    char *result;\n\n    value = tparm(set_attributes, 0, 0, 0, 0, 0, 0, 0, 0, flag);\n    if (PRESENT(value))\n\tresult = strdup(value);\n    else\n\tresult = 0;\n    return result;\n}",
        "output": "1",
        "idx": 5749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gf_dom_event_remove_all_listeners(GF_DOMEventTarget *event_target)\n{\n\twhile (gf_list_count(event_target->listeners)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(event_target->listeners, 0);\n\t\tgf_dom_listener_del(n, event_target);\n\t}\n}",
        "output": "1",
        "idx": 5639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asn1_get_octet_der (const unsigned char *der, int der_len,\n\t\t    int *ret_len, unsigned char *str, int str_size,\n\t\t    int *str_len)\n{\n  int len_len = 0;\n\n  if (der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n\n  /* if(str==NULL) return ASN1_SUCCESS; */\n  *str_len = asn1_get_length_der (der, der_len, &len_len);\n\n  if (*str_len < 0)\n    return ASN1_DER_ERROR;\n\n  *ret_len = *str_len + len_len;\n  if (str_size >= *str_len)\n    {\n      if (*str_len > 0)\n        memcpy (str, der + len_len, *str_len);\n    }\n  else\n    {\n      return ASN1_MEM_ERROR;\n    }\n\n  return ASN1_SUCCESS;\n}",
        "output": "1",
        "idx": 1558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_server_send_signal (struct t_irc_server *server, const char *signal,\n                        const char *command, const char *full_message,\n                        const char *tags)\n{\n    int length;\n    char *str_signal, *full_message_tags;\n    \n    length = strlen (server->name) + 1 + strlen (signal) + 1 + strlen (command) + 1;\n    str_signal = malloc (length);\n    if (str_signal)\n    {\n        snprintf (str_signal, length,\n                  \"%s,%s_%s\", server->name, signal, command);\n        if (tags)\n        {\n            length = strlen (tags) + 1 + strlen (full_message) + 1;\n            full_message_tags = malloc (length);\n            if (full_message_tags)\n            {\n                snprintf (full_message_tags, length,\n                          \"%s;%s\", tags, full_message);\n                weechat_hook_signal_send (str_signal,\n                                          WEECHAT_HOOK_SIGNAL_STRING,\n                                          (void *)full_message_tags);\n                free (full_message_tags);\n            }\n        }\n        else\n        {\n            weechat_hook_signal_send (str_signal, WEECHAT_HOOK_SIGNAL_STRING,\n                                      (void *)full_message);\n        }\n        free (str_signal);\n    }\n}",
        "output": "0",
        "idx": 6190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_date_time_new_now_local_time (void)\n{\n  return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());\n}",
        "output": "0",
        "idx": 3493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t qemu_archipelago_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret;\n\n    BDRVArchipelagoState *s = bs->opaque;\n\n\n\n    ret = archipelago_volume_info(s);\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 5739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 1220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)\n\t{\n\treturn ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);\n\t}",
        "output": "0",
        "idx": 3575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RemoteDevicePropertiesWidget::RemoteDevicePropertiesWidget(QWidget *parent)\n    : QWidget(parent)\n    , modified(false)\n    , saveable(false)\n{\n    setupUi(this);\n    if (qobject_cast<QTabWidget *>(parent)) {\n        verticalLayout->setMargin(4);\n    }\n    type->addItem(tr(\"Samba Share\"), (int)Type_Samba);\n    type->addItem(tr(\"Samba Share (Auto-discover host and port)\"), (int)Type_SambaAvahi);\n    type->addItem(tr(\"Secure Shell (sshfs)\"), (int)Type_SshFs);\n    type->addItem(tr(\"Locally Mounted Folder\"), (int)Type_File);\n}",
        "output": "1",
        "idx": 2480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,\n                                      const struct lys_node *first_node, int abs_path)\n{\n    int dep1, dep2;\n    const struct lys_node *node;\n\n    if (!op_node) {\n        /* leafref pointing to a different module */\n        if (local_mod != lys_node_module(first_node)) {\n            return 1;\n        }\n    } else if (lys_parent(op_node)) {\n        /* inner operation (notif/action) */\n        if (abs_path) {\n            return 1;\n        } else {\n            /* compare depth of both nodes */\n            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));\n            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));\n            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {\n                return 1;\n            }\n        }\n    } else {\n        /* top-level operation (notif/rpc) */\n        if (op_node != first_node) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 6317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)\n\n{\n\n    ff_wmv2_idct_c(block);\n\n    put_pixels_clamped_c(block, dest, line_size);\n\n}\n",
        "output": "1",
        "idx": 1284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qdev_prop_set_globals(DeviceState *dev, Error **errp)\n{\n    ObjectClass *class = object_get_class(OBJECT(dev));\n\n    do {\n        GlobalProperty *prop;\n        QTAILQ_FOREACH(prop, &global_props, next) {\n            Error *err = NULL;\n\n            if (strcmp(object_class_get_name(class), prop->driver) != 0) {\n                continue;\n            }\n            qdev_prop_parse(dev, prop->property, prop->value, &err);\n            if (err != NULL) {\n                error_propagate(errp, err);\n                return;\n            }\n        }\n        class = object_class_get_parent(class);\n    } while (class);\n}",
        "output": "0",
        "idx": 3326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (ext4_has_feature_journal(inode->i_sb) &&\n\t    (inode->i_ino ==\n\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))\n\t\treturn 0;\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock %llu \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_pblk, map->m_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n",
        "output": "1",
        "idx": 1121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_opts_print(QemuOpts *opts, void *dummy)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    fprintf(stderr, \"%s: %s:\", opts->list->name,\n\n            opts->id ? opts->id : \"<noid>\");\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 4372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    return REMOVE_SUCCESS;\n\n}\n",
        "output": "1",
        "idx": 2586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool hugetlb_cma_page(struct page *page, unsigned int order)\n{\n\treturn false;\n}",
        "output": "0",
        "idx": 677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_pool_can_realloc(mrb_pool *pool, void *p, size_t len)\n{\n  struct mrb_pool_page *page;\n\n  if (!pool) return 0;\n  len += CALC_ALIGN_PADDING(len);\n  page = pool->pages;\n  while (page) {\n    if (page->last == p) {\n      size_t beg;\n\n      beg = (char*)p - page->page;\n      if (beg + len > page->len) return 0;\n      return 1;\n    }\n    page = page->next;\n  }\n  return 0;\n}",
        "output": "0",
        "idx": 3227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}",
        "output": "1",
        "idx": 3913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unix_sck_send_disconnect(hsm_com_client_hdl_t *hdl, int timeout)\r\n{\r\n\thsm_com_discon_data_t\tmsg;\r\n\r\n\tmemset(&msg,0,sizeof(msg));\r\n\r\n\tmsg.header.cmd = HSM_COM_CMD_DISC;\r\n\tmsg.header.ver = HSM_COM_VER;\r\n\tmsg.header.trans_id = hdl->trans_id++;\r\n\tmsg.header.payload_len = 0;\r\n\r\n\tif(unix_sck_send_msg(hdl, (char*)&msg, sizeof(msg), (char*)&msg, \r\n\t\t\t\t\t\t sizeof(msg), timeout) != sizeof(msg))\r\n\t{\r\n\t\t// COM Error...\r\n\t\t// Close our connection\r\n\t\tclose(hdl->client_fd);\r\n\t\thdl->client_state = HSM_COM_C_STATE_IN;\r\n\r\n\t\treturn HSM_COM_BAD;\r\n\t}\r\n\r\n\tif(msg.header.resp_code == HSM_COM_RESP_OK){\r\n\t\treturn HSM_COM_OK;\r\n\t}\r\n\r\n\treturn HSM_COM_BAD;\r\n\r\n}\r",
        "output": "0",
        "idx": 167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel *) _dst;\n\n    dctcoef *src = (dctcoef *) _src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        dst[0] += src[0];\n\n        dst[1] += src[1];\n\n        dst[2] += src[2];\n\n        dst[3] += src[3];\n\n        dst[4] += src[4];\n\n        dst[5] += src[5];\n\n        dst[6] += src[6];\n\n        dst[7] += src[7];\n\n\n\n        dst += stride;\n\n        src += 8;\n\n    }\n\n\n\n    memset(_src, 0, sizeof(dctcoef) * 64);\n\n}\n",
        "output": "1",
        "idx": 3369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,\n    size_t position, enum evbuffer_ptr_how how)\n{\n\tsize_t left = position;\n\tstruct evbuffer_chain *chain = NULL;\n\n\tEVBUFFER_LOCK(buf);\n\n\tswitch (how) {\n\tcase EVBUFFER_PTR_SET:\n\t\tchain = buf->first;\n\t\tpos->pos = position;\n\t\tposition = 0;\n\t\tbreak;\n\tcase EVBUFFER_PTR_ADD:\n\t\t/* this avoids iterating over all previous chains if\n\t\t   we just want to advance the position */\n\t\tchain = pos->_internal.chain;\n\t\tpos->pos += position;\n\t\tposition = pos->_internal.pos_in_chain;\n\t\tbreak;\n\t}\n\n\twhile (chain && position + left >= chain->off) {\n\t\tleft -= chain->off - position;\n\t\tchain = chain->next;\n\t\tposition = 0;\n\t}\n\tif (chain) {\n\t\tpos->_internal.chain = chain;\n\t\tpos->_internal.pos_in_chain = position + left;\n\t} else {\n\t\tpos->_internal.chain = NULL;\n\t\tpos->pos = -1;\n\t}\n\n\tEVBUFFER_UNLOCK(buf);\n\n\treturn chain != NULL ? 0 : -1;\n}",
        "output": "1",
        "idx": 3952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, size_t len, const bson *scope ) {\n\n    size_t sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32_as_int( b, ( int )size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}",
        "output": "0",
        "idx": 3068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,\n\n                                             ptrdiff_t buf_stride,\n\n                                             ptrdiff_t src_stride,\n\n                                             int block_w, int block_h,\n\n                                             int src_x, int src_y, int w, int h)\n\n{\n\n    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,\n\n                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,\n\n                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);\n\n}\n",
        "output": "0",
        "idx": 4722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdm_session_finalize (GObject *object)\n{\n        GdmSession   *self;\n        GObjectClass *parent_class;\n\n        self = GDM_SESSION (object);\n\n        g_free (self->priv->selected_user);\n        g_free (self->priv->selected_session);\n        g_free (self->priv->saved_session);\n        g_free (self->priv->saved_language);\n\n        g_free (self->priv->fallback_session_name);\n\n        parent_class = G_OBJECT_CLASS (gdm_session_parent_class);\n\n        if (parent_class->finalize != NULL)\n                parent_class->finalize (object);\n}",
        "output": "0",
        "idx": 868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcmp(filename, DOT_GIT) != 0));\n}",
        "output": "1",
        "idx": 2155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void enable_kernel_spe(void)\n{\n\tWARN_ON(preemptible());\n\n\tmsr_check_and_set(MSR_SPE);\n\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {\n\t\tcheck_if_tm_restore_required(current);\n\t\t__giveup_spe(current);\n\t}\n}",
        "output": "0",
        "idx": 1853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sdl_write_trailer(AVFormatContext *s)\n\n{\n\n    SDLContext *sdl = s->priv_data;\n\n\n\n    sdl->quit = 1;\n\n\n\n    if (sdl->overlay)\n\n        SDL_FreeYUVOverlay(sdl->overlay);\n\n\n    if (sdl->event_thread)\n\n        SDL_WaitThread(sdl->event_thread, NULL);\n\n\n    if (sdl->mutex)\n\n        SDL_DestroyMutex(sdl->mutex);\n\n\n    if (sdl->init_cond)\n\n        SDL_DestroyCond(sdl->init_cond);\n\n\n\n\n    if (!sdl->sdl_was_already_inited)\n\n        SDL_Quit();\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 2323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *mnt_fs_get_user_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->user_optstr : NULL;\n}",
        "output": "0",
        "idx": 4477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {\n\n    double time = av_gettime() / 1000000.0;\n\n    /* update current video pts */\n\n    is->video_current_pts = pts;\n\n    is->video_current_pts_drift = is->video_current_pts - time;\n\n    is->video_current_pos = pos;\n\n    is->frame_last_pts = pts;\n\n    check_external_clock_sync(is, is->video_current_pts);\n\n}\n",
        "output": "0",
        "idx": 814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct cpu *cpu = container_of(dev, struct cpu, dev);\n\tssize_t rc;\n\tunsigned long long addr;\n\tint cpunum;\n\n\tcpunum = cpu->dev.id;\n\n\t/*\n\t * Might be reading other cpu's data based on which cpu read thread\n\t * has been scheduled. But cpu data (memory) is allocated once during\n\t * boot up and this data does not change there after. Hence this\n\t * operation should be safe. No locking required.\n\t */\n\taddr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));\n\trc = sprintf(buf, \"%Lx\\n\", addr);\n\treturn rc;\n}",
        "output": "1",
        "idx": 1844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\tint res = 0;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\tfor (t = next_thread(p); t != p; t = next_thread(t)) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs) {\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\t} else {\n\t\tres = -EAGAIN;\n\t\tif (!p->fs->in_exec) {\n\t\t\tp->fs->in_exec = 1;\n\t\t\tres = 1;\n\t\t}\n\t}\n\tspin_unlock(&p->fs->lock);\n\n\treturn res;\n}",
        "output": "1",
        "idx": 5401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n",
        "output": "0",
        "idx": 2030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tif (esno_snr == 1)\n\t\treturn cx24116_read_snr_esno(fe, snr);\n\telse\n\t\treturn cx24116_read_snr_pct(fe, snr);\n}",
        "output": "0",
        "idx": 4506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vhdx_reopen_prepare(BDRVReopenState *state,\n                               BlockReopenQueue *queue, Error **errp)\n{\n    return 0;\n}",
        "output": "0",
        "idx": 3239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)\n{\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n    const char *path = qemu_opt_get(opts, \"path\");\n    if (sec_model) {\n        error_report(\"Invalid argument security_model specified with handle fsdriver\");\n        return -1;\n    }\n    if (!path) {\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n    fse->path = g_strdup(path);\n    return 0;\n}",
        "output": "1",
        "idx": 3460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "systemd_unit_name_escape (const gchar *in)\n{\n  /* Adapted from systemd source */\n  GString * const str = g_string_sized_new (strlen (in));\n\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}",
        "output": "0",
        "idx": 2447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n",
        "output": "1",
        "idx": 2648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int memory_region_get_fd(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_fd(mr->alias);\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n",
        "output": "0",
        "idx": 2635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)\n{\n\tif (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;\n\tasn1_write_uint8(data, v);\n\tasn1_pop_tag(data);\n\treturn !data->has_error;\n}",
        "output": "1",
        "idx": 4154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sock * unix_create1(struct socket *sock)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\n\tif (atomic_read(&unix_nr_socks) >= 2*get_max_files())\n\t\tgoto out;\n\n\tsk = sk_alloc(PF_UNIX, GFP_KERNEL, &unix_proto, 1);\n\tif (!sk)\n\t\tgoto out;\n\n\tatomic_inc(&unix_nr_socks);\n\n\tsock_init_data(sock,sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= sysctl_unix_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->dentry = NULL;\n\tu->mnt\t  = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_set(&u->inflight, sock ? 0 : -1);\n\tmutex_init(&u->readlock); /* single task reading lock */\n\tinit_waitqueue_head(&u->peer_wait);\n\tunix_insert_socket(unix_sockets_unbound, sk);\nout:\n\treturn sk;\n}",
        "output": "1",
        "idx": 4990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n",
        "output": "0",
        "idx": 2114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init of_unittest_overlay_0(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 0);\n}",
        "output": "0",
        "idx": 5644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))\n{\n\tmutex_lock(&dlci_ioctl_mutex);\n\tdlci_ioctl_hook = hook;\n\tmutex_unlock(&dlci_ioctl_mutex);\n}",
        "output": "0",
        "idx": 1666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SQInteger base_collectgarbage(HSQUIRRELVM v)\n{\n    sq_pushinteger(v, sq_collectgarbage(v));\n    return 1;\n}",
        "output": "0",
        "idx": 6063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ms_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe / framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}",
        "output": "1",
        "idx": 2512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\n\tif (!fepriv)\n\t\treturn;\n\n\tkfree(fepriv);\n\tfe->frontend_priv = NULL;\n}",
        "output": "1",
        "idx": 2000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)\n{\n    if (x->aux && (x->aux->trust || x->aux->reject))\n        return obj_trust(trust->arg1, x, flags);\n    /*\n     * we don't have any trust settings: for compatibility we return trusted\n     * if it is self signed\n     */\n    return trust_compat(trust, x, flags);\n}",
        "output": "1",
        "idx": 2072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RedCharDeviceWriteBuffer *vdagent_new_write_buffer(RedCharDeviceVDIPort *agent_dev,\n                                                          uint32_t type,\n                                                          size_t size,\n                                                          bool use_token)\n{\n    uint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;\n\n    RedCharDeviceWriteBuffer *char_dev_buf;\n        char_dev_buf = agent_dev->write_buffer_get_server(total_msg_size,\n                                                          use_token);\n    if (!char_dev_buf) {\n        return NULL;  // no token was available\n    }\n\n    char_dev_buf->buf_used = total_msg_size;\n    VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;\n    internal_buf->chunk_header.port = VDP_SERVER_PORT;\n    internal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;\n    internal_buf->header.protocol = VD_AGENT_PROTOCOL;\n    internal_buf->header.type = type;\n    internal_buf->header.opaque = 0;\n    internal_buf->header.size = size;\n\n    return char_dev_buf;\n}",
        "output": "0",
        "idx": 228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdm_session_authorize (GdmSession *self,\n                       const char *service_name)\n{\n        GdmSessionConversation *conversation;\n\n        g_return_if_fail (GDM_IS_SESSION (self));\n\n        conversation = find_conversation_by_name (self, service_name);\n        if (conversation != NULL) {\n                gdm_dbus_worker_call_authorize (conversation->worker_proxy,\n                                                NULL,\n                                                (GAsyncReadyCallback) on_authorize_cb,\n                                                conversation);\n        }\n}",
        "output": "1",
        "idx": 5494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}",
        "output": "1",
        "idx": 3805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    if (cipher != NULL) {\n        if (cipher->aes_key != NULL) {\n            explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n        }\n        SAFE_FREE(cipher->aes_key);\n    }\n}",
        "output": "0",
        "idx": 787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit xfrm6_tunnel_net_exit(struct net *net)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tunsigned int i;\n\n\txfrm_flush_gc();\n\txfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byaddr[i]));\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byspi[i]));\n}",
        "output": "1",
        "idx": 5422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,\n                                    unsigned size, MemTxAttrs attrs)\n{\n    GICState *s = (GICState *)opaque;\n    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);\n}",
        "output": "0",
        "idx": 1483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *print_number( cJSON *item )\n{\n\tchar *str;\n\tdouble f, f2;\n\tint64_t i;\n\n\tstr = (char*) cJSON_malloc( 64 );\n\tif ( str ) {\n\t\tf = item->valuefloat;\n\t\ti = f;\n\t\tf2 = i;\n\t\tif ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )\n\t\t\tsprintf( str, \"%lld\", (long long) item->valueint );\n\t\telse\n\t\t\tsprintf( str, \"%g\", item->valuefloat );\n\t}\n\treturn str;\n}",
        "output": "1",
        "idx": 435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Pl_RunLength::decode(unsigned char* data, size_t len)\n{\n    for (size_t i = 0; i < len; ++i)\n    {\n        unsigned char ch = data[i];\n        switch (this->state)\n        {\n          case st_top:\n            if (ch < 128)\n            {\n                // length represents remaining number of bytes to copy\n                this->length = 1 + ch;\n                this->state = st_copying;\n            }\n            else if (ch > 128)\n            {\n                // length represents number of copies of next byte\n                this->length = 257 - ch;\n                this->state = st_run;\n            }\n            else // ch == 128\n            {\n                // EOD; stay in this state\n            }\n            break;\n\n          case st_copying:\n            this->getNext()->write(&ch, 1);\n            if (--this->length == 0)\n            {\n                this->state = st_top;\n            }\n            break;\n\n          case st_run:\n            for (unsigned int j = 0; j < this->length; ++j)\n            {\n                this->getNext()->write(&ch, 1);\n            }\n            this->state = st_top;\n            break;\n        }\n    }\n}",
        "output": "1",
        "idx": 2639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lzh_emit_window(struct lzh_stream *strm, size_t s)\n{\n\tstrm->ref_ptr = strm->ds->w_buff;\n\tstrm->avail_out = (int)s;\n\tstrm->total_out += s;\n}",
        "output": "0",
        "idx": 4405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n",
        "output": "1",
        "idx": 5589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "listener_ref_entry_remove_for_connection (GSListener  *listener,\n                                          int          entry_type,\n                                          const char  *connection)\n{\n        gboolean    removed;\n        guint       n_removed;\n        GHashTable *hash;\n\n        hash = get_hash_for_entry_type (listener, entry_type);\n\n        removed = FALSE;\n        n_removed = g_hash_table_foreach_remove (hash, listener_ref_entry_has_connection, (gpointer)connection);\n\n        removed = (n_removed > 0);\n\n        return removed;\n}",
        "output": "1",
        "idx": 6311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n\n\n    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);\n\n    kvm_mce_broadcast_rest(env);\n\n}\n",
        "output": "0",
        "idx": 1703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_input_queue_process(void *opaque)\n{\n    struct QemuInputEventQueueHead *queue = opaque;\n    QemuInputEventQueue *item;\n\n    g_assert(!QTAILQ_EMPTY(queue));\n    item = QTAILQ_FIRST(queue);\n    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);\n    QTAILQ_REMOVE(queue, item, node);\n    g_free(item);\n\n    while (!QTAILQ_EMPTY(queue)) {\n        item = QTAILQ_FIRST(queue);\n        switch (item->type) {\n        case QEMU_INPUT_QUEUE_DELAY:\n            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                      + item->delay_ms);\n            return;\n        case QEMU_INPUT_QUEUE_EVENT:\n            qemu_input_event_send(item->src, item->evt);\n            qapi_free_InputEvent(item->evt);\n            break;\n        case QEMU_INPUT_QUEUE_SYNC:\n            qemu_input_event_sync();\n            break;\n        }\n        QTAILQ_REMOVE(queue, item, node);\n        g_free(item);\n    }\n}",
        "output": "1",
        "idx": 5295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}",
        "output": "1",
        "idx": 4516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n#if HAVE_7REGS && HAVE_TEN_OPERANDS\n\n    c->mlp_filter_channel = mlp_filter_channel_x86;\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 5742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void av_build_index_raw(AVFormatContext *s)\n\n{\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    st = s->streams[0];\n\n    av_read_frame_flush(s);\n\n    url_fseek(&s->pb, s->data_offset, SEEK_SET);\n\n\n\n    for(;;) {\n\n        ret = av_read_frame(s, pkt);\n\n        if (ret < 0)\n\n            break;\n\n        if (pkt->stream_index == 0 && st->parser &&\n\n            (pkt->flags & PKT_FLAG_KEY)) {\n\n            add_index_entry(st, st->parser->frame_offset, pkt->dts, \n\n                            AVINDEX_KEYFRAME);\n\n        }\n\n        av_free_packet(pkt);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n",
        "output": "1",
        "idx": 3228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nr_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr;\n\n\tif (sk == NULL) return 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\tnr = nr_sk(sk);\n\n\tswitch (nr->state) {\n\tcase NR_STATE_0:\n\tcase NR_STATE_1:\n\tcase NR_STATE_2:\n\t\tnr_disconnect(sk, 0);\n\t\tnr_destroy_socket(sk);\n\t\tbreak;\n\n\tcase NR_STATE_3:\n\t\tnr_clear_queues(sk);\n\t\tnr->n2count = 0;\n\t\tnr_write_internal(sk, NR_DISCREQ);\n\t\tnr_start_t1timer(sk);\n\t\tnr_stop_t2timer(sk);\n\t\tnr_stop_t4timer(sk);\n\t\tnr_stop_idletimer(sk);\n\t\tnr->state    = NR_STATE_2;\n\t\tsk->sk_state    = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}",
        "output": "0",
        "idx": 496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XSetStandardProperties (\n    \tDisplay *dpy,\n    \tWindow w,\t\t/* window to decorate */\n    \t_Xconst char *name,\t/* name of application */\n    \t_Xconst char *icon_string,/* name string for icon */\n\tPixmap icon_pixmap,\t/* pixmap to use as icon, or None */\n    \tchar **argv,\t\t/* command to be used to restart application */\n    \tint argc,\t\t/* count of arguments */\n    \tXSizeHints *hints)\t/* size hints for window in its normal state */\n{\n\tXWMHints phints;\n\tphints.flags = 0;\n\n\tif (name != NULL) XStoreName (dpy, w, name);\n\n\tif (icon_string != NULL) {\n\t    XChangeProperty (dpy, w, XA_WM_ICON_NAME, XA_STRING, 8,\n                             PropModeReplace,\n                             (_Xconst unsigned char *)icon_string,\n                             (int)safestrlen(icon_string));\n\t\t}\n\n\tif (icon_pixmap != None) {\n\t\tphints.icon_pixmap = icon_pixmap;\n\t\tphints.flags |= IconPixmapHint;\n\t\t}\n\tif (argv != NULL) XSetCommand(dpy, w, argv, argc);\n\n\tif (hints != NULL) XSetNormalHints(dpy, w, hints);\n\n\tif (phints.flags != 0) XSetWMHints(dpy, w, &phints);\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 5952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_set_default_dir(int id TSRMLS_DC)\n{\n\tif (DIRG(default_dir)!=-1) {\n\t\tzend_list_delete(DIRG(default_dir));\n\t}\n\n\tif (id != -1) {\n\t\tzend_list_addref(id);\n\t}\n\t\n\tDIRG(default_dir) = id;\n}",
        "output": "1",
        "idx": 1792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 5146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_mtime(buf_T *buf, stat_T *st)\n{\n    if (buf->b_mtime_read != 0\n\t    && time_differs((long)st->st_mtime, buf->b_mtime_read))\n    {\n\tmsg_scroll = TRUE;\t    /* don't overwrite messages here */\n\tmsg_silent = 0;\t\t    /* must give this prompt */\n\t/* don't use emsg() here, don't want to flush the buffers */\n\tMSG_ATTR(_(\"WARNING: The file has been changed since reading it!!!\"),\n\t\t\t\t\t\t       HL_ATTR(HLF_E));\n\tif (ask_yesno((char_u *)_(\"Do you really want to write to it\"),\n\t\t\t\t\t\t\t\t TRUE) == 'n')\n\t    return FAIL;\n\tmsg_scroll = FALSE;\t    /* always overwrite the file message now */\n    }\n    return OK;\n}",
        "output": "0",
        "idx": 5339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,\n\n                                             hwaddr ptex, int n)\n\n{\n\n    ppc_hash_pte64_t *hptes = NULL;\n\n    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;\n\n\n\n    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {\n\n        /*\n\n         * HTAB is controlled by KVM. Fetch into temporary buffer\n\n         */\n\n        hptes = g_malloc(HASH_PTEG_SIZE_64);\n\n        kvmppc_read_hptes(hptes, ptex, n);\n\n    } else if (cpu->env.external_htab) {\n\n        /*\n\n         * HTAB is controlled by QEMU. Just point to the internally\n\n         * accessible PTEG.\n\n         */\n\n        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);\n\n    } else if (cpu->env.htab_base) {\n\n        hwaddr plen = n * HASH_PTE_SIZE_64;\n\n        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,\n\n                                 &plen, false);\n\n        if (plen < (n * HASH_PTE_SIZE_64)) {\n\n            hw_error(\"%s: Unable to map all requested HPTEs\\n\", __func__);\n\n        }\n\n    }\n\n    return hptes;\n\n}\n",
        "output": "0",
        "idx": 4232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int blk_mq_hctx_notify(void *data, unsigned long action,\n\t\t\t      unsigned int cpu)\n{\n\tstruct blk_mq_hw_ctx *hctx = data;\n\n\tif (action == CPU_DEAD || action == CPU_DEAD_FROZEN)\n\t\treturn blk_mq_hctx_cpu_offline(hctx, cpu);\n\n\t/*\n\t * In case of CPU online, tags may be reallocated\n\t * in blk_mq_map_swqueue() after mapping is updated.\n\t */\n\n\treturn NOTIFY_OK;\n}",
        "output": "0",
        "idx": 4407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\treturn argv_new (cmd, parent, name, cb, help, true);\n}",
        "output": "0",
        "idx": 1674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hotplug(void)\n\n{\n\n    qtest_start(\"-device virtio-net-pci\");\n\n\n\n    qpci_plug_device_test(\"virtio-net-pci\", \"net1\", PCI_SLOT_HP, NULL);\n\n    qpci_unplug_acpi_device_test(\"net1\", PCI_SLOT_HP);\n\n\n\n    test_end();\n\n}\n",
        "output": "0",
        "idx": 3342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int usb_device_detach(USBDevice *dev)\n{\n    USBBus *bus = usb_bus_from_device(dev);\n    USBPort *port = dev->port;\n\n    assert(port != NULL);\n    assert(dev->attached);\n    trace_usb_port_detach(bus->busnr, port->path);\n\n    usb_detach(port);\n    dev->attached--;\n    return 0;\n}",
        "output": "0",
        "idx": 2902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CModules::OnUserTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnUserTextMessage(Message));\n}",
        "output": "0",
        "idx": 2739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\n\treturn (1);\n}",
        "output": "1",
        "idx": 3188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void setupSigSegvAction(void) {\n    struct sigaction act;\n\n    sigemptyset (&act.sa_mask);\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction\n     * is used. Otherwise, sa_handler is used */\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = segvHandler;\n    sigaction (SIGSEGV, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n    sigaction (SIGFPE, &act, NULL);\n    sigaction (SIGILL, &act, NULL);\n    sigaction (SIGBUS, &act, NULL);\n\n    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;\n    act.sa_handler = sigtermHandler;\n    sigaction (SIGTERM, &act, NULL);\n    return;\n}",
        "output": "0",
        "idx": 2975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}",
        "output": "1",
        "idx": 5662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int MP3lame_encode_frame(AVCodecContext *avctx,\n\n                     unsigned char *frame, int buf_size, void *data)\n\n{\n\n\tMp3AudioContext *s = avctx->priv_data;\n\n\tint num, i;\n\n//av_log(avctx, AV_LOG_DEBUG, \"%X %d %X\\n\", (int)frame, buf_size, (int)data);\n\n//        if(data==NULL)\n\n//            return lame_encode_flush(s->gfp, frame, buf_size);\n\n\n\n\t/* lame 3.91 dies on '1-channel interleaved' data */\n\n\tif (s->stereo) {\n\n\t\tnum = lame_encode_buffer_interleaved(s->gfp, data,\n\n\t\t\tMPA_FRAME_SIZE, frame, buf_size);\n\n\t} else {\n\n\t\tnum = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,\n\n\t\t\tframe, buf_size);\n\n\n\n/*av_log(avctx, AV_LOG_DEBUG, \"in:%d out:%d\\n\", MPA_FRAME_SIZE, num);\n\nfor(i=0; i<num; i++){\n\n    av_log(avctx, AV_LOG_DEBUG, \"%2X \", frame[i]);\n\n}*/\n\n\t}\n\n\n\n\treturn num;\n\n}\n",
        "output": "0",
        "idx": 5379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void object_property_add(Object *obj, const char *name, const char *type,\n\n                         ObjectPropertyAccessor *get,\n\n                         ObjectPropertyAccessor *set,\n\n                         ObjectPropertyRelease *release,\n\n                         void *opaque, Error **errp)\n\n{\n\n    ObjectProperty *prop;\n\n\n\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n\n        if (strcmp(prop->name, name) == 0) {\n\n            error_setg(errp, \"attempt to add duplicate property '%s'\"\n\n                       \" to object (type '%s')\", name,\n\n                       object_get_typename(obj));\n\n            return;\n\n        }\n\n    }\n\n\n\n    prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->name = g_strdup(name);\n\n    prop->type = g_strdup(type);\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n    prop->release = release;\n\n    prop->opaque = opaque;\n\n\n\n    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n\n}\n",
        "output": "0",
        "idx": 5196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n",
        "output": "1",
        "idx": 3127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\t(void)a; /* UNUSED */\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)set; /* UNUSED */\n\t(void)clear; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}",
        "output": "1",
        "idx": 793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tu8 num_reports = skb->data[0];\n\tvoid *ptr = &skb->data[1];\n\n\thci_dev_lock(hdev);\n\n\twhile (num_reports--) {\n\t\tstruct hci_ev_le_direct_adv_info *ev = ptr;\n\n\t\tprocess_adv_report(hdev, ev->evt_type, &ev->bdaddr,\n\t\t\t\t   ev->bdaddr_type, &ev->direct_addr,\n\t\t\t\t   ev->direct_addr_type, ev->rssi, NULL, 0);\n\n\t\tptr += sizeof(*ev);\n\t}\n\n\thci_dev_unlock(hdev);\n}",
        "output": "1",
        "idx": 6038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\t\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}",
        "output": "1",
        "idx": 595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);",
        "output": "1",
        "idx": 2835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (cdsz == 0) {\n\t\treturn;\n\t}\n\n\tRIOMap *map = r_io_map_get (r->io, addr);\n\tif (!map || map ->perm & R_PERM_X) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"Cd %d @ 0x%08\" PFMT64x \"\\n\", cdsz, addr);\n\t}\n}",
        "output": "0",
        "idx": 134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\n\treturn ptr;\n}",
        "output": "1",
        "idx": 300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nvme_instance_init(Object *obj)\n\n{\n\n    object_property_add(obj, \"bootindex\", \"int32\",\n\n                        nvme_get_bootindex,\n\n                        nvme_set_bootindex, NULL, NULL, NULL);\n\n    object_property_set_int(obj, -1, \"bootindex\", NULL);\n\n}\n",
        "output": "1",
        "idx": 1495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n",
        "output": "1",
        "idx": 4692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)\n\n{\n\n    if (!mb_x) {\n\n        return mb_y ? VERT_VP8_PRED : DC_129_PRED;\n\n    } else {\n\n        return mb_y ? mode : HOR_VP8_PRED;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 24
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic inline struct kset *cache_kset(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tif (!is_root_cache(s))\n\t\treturn s->memcg_params.root_cache->memcg_kset;\n#endif\n\treturn slab_kset;",
        "output": "0",
        "idx": 950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int run_tracer_selftest(struct tracer *type)\n{\n\treturn 0;\n}",
        "output": "0",
        "idx": 6240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *ret;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return ret;\n\n\n\nout: \n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n",
        "output": "0",
        "idx": 1343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
        "output": "1",
        "idx": 3177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void plist_bin_init(void)\n{\n    /* init binary plist stuff */\n#ifdef DEBUG\n    char *env_debug = getenv(\"PLIST_BIN_DEBUG\");\n    if (env_debug && !strcmp(env_debug, \"1\")) {\n        plist_bin_debug = 1;\n    }\n#endif\n}",
        "output": "0",
        "idx": 2513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)\n{\n\tsmart_str nstype = {0};\n\tget_type_str(node, ns, type, &nstype);\n\tset_xsi_type(node, nstype.c);\n\tsmart_str_free(&nstype);\n}",
        "output": "0",
        "idx": 3996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ide_trim_bh_cb(void *opaque)\n\n{\n\n    TrimAIOCB *iocb = opaque;\n\n\n\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n\n\n\n    qemu_bh_delete(iocb->bh);\n\n    iocb->bh = NULL;\n\n    qemu_aio_unref(iocb);\n\n}\n",
        "output": "0",
        "idx": 5949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_attr_med (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  /* Length check. */\n  if (length != 4)\n    {\n      zlog (peer->log, LOG_ERR, \n\t    \"MED attribute length isn't four [%d]\", length);\n\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  attr->med = stream_getl (peer->ibuf);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}",
        "output": "0",
        "idx": 1251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n",
        "output": "1",
        "idx": 3533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int srt_probe(AVProbeData *p)\n\n{\n\n    const unsigned char *ptr = p->buf;\n\n    int i, v, num = 0;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3;  /* skip UTF-8 BOM */\n\n\n\n    while (*ptr == '\\r' || *ptr == '\\n')\n\n        ptr++;\n\n    for (i=0; i<2; i++) {\n\n        if ((num == i || num + 1 == i)\n\n            && sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)\n\n            return AVPROBE_SCORE_MAX;\n\n        num = atoi(ptr);\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu);\n}",
        "output": "0",
        "idx": 1621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void io_queue_link_head(struct io_kiocb *req)\n{\n\tif (unlikely(req->flags & REQ_F_FAIL_LINK)) {\n\t\tio_cqring_add_event(req, -ECANCELED);\n\t\tio_double_put_req(req);\n\t} else\n\t\tio_queue_sqe(req);\n}",
        "output": "0",
        "idx": 2091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n\n                                               VirtQueue *vq,\n\n                                               EventNotifierHandler *handler,\n\n                                               int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        exit(1);\n\n    }\n\n    r->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);\n\n    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);\n\n\n\n    r->parent = s;\n\n\n\n    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n\n        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");\n\n        exit(1);\n\n    }\n\n    return r;\n\n}\n",
        "output": "1",
        "idx": 1997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }",
        "output": "1",
        "idx": 646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t enum wmi_cmd_id cmd_id)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(0);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gnutls_pcert_deinit (gnutls_pcert_st *pcert)\n{\n  gnutls_pubkey_deinit(pcert->pubkey);\n  pcert->pubkey = NULL;\n  gnutls_free(pcert->cert.data);\n  pcert->cert.data = NULL;\n}",
        "output": "1",
        "idx": 2565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n",
        "output": "1",
        "idx": 5197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n\t\tpsf->header [psf->headindex++] = (x >> 56) ;\n\t\t} ;\n} /* header_put_le_8byte */",
        "output": "1",
        "idx": 4075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "States& SSL::useStates()\n{\n    return states_;\n}",
        "output": "0",
        "idx": 2923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n",
        "output": "1",
        "idx": 6231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 1744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_dealloc_types(void)\n\n{\n\n    UserDefOne *ud1test, *ud1a, *ud1b;\n\n    UserDefOneList *ud1list;\n\n\n\n    ud1test = g_malloc0(sizeof(UserDefOne));\n\n    ud1test->base = g_new0(UserDefZero, 1);\n\n    ud1test->base->integer = 42;\n\n    ud1test->string = g_strdup(\"hi there 42\");\n\n\n\n    qapi_free_UserDefOne(ud1test);\n\n\n\n    ud1a = g_malloc0(sizeof(UserDefOne));\n\n    ud1a->base = g_new0(UserDefZero, 1);\n\n    ud1a->base->integer = 43;\n\n    ud1a->string = g_strdup(\"hi there 43\");\n\n\n\n    ud1b = g_malloc0(sizeof(UserDefOne));\n\n    ud1b->base = g_new0(UserDefZero, 1);\n\n    ud1b->base->integer = 44;\n\n    ud1b->string = g_strdup(\"hi there 44\");\n\n\n\n    ud1list = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->value = ud1a;\n\n    ud1list->next = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->next->value = ud1b;\n\n\n\n    qapi_free_UserDefOneList(ud1list);\n\n}\n",
        "output": "0",
        "idx": 5371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)\n{\n    SQArray *aparams=_array(stack_get(v,2));\n    SQInteger nparams=aparams->Size();\n    v->Push(stack_get(v,1));\n    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);\n    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;\n}",
        "output": "0",
        "idx": 2858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    /* ??? Register memory space.  */\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 1118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int idcin_decode_init(AVCodecContext *avctx)\n\n{\n\n    IdcinContext *s = avctx->priv_data;\n\n    int i, j, histogram_index = 0;\n\n    unsigned char *histograms;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the Huffman tables make it */\n\n    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  Id CIN video: expected extradata size of %d\\n\", HUFFMAN_TABLE_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    /* build the 256 Huffman decode trees */\n\n    histograms = (unsigned char *)s->avctx->extradata;\n\n    for (i = 0; i < 256; i++) {\n\n        for(j = 0; j < HUF_TOKENS; j++)\n\n            s->huff_nodes[i][j].count = histograms[histogram_index++];\n\n        huff_build_tree(s, i);\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 1583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_trigger_prepare(GSource * source, gint * timeout)\n{\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    /* cluster-glue's FD and IPC related sources make use of\n     * g_source_add_poll() but do not set a timeout in their prepare\n     * functions\n     *\n     * This means mainloop's poll() will block until an event for one\n     * of these sources occurs - any /other/ type of source, such as\n     * this one or g_idle_*, that doesn't use g_source_add_poll() is\n     * S-O-L and wont be processed until there is something fd-based\n     * happens.\n     *\n     * Luckily the timeout we can set here affects all sources and\n     * puts an upper limit on how long poll() can take.\n     *\n     * So unconditionally set a small-ish timeout, not too small that\n     * we're in constant motion, which will act as an upper bound on\n     * how long the signal handling might be delayed for.\n     */\n    *timeout = 500;             /* Timeout in ms */\n\n    return trig->trigger;\n}",
        "output": "0",
        "idx": 2494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "on_worker_connection_closed (GDBusConnection *connection,\n                             gboolean         remote_peer_vanished,\n                             GError          *error,\n                             GdmSession      *self)\n{\n        self->priv->pending_worker_connections =\n            g_list_remove (self->priv->pending_worker_connections,\n                           connection);\n        g_object_unref (connection);\n}",
        "output": "0",
        "idx": 2152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pci_register_iommu_region(struct pci_pbm_info *pbm)\n{\n\tconst u32 *vdma = of_get_property(pbm->op->node, \"virtual-dma\", NULL);\n\n\tif (vdma) {\n\t\tstruct resource *rp = kmalloc(sizeof(*rp), GFP_KERNEL);\n\n\t\tif (!rp) {\n\t\t\tprom_printf(\"Cannot allocate IOMMU resource.\\n\");\n\t\t\tprom_halt();\n\t\t}\n\t\trp->name = \"IOMMU\";\n\t\trp->start = pbm->mem_space.start + (unsigned long) vdma[0];\n\t\trp->end = rp->start + (unsigned long) vdma[1] - 1UL;\n\t\trp->flags = IORESOURCE_BUSY;\n\t\trequest_resource(&pbm->mem_space, rp);\n\t}\n}",
        "output": "1",
        "idx": 1103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __net_exit ip_vs_control_net_cleanup(struct net *net)\n{\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tip_vs_trash_cleanup(net);\n\tip_vs_stop_estimator(net, &ipvs->tot_stats);\n\tip_vs_control_net_cleanup_sysctl(net);\n\tproc_net_remove(net, \"ip_vs_stats_percpu\");\n\tproc_net_remove(net, \"ip_vs_stats\");\n\tproc_net_remove(net, \"ip_vs\");\n\tfree_percpu(ipvs->tot_stats.cpustats);\n}",
        "output": "0",
        "idx": 39
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)\n{\n    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);\n    report.transaction_id.id = 0x3F;\n\n    report.arguments[0] = variable_storage;\n    report.arguments[1] = led_id;\n\n    return report;\n}",
        "output": "0",
        "idx": 3573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)\n{\n    static const auto d = MakeNamedErrorDetail(\"REQMOD_BLOCK\");\n    request->detailError(ERR_ACCESS_DENIED, d);\n    AclMatchedName = answer.ruleId.termedBuf();\n    assert(calloutContext);\n    calloutContext->clientAccessCheckDone(ACCESS_DENIED);\n    AclMatchedName = NULL;\n}",
        "output": "0",
        "idx": 6223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)\n{\n  do\n  {\n    mutt_extract_token (buf, s, 0);\n    /*\n     * Check for deletion of entire list\n     */\n    if (mutt_strcmp (buf->data, \"*\") == 0)\n    {\n      mutt_free_list ((LIST **) data);\n      break;\n    }\n    remove_from_list ((LIST **) data, buf->data);\n  }\n  while (MoreArgs (s));\n\n  return 0;\n}",
        "output": "0",
        "idx": 4950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t auto_online_blocks_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       online_type_to_str[memhp_default_online_type]);\n}",
        "output": "1",
        "idx": 5191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)\n\n{\n\n    AVBitStreamFilter *bsf = first_bitstream_filter;\n\n\n\n    while (bsf) {\n\n        if (!strcmp(name, bsf->name)) {\n\n            AVBitStreamFilterContext *bsfc =\n\n                av_mallocz(sizeof(AVBitStreamFilterContext));\n\n            bsfc->filter    = bsf;\n\n            bsfc->priv_data =\n\n                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;\n\n            return bsfc;\n\n        }\n\n        bsf = bsf->next;\n\n    }\n\n    return NULL;\n\n}\n",
        "output": "0",
        "idx": 3161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void probe_driver(struct btd_adapter *adapter, gpointer user_data)\n{\n\tstruct btd_adapter_driver *driver = user_data;\n\tint err;\n\n\tif (driver->probe == NULL)\n\t\treturn;\n\n\terr = driver->probe(adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"%s: %s (%d)\", driver->name,\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\treturn;\n\t}\n\n\tadapter->drivers = g_slist_prepend(adapter->drivers, driver);\n}",
        "output": "0",
        "idx": 5115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_attr_atomic (struct peer *peer, bgp_size_t length, \n\t\t struct attr *attr, u_char flag, u_char *startp)\n{\n  bgp_size_t total;\n\n  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);\n  /* Flag checks. */\n  if (bgp_attr_flag_invalid (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag))\n    return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,\n                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n                               startp, total);\n  \n  /* Length check. */\n  if (length != 0)\n    {\n      zlog (peer->log, LOG_ERR, \"ATOMIC_AGGREGATE attribute length isn't 0 [%u]\", length);\n      return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 startp, total);\n    }\n\n  /* Set atomic aggregate flag. */\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}",
        "output": "1",
        "idx": 5288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  return(CopyPixel(image,p,pixel));\n}",
        "output": "0",
        "idx": 4096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t rtmp_read_seek(URLContext *s, int stream_index,\n\n                              int64_t timestamp, int flags)\n\n{\n\n    RTMP *r = s->priv_data;\n\n\n\n    if (flags & AVSEEK_FLAG_BYTE)\n\n        return AVERROR(ENOSYS);\n\n\n\n    /* seeks are in milliseconds */\n\n    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);\n\n    if (!RTMP_SendSeek(r, timestamp))\n\n        return -1;\n\n    return timestamp;\n\n}\n",
        "output": "0",
        "idx": 4286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n",
        "output": "1",
        "idx": 1566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dhcp_decode(const uint8_t *buf, int size,\n\n                        int *pmsg_type)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n\n\n    p = buf;\n\n    p_end = buf + size;\n\n    if (size < 5)\n\n        return;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_smbios_ep_address(test_data *data)\n\n{\n\n    uint32_t off;\n\n\n\n    /* find smbios entry point structure */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10) {\n\n        uint8_t sig[] = \"_SM_\";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"_SM_\", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n    data->smbios_ep_addr = off;\n\n}\n",
        "output": "1",
        "idx": 4791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {\n  assert(EnableInvokeDynamic, \"\");\n  // This guy is reached from InterpreterRuntime::resolve_invokehandle.\n  KlassHandle  resolved_klass;\n  Symbol* method_name = NULL;\n  Symbol* method_signature = NULL;\n  KlassHandle  current_klass;\n  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);\n  if (TraceMethodHandles) {\n    ResourceMark rm(THREAD);\n    tty->print_cr(\"resolve_invokehandle %s %s\", method_name->as_C_string(), method_signature->as_C_string());\n  }\n  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);\n}",
        "output": "1",
        "idx": 1442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tls12_get_sigid(const EVP_PKEY *pk)\n{\n    return tls12_find_id(pk->type, tls12_sig,\n                         sizeof(tls12_sig) / sizeof(tls12_lookup));\n}",
        "output": "0",
        "idx": 4465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\n\tRETURN_TRUE;\n}",
        "output": "1",
        "idx": 1804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,\n\t\t\t\t uint32_t val)\n{\n#ifdef TARGET_WORDS_BIGENDIAN\n    cirrus_linear_bitblt_writeb(opaque, addr, (val >> 8) & 0xff);\n    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);\n#else\n    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);\n    cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);\n#endif\n}",
        "output": "0",
        "idx": 6265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL rdp_read_share_control_header(STREAM* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (stream_get_left(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tstream_read_UINT16(s, *length); /* totalLength */\n\n\tif (*length - 2 > stream_get_left(s))\n\t\treturn FALSE;\n\n\tstream_read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F; /* type is in the 4 least significant bits */\n\n\tif (*length > 4)\n\t\tstream_read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 2922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,\n\n                                         src - (stride * 2),\n\n                                         stride, dst, stride);\n\n}\n",
        "output": "0",
        "idx": 1423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jas_icctxtdesc_destroy(jas_iccattrval_t *attrval)\n{\n\tjas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc;\n\tif (txtdesc->ascdata)\n\t\tjas_free(txtdesc->ascdata);\n\tif (txtdesc->ucdata)\n\t\tjas_free(txtdesc->ucdata);\n}",
        "output": "1",
        "idx": 3903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}",
        "output": "1",
        "idx": 4812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)\n{\n    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;\n    RsvgHandle *ctx = z->ctx;\n\n    g_string_append_printf (ctx->priv->metadata, \"<%s \", name);\n    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);\n    g_string_append (ctx->priv->metadata, \">\\n\");\n}",
        "output": "0",
        "idx": 1916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)\n{\n\tif (ldns_rdf_size(rdf) != 6) {\n\t\treturn LDNS_STATUS_WIRE_RDATA_ERR;\n\t}\n\tldns_buffer_printf(output,\"%.2x-%.2x-%.2x-%.2x-%.2x-%.2x\",\n\t\t\t\tldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],\n\t\t\t\tldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],\n\t\t\t\tldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);\n\treturn ldns_buffer_status(output);\n}",
        "output": "0",
        "idx": 3046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int float_near_ulp(float a, float b, unsigned max_ulp)\n\n{\n\n    union av_intfloat32 x, y;\n\n\n\n    x.f = a;\n\n    y.f = b;\n\n\n\n    if (is_negative(x) != is_negative(y)) {\n\n        // handle -0.0 == +0.0\n\n        return a == b;\n\n    }\n\n\n\n    if (abs(x.i - y.i) <= max_ulp)\n\n        return 1;\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t _q_urldecode(char *str)\n{\n    if (str == NULL) {\n        return 0;\n    }\n\n    char *pEncPt, *pBinPt = str;\n    for (pEncPt = str; *pEncPt != '\\0'; pEncPt++) {\n        switch (*pEncPt) {\n            case '+': {\n                *pBinPt++ = ' ';\n                break;\n            }\n            case '%': {\n                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));\n                pEncPt += 2;\n                break;\n            }\n            default: {\n                *pBinPt++ = *pEncPt;\n                break;\n            }\n        }\n    }\n    *pBinPt = '\\0';\n\n    return (pBinPt - str);\n}",
        "output": "1",
        "idx": 1057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)\n{\n  return state->lineinfo + row;\n}",
        "output": "0",
        "idx": 4679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  auto& resources = subgraph->resources();\n  auto* variable = resource::GetResourceVariable(&resources, resource_id);\n  TF_LITE_ENSURE(context, variable != nullptr);\n\n  TfLiteTensor* variable_tensor = variable->GetTensor();\n  TfLiteTensor* output = GetOutput(context, node, kOutputValue);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, variable_tensor->type, output->type);\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(\n                   context, output, TfLiteIntArrayCopy(variable_tensor->dims)));\n  memcpy(output->data.raw, variable_tensor->data.raw, output->bytes);\n\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 1786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n",
        "output": "0",
        "idx": 3758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
        "output": "1",
        "idx": 5905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)\n{\n\tchar *dst;\n\n\tif (!value.length)\n\t\treturn NULL;\n\n\t/* allocate destination string, it will be at most 3 times the source */\n\tdst = talloc_array(mem_ctx, char, value.length * 3 + 1);\n\tif ( ! dst) {\n\t\ttalloc_free(dst);\n\t\treturn NULL;\n\t}\n\n\tldb_dn_escape_internal(dst, (const char *)value.data, value.length);\n\n\tdst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);\n\n\treturn dst;\n}",
        "output": "1",
        "idx": 5856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ClientHandler::read_tls() {\n  ERR_clear_error();\n\n  rb_.ensure_chunk();\n\n  for (;;) {\n    // we should process buffered data first before we read EOF.\n    if (rb_.rleft() && on_read() != 0) {\n      return -1;\n    }\n    if (rb_.rleft() == 0) {\n      rb_.reset();\n    } else if (rb_.wleft() == 0) {\n      conn_.rlimit.stopw();\n      return 0;\n    }\n\n    if (!ev_is_active(&conn_.rev)) {\n      return 0;\n    }\n\n    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());\n\n    if (nread == 0) {\n      if (rb_.rleft() == 0) {\n        rb_.release_chunk();\n      }\n      return 0;\n    }\n\n    if (nread < 0) {\n      return -1;\n    }\n\n    rb_.write(nread);\n  }\n}",
        "output": "1",
        "idx": 4885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n",
        "output": "0",
        "idx": 4799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Crypto::Crypto() \n    : digest_(0), cipher_(0), dh_(0) \n{}",
        "output": "0",
        "idx": 756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool is_seccomp_available(void) {\n        static int cached_enabled = -1;\n\n        if (cached_enabled < 0)\n                cached_enabled =\n                        is_basic_seccomp_available() &&\n                        is_seccomp_filter_available();\n\n        return cached_enabled;\n}",
        "output": "0",
        "idx": 5869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\t/*\n\t\t * The !iov->iov_len check ensures we skip over unlikely\n\t\t * zero-length segments (without overruning the iovec).\n\t\t */\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "output": "1",
        "idx": 931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n",
        "output": "0",
        "idx": 1013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sctp_getsockopt_maxseg(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\n\tval = sctp_sk(sk)->user_frag;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 6301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,\n\n                                          ptrdiff_t stride)\n\n{\n\n    int i;\n\n    pixel *pix = (pixel*)_pix;\n\n    const dctcoef *block = (const dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n    for(i=0; i<4; i++){\n\n        pixel v = pix[-1];\n\n        pix[0]= v += block[0];\n\n        pix[1]= v += block[1];\n\n        pix[2]= v += block[2];\n\n        pix[3]= v +  block[3];\n\n        pix+= stride;\n\n        block+= 4;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int movie_request_frame(AVFilterLink *outlink)\n\n{\n\n    AVFilterBufferRef *outpicref;\n\n    MovieContext *movie = outlink->src->priv;\n\n    int ret;\n\n\n\n    if (movie->is_done)\n\n        return AVERROR_EOF;\n\n    if ((ret = movie_get_frame(outlink)) < 0)\n\n        return ret;\n\n\n\n    outpicref = avfilter_ref_buffer(movie->picref, ~0);\n\n    ff_start_frame(outlink, outpicref);\n\n    ff_draw_slice(outlink, 0, outlink->h, 1);\n\n    ff_end_frame(outlink);\n\n    avfilter_unref_buffer(movie->picref);\n\n    movie->picref = NULL;\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n",
        "output": "1",
        "idx": 5956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n",
        "output": "0",
        "idx": 27
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ElectronBrowserHandlerImpl::UpdateDraggableRegions(\n    std::vector<mojom::DraggableRegionPtr> regions) {\n  api::WebContents* api_web_contents = api::WebContents::From(web_contents());\n  if (api_web_contents) {\n    api_web_contents->UpdateDraggableRegions(std::move(regions));\n  }\n}",
        "output": "1",
        "idx": 3495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void esp_init(target_phys_addr_t espaddr, int it_shift,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_read,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_write,\n\n              void *dma_opaque, qemu_irq irq, qemu_irq *reset,\n\n              qemu_irq *dma_enable)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SysBusESPState *sysbus;\n\n    ESPState *esp;\n\n\n\n    dev = qdev_create(NULL, \"esp\");\n\n    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);\n\n    esp = &sysbus->esp;\n\n    esp->dma_memory_read = dma_memory_read;\n\n    esp->dma_memory_write = dma_memory_write;\n\n    esp->dma_opaque = dma_opaque;\n\n    sysbus->it_shift = it_shift;\n\n    /* XXX for now until rc4030 has been changed to use DMA enable signal */\n\n    esp->dma_enabled = 1;\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, espaddr);\n\n    *reset = qdev_get_gpio_in(dev, 0);\n\n    *dma_enable = qdev_get_gpio_in(dev, 1);\n\n}\n",
        "output": "0",
        "idx": 322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CAMLprim value caml_alloc_dummy(value size)\n{\n  mlsize_t wosize = Int_val(size);\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}",
        "output": "1",
        "idx": 5102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}",
        "output": "1",
        "idx": 169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_timespec __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err) {\n\t\terr = put_user(kts.tv_sec, &up->tv_sec);\n\t\terr |= __put_user(kts.tv_nsec, &up->tv_nsec);\n\t}\n\treturn err;\n}",
        "output": "1",
        "idx": 3422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct output_pixel_processor *dce80_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}",
        "output": "0",
        "idx": 6115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CtPtr ProtocolV1::handle_client_banner_write(int r) {\n  ldout(cct, 20) << __func__ << \" r=\" << r << dendl;\n\n  if (r < 0) {\n    ldout(cct, 1) << __func__ << \" write client banner failed\" << dendl;\n    return _fault();\n  }\n  ldout(cct, 10) << __func__ << \" connect write banner done: \"\n                 << connection->get_peer_addr() << dendl;\n\n  return wait_server_banner();\n}",
        "output": "0",
        "idx": 3603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDF::resolve(int objid, int generation)\n{\n    // Check object cache before checking xref table.  This allows us\n    // to insert things into the object cache that don't actually\n    // exist in the file.\n    QPDFObjGen og(objid, generation);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    // PDF spec says unknown objects resolve to the null object.\n\t    return new QPDF_Null;\n\t}\n\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\t// Object stored in cache by readObjectAtOffset\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n\n    return this->obj_cache[og].object;\n}",
        "output": "1",
        "idx": 5061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n",
        "output": "0",
        "idx": 2209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 5184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MD5::checkDataChecksum(char const* const checksum,\n\t\t       char const* buf, int len)\n{\n    std::string actual_checksum = getDataChecksum(buf, len);\n    return (checksum == actual_checksum);\n}",
        "output": "1",
        "idx": 774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n    int ret;\n\n    int changed;\n\n\n\n    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n    changed = cow_test_bit(bitnum, bitmap);\n\n    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n    return changed;\n\n}\n",
        "output": "1",
        "idx": 2596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}",
        "output": "1",
        "idx": 3419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prune_dead_connections(struct Curl_easy *data)\n{\n  struct curltime now = Curl_now();\n  timediff_t elapsed;\n\n  DEBUGASSERT(!data->conn); /* no connection */\n  CONNCACHE_LOCK(data);\n  elapsed =\n    Curl_timediff(now, data->state.conn_cache->last_cleanup);\n  CONNCACHE_UNLOCK(data);\n\n  if(elapsed >= 1000L) {\n    struct prunedead prune;\n    prune.data = data;\n    prune.extracted = NULL;\n    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,\n                                 call_extract_if_dead)) {\n      /* unlocked */\n\n      /* remove connection from cache */\n      Curl_conncache_remove_conn(data, prune.extracted, TRUE);\n\n      /* disconnect it */\n      Curl_disconnect(data, prune.extracted, TRUE);\n    }\n    CONNCACHE_LOCK(data);\n    data->state.conn_cache->last_cleanup = now;\n    CONNCACHE_UNLOCK(data);\n  }\n}",
        "output": "0",
        "idx": 5761
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(WriterTest, WriteLongLong) {\n  CHECK_WRITE(56ll);\n  CHECK_WRITE(78ull);\n  CHECK_WRITE(std::numeric_limits<long long>::min());\n  CHECK_WRITE(std::numeric_limits<long long>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());\n}",
        "output": "0",
        "idx": 1491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void net_tx_pkt_dump(struct NetTxPkt *pkt)\n{\n#ifdef NET_TX_PKT_DEBUG\n    assert(pkt);\n\n    printf(\"TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, \"\n        \"l3hdr_len: %lu, payload_len: %u\\n\", pkt->hdr_len, pkt->packet_type,\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);\n#endif\n}",
        "output": "0",
        "idx": 6262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,\n\n                        void *s, void *sp)\n\n{\n\n    DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd);\n\n    switch (action) {\n\n        case CURL_POLL_IN:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);\n\n            break;\n\n        case CURL_POLL_OUT:\n\n            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_INOUT:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_REMOVE:\n\n            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);\n\n            break;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit v8_action_t(ActionFeature const& actionFeature)\n      : TRI_action_t(), _actionFeature(actionFeature), _callbacks(), _callbacksLock() {}",
        "output": "0",
        "idx": 5423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "finish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(SOME_VALID);\n    }\n}",
        "output": "0",
        "idx": 5695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)\n\n{\n\n    ROQDPCMContext *context = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be mono or stereo\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 22050) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be 22050 Hz\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be signed 16-bit\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;\n\n\n\n    context->lastSample[0] = context->lastSample[1] = 0;\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 5954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n",
        "output": "1",
        "idx": 4211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int mirror(int v, int m){\n\n    if     (v<0) return -v;\n\n    else if(v>m) return 2*m-v;\n\n    else         return v;\n\n}\n",
        "output": "1",
        "idx": 257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(HttpStatusChecker, InvalidExpectedRange) {\n  const std::string yaml = R\"EOF(\n  timeout: 1s\n  interval: 1s\n  unhealthy_threshold: 2\n  healthy_threshold: 2\n  http_health_check:\n    service_name_matcher:\n        prefix: locations\n    path: /healthchecka\n    expected_statuses:\n      - start: 200\n        end: 200\n  )EOF\";\n\n  auto conf = parseHealthCheckFromV3Yaml(yaml);\n  EXPECT_THROW_WITH_MESSAGE(\n      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(\n          conf.http_health_check().expected_statuses(),\n          conf.http_health_check().retriable_statuses(), 200),\n      EnvoyException,\n      \"Invalid http expected status range: expecting start < end, but found start=200 and end=200\");\n}",
        "output": "0",
        "idx": 319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,\n          const Dims<4>& output_dims) {\n  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),\n       output_data);\n}",
        "output": "0",
        "idx": 1650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ssh_buffer_struct *ssh_buffer_new(void)\n{\n    struct ssh_buffer_struct *buf = NULL;\n    int rc;\n\n    buf = calloc(1, sizeof(struct ssh_buffer_struct));\n    if (buf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * Always preallocate 64 bytes.\n     *\n     * -1 for ralloc_buffer magic.\n     */\n    rc = ssh_buffer_allocate_size(buf, 64 - 1);\n    if (rc != 0) {\n        SAFE_FREE(buf);\n        return NULL;\n    }\n    buffer_verify(buf);\n\n    return buf;\n}",
        "output": "0",
        "idx": 2196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}",
        "output": "1",
        "idx": 3322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Status ParseActivationMode(OpKernelConstruction* context,\n                           FusedBatchNormActivationMode* activation_mode) {\n  string activation_mode_str;\n  TF_RETURN_IF_ERROR(context->GetAttr(\"activation_mode\", &activation_mode_str));\n\n  if (activation_mode_str == \"Identity\") {\n    *activation_mode = FusedBatchNormActivationMode::kIdentity;\n    return Status::OK();\n  }\n  if (activation_mode_str == \"Relu\") {\n    *activation_mode = FusedBatchNormActivationMode::kRelu;\n    return Status::OK();\n  }\n  return errors::InvalidArgument(\"Unsupported activation mode: \",\n                                 activation_mode_str);\n}",
        "output": "0",
        "idx": 4333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)\n{\n    srpsrvparm *p = (srpsrvparm *) arg;\n    if (p->login == NULL && p->user == NULL) {\n        p->login = SSL_get_srp_username(s);\n        BIO_printf(bio_err, \"SRP username = \\\"%s\\\"\\n\", p->login);\n        return (-1);\n    }\n\n    if (p->user == NULL) {\n        BIO_printf(bio_err, \"User %s doesn't exist\\n\", p->login);\n        return SSL3_AL_FATAL;\n    }\n    if (SSL_set_srp_server_param\n        (s, p->user->N, p->user->g, p->user->s, p->user->v,\n         p->user->info) < 0) {\n        *ad = SSL_AD_INTERNAL_ERROR;\n        return SSL3_AL_FATAL;\n    }\n    BIO_printf(bio_err,\n               \"SRP parameters set: username = \\\"%s\\\" info=\\\"%s\\\" \\n\",\n               p->login, p->user->info);\n    /* need to check whether there are memory leaks */\n    p->user = NULL;\n    p->login = NULL;\n    return SSL_ERROR_NONE;\n}",
        "output": "1",
        "idx": 245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tpm_passthrough_unix_tx_bufs(int tpm_fd,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        error_report(\"tpm_passthrough: error while transmitting data \"\n\n                     \"to TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n        goto err_exit;\n\n    }\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        error_report(\"tpm_passthrough: error while reading data from \"\n\n                     \"TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 4356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC\n{\t/* Returns a locked and ready for use mspace */\n\tmstate m=p->m[mymspace];\n\tassert(m);\n\tif(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\\\n\t/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/\n\treturn m;\n}",
        "output": "0",
        "idx": 694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AVFrame *avcodec_alloc_frame(void)\n\n{\n\n    AVFrame *frame = av_mallocz(sizeof(AVFrame));\n\n\n\n    if (frame == NULL)\n\n        return NULL;\n\n\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avcodec_get_frame_defaults(frame);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    return frame;\n\n}\n",
        "output": "0",
        "idx": 1832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)\n{\n    int pal_start, pal_count, i, ret, fps;\n\n    if(buf_end - buf < 16) {\n        av_log(s->avctx, AV_LOG_WARNING, \"truncated header\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->width  = AV_RL16(&buf[4]);\n    s->height = AV_RL16(&buf[6]);\n\n    ret = ff_set_dimensions(s->avctx, s->width, s->height);\n    if (ret < 0)\n        return ret;\n\n    fps = AV_RL16(&buf[10]);\n    if (fps > 0)\n        s->avctx->time_base = (AVRational){ 1, fps };\n\n    pal_start = AV_RL16(&buf[12]);\n    pal_count = AV_RL16(&buf[14]);\n\n    buf += 16;\n    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {\n        s->palette[i] = AV_RB24(buf);\n        buf += 3;\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 4687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t))) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}",
        "output": "1",
        "idx": 47
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline size_t xfrm_sadinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_sadhinfo))\n\t       + nla_total_size(4); /* XFRMA_SAD_CNT */\n}",
        "output": "0",
        "idx": 1244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void breakpoint_handler(CPUState *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n    if (prev_debug_excp_handler)\n\n        prev_debug_excp_handler(env);\n\n}\n",
        "output": "0",
        "idx": 1539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _gnutls_fips_perform_self_checks1(void)\n{\n\tint ret;\n\n\t_gnutls_switch_lib_state(LIB_STATE_SELFTEST);\n\n\t/* Tests the FIPS algorithms used by nettle internally.\n\t * In our case we test AES-CBC since nettle's AES is used by\n\t * the DRBG-AES.\n\t */\n\n\t/* ciphers - one test per cipher */\n\tret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t_gnutls_switch_lib_state(LIB_STATE_ERROR);\n\t_gnutls_audit_log(NULL, \"FIPS140-2 self testing part1 failed\\n\");\n\n\treturn GNUTLS_E_SELF_TEST_ERROR;\n}",
        "output": "0",
        "idx": 2870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 3491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n\tVNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n\treturn NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n",
        "output": "0",
        "idx": 1353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *rxe_find_route6(struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\treturn NULL;\n}",
        "output": "1",
        "idx": 3008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)\n\n{\n\n    int64_t scaled_dim;\n\n\n\n    if (!sar.den)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!sar.num || sar.num == sar.den)\n\n        return 0;\n\n\n\n    if (sar.num < sar.den)\n\n        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);\n\n    else\n\n        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);\n\n\n\n    if (scaled_dim > 0)\n\n        return 0;\n\n\n\n    return AVERROR(EINVAL);\n\n}\n",
        "output": "1",
        "idx": 2771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tss2_add_vserver (int vserver_port)\n{\n\t/*\n\t * Adds a new vserver to the linked list\n\t */\n\tvserver_list_t *entry;\n\n\t/* Check port range */\n\tif ((vserver_port <= 0) || (vserver_port > 65535))\n\t{\n\t\tERROR (\"teamspeak2 plugin: VServer port is invalid: %i\",\n\t\t\t\tvserver_port);\n\t\treturn (-1);\n\t}\n\n\t/* Allocate memory */\n\tentry = malloc (sizeof (*entry));\n\tif (entry == NULL)\n\t{\n\t\tERROR (\"teamspeak2 plugin: malloc failed.\");\n\t\treturn (-1);\n\t}\n\tmemset (entry, 0, sizeof (vserver_list_t));\n\n\t/* Save data */\n\tentry->port = vserver_port;\n\n\t/* Insert to list */\n\tif(server_list == NULL) {\n\t\t/* Add the server as the first element */\n\t\tserver_list = entry;\n\t}\n\telse {\n\t\tvserver_list_t *prev;\n\n\t\t/* Add the server to the end of the list */\n\t\tprev = server_list;\n\t\twhile (prev->next != NULL)\n\t\t\tprev = prev->next;\n\t\tprev->next = entry;\n\t}\n\n\tINFO (\"teamspeak2 plugin: Registered new vserver: %i\", vserver_port);\n\n\treturn (0);\n} /* int tss2_add_vserver */",
        "output": "0",
        "idx": 6141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DCTStream::getChars(int nChars, unsigned char *buffer)\n{\n    for (int i = 0; i < nChars;) {\n        if (current == limit) {\n            if (!readLine())\n                return i;\n        }\n        int left = limit - current;\n        if (nChars < left)\n            left = nChars;\n        memcpy(buffer + i, current, left);\n        current += left;\n        i += left;\n    }\n    return nChars;\n}",
        "output": "1",
        "idx": 2522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}",
        "output": "1",
        "idx": 6066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n\n    visit_free(v);\n\n}",
        "output": "1",
        "idx": 2392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "1",
        "idx": 1162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,\n\n                  void *priv_data, RTPDynamicProtocolHandler *handler)\n\n{\n\n    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->ic = ic;\n\n    s->streams = &ic->streams[first_stream_of_set_idx];\n\n    do {\n\n        s->n_streams++;\n\n    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&\n\n             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);\n\n    s->prev_set_id    = -1;\n\n    s->prev_stream_id = -1;\n\n    s->prev_timestamp = -1;\n\n    s->parse_packet = handler->parse_packet;\n\n    s->dynamic_protocol_context = priv_data;\n\n\n\n    return s;\n\n}\n",
        "output": "1",
        "idx": 3152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spapr_cpu_core_host_initfn(Object *obj)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);\n\n    char *name = g_strdup_printf(\"%s-\" TYPE_POWERPC_CPU, \"host\");\n\n    ObjectClass *oc = object_class_by_name(name);\n\n\n\n    g_assert(oc);\n\n    g_free((void *)name);\n\n    core->cpu_class = oc;\n\n}\n",
        "output": "0",
        "idx": 165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vc1_v_overlap_c(uint8_t* src, int stride)\n\n{\n\n    int i;\n\n    int a, b, c, d;\n\n    int d1, d2;\n\n    int rnd = 1;\n\n    for(i = 0; i < 8; i++) {\n\n        a = src[-2*stride];\n\n        b = src[-stride];\n\n        c = src[0];\n\n        d = src[stride];\n\n        d1 = (a - d + 3 + rnd) >> 3;\n\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n\n\n        src[-2*stride] = a - d1;\n\n        src[-stride] = b - d2;\n\n        src[0] = c + d2;\n\n        src[stride] = d + d1;\n\n        src++;\n\n        rnd = !rnd;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)\n{\n    GError *real_error = NULL;\n    int result;\n\n    rsvg_return_val_if_fail (handle != NULL, FALSE, error);\n\n    handle->priv->error = &real_error;\n    if (handle->priv->ctxt == NULL) {\n        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,\n                                                      rsvg_handle_get_base_uri (handle));\n\n        /* if false, external entities work, but internal ones don't. if true, internal entities\n           work, but external ones don't. favor internal entities, in order to not cause a\n           regression */\n        handle->priv->ctxt->replaceEntities = TRUE;\n    }\n\n    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);\n    if (result != 0) {\n        rsvg_set_error (error, handle->priv->ctxt);\n        return FALSE;\n    }\n\n    handle->priv->error = NULL;\n\n    if (real_error != NULL) {\n        g_propagate_error (error, real_error);\n        return FALSE;\n    }\n\n    return TRUE;\n}",
        "output": "1",
        "idx": 4623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MigrationState *migrate_get_current(void)\n\n{\n\n    static MigrationState current_migration = {\n\n        .state = MIG_STATE_NONE,\n\n        .bandwidth_limit = MAX_THROTTLE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n    };\n\n\n\n    return &current_migration;\n\n}\n",
        "output": "1",
        "idx": 3423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    uint64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n\n\n\n    mr = ddc->get_memory_region(dimm);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_uint64(v, name, &value, errp);\n\n}\n",
        "output": "1",
        "idx": 1263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Autocrop image region, regarding the specified background value \\newinstance.\n    CImg<T> get_autocrop(const T& value, const char *const axes=\"czyx\") const {\n      return (+*this).autocrop(value,axes);",
        "output": "0",
        "idx": 2931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,\n\n                              int dump_payload, AVRational time_base)\n\n{\n\n    HEXDUMP_PRINT(\"stream #%d:\\n\", pkt->stream_index);\n\n    HEXDUMP_PRINT(\"  keyframe=%d\\n\", (pkt->flags & AV_PKT_FLAG_KEY) != 0);\n\n    HEXDUMP_PRINT(\"  duration=%0.3f\\n\", pkt->duration * av_q2d(time_base));\n\n    /* DTS is _always_ valid after av_read_frame() */\n\n    HEXDUMP_PRINT(\"  dts=\");\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->dts * av_q2d(time_base));\n\n    /* PTS may not be known if B-frames are present. */\n\n    HEXDUMP_PRINT(\"  pts=\");\n\n    if (pkt->pts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->pts * av_q2d(time_base));\n\n    HEXDUMP_PRINT(\"\\n\");\n\n    HEXDUMP_PRINT(\"  size=%d\\n\", pkt->size);\n\n    if (dump_payload)\n\n        av_hex_dump(f, pkt->data, pkt->size);\n\n}\n",
        "output": "1",
        "idx": 1346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hds_free(AVFormatContext *s)\n\n{\n\n    HDSContext *c = s->priv_data;\n\n    int i, j;\n\n    if (!c->streams)\n\n        return;\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        OutputStream *os = &c->streams[i];\n\n        if (os->out)\n\n            avio_close(os->out);\n\n        os->out = NULL;\n\n        if (os->ctx && os->ctx_inited)\n\n            av_write_trailer(os->ctx);\n\n        if (os->ctx && os->ctx->pb)\n\n            av_free(os->ctx->pb);\n\n        if (os->ctx)\n\n            avformat_free_context(os->ctx);\n\n        av_free(os->metadata);\n\n        for (j = 0; j < os->nb_extra_packets; j++)\n\n            av_free(os->extra_packets[j]);\n\n        for (j = 0; j < os->nb_fragments; j++)\n\n            av_free(os->fragments[j]);\n\n        av_free(os->fragments);\n\n    }\n\n    av_freep(&c->streams);\n\n}\n",
        "output": "0",
        "idx": 2241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
        "output": "1",
        "idx": 2492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 3720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n",
        "output": "1",
        "idx": 805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n",
        "output": "1",
        "idx": 111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *object_get_typename(Object *obj)\n\n{\n\n    return obj->class->type->name;\n\n}\n",
        "output": "1",
        "idx": 740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_qemu_strtoull_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 18446744073709551295LLU);\n\n}\n",
        "output": "0",
        "idx": 5344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sodium_misuse_handler(void)\n{\n\tfatal_exit(\n\t\t\"dnscrypt: libsodium could not be initialized, this typically\"\n\t\t\" happens when no good source of entropy is found. If you run\"\n\t\t\" unbound in a chroot, make sure /dev/urandom is available. See\"\n\t\t\" https://www.unbound.net/documentation/unbound.conf.html\");\n}",
        "output": "0",
        "idx": 3182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_parse_skb(struct sk_buff *skb, struct common_audit_data *ad,\n\t\t\t     char **_addrp, int src, u8 *proto)\n{\n\tchar *addrp;\n\tint ret;\n\n\tswitch (ad->u.net->family) {\n\tcase PF_INET:\n\t\tret = selinux_parse_skb_ipv4(skb, ad, proto);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t\taddrp = (char *)(src ? &ad->u.net->v4info.saddr :\n\t\t\t\t       &ad->u.net->v4info.daddr);\n\t\tgoto okay;\n\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\n\tcase PF_INET6:\n\t\tret = selinux_parse_skb_ipv6(skb, ad, proto);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t\taddrp = (char *)(src ? &ad->u.net->v6info.saddr :\n\t\t\t\t       &ad->u.net->v6info.daddr);\n\t\tgoto okay;\n#endif\t/* IPV6 */\n\tdefault:\n\t\taddrp = NULL;\n\t\tgoto okay;\n\t}\n\nparse_error:\n\tprintk(KERN_WARNING\n\t       \"SELinux: failure in selinux_parse_skb(),\"\n\t       \" unable to parse packet\\n\");\n\treturn ret;\n\nokay:\n\tif (_addrp)\n\t\t*_addrp = addrp;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(xml_parser_create)\n{\n\tphp_xml_parser_create_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\t\n}",
        "output": "1",
        "idx": 2735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)\n{\n\t/* Mark all delegations for reclaim */\n\tnfs_delegation_mark_reclaim(clp);\n\tnfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);\n}",
        "output": "0",
        "idx": 2609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Virtual_column_info::fix_session_expr_for_read(THD *thd, Field *field)\n{\n  DBUG_ENTER(\"fix_session_vcol_expr_for_read\");\n  TABLE_LIST *tl= field->table->pos_in_table_list;\n  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)\n    DBUG_RETURN(0);\n  Security_context *save_security_ctx= thd->security_ctx;\n  if (tl->security_ctx)\n    thd->security_ctx= tl->security_ctx;\n  bool res= fix_session_expr(thd);\n  thd->security_ctx= save_security_ctx;\n  DBUG_RETURN(res);\n}",
        "output": "1",
        "idx": 124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}",
        "output": "1",
        "idx": 1679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
        "output": "0",
        "idx": 5180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ap_lua_push_connection(lua_State *L, conn_rec *c)\n{\n    req_table_t* t;\n    lua_boxpointer(L, c);\n    luaL_getmetatable(L, \"Apache2.Connection\");\n    lua_setmetatable(L, -2);\n    luaL_getmetatable(L, \"Apache2.Connection\");\n\n    t = apr_pcalloc(c->pool, sizeof(req_table_t));\n    t->t = c->notes;\n    t->r = NULL;\n    t->n = \"notes\";\n    ap_lua_push_apr_table(L, t);\n    lua_setfield(L, -2, \"notes\");\n\n    lua_pushstring(L, c->client_ip);\n    lua_setfield(L, -2, \"client_ip\");\n\n    lua_pop(L, 1);\n}",
        "output": "0",
        "idx": 312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INLINE void gdi_RectToCRgn(const HGDI_RECT rect, INT32* x, INT32* y, INT32* w, INT32* h)\n{\n\t*x = rect->left;\n\t*y = rect->top;\n\t*w = rect->right - rect->left + 1;\n\t*h = rect->bottom - rect->top + 1;\n}",
        "output": "1",
        "idx": 2705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n",
        "output": "1",
        "idx": 121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void calipso_doi_putdef(struct calipso_doi *doi_def)\n{\n\tif (!doi_def)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&doi_def->refcount))\n\t\treturn;\n\tspin_lock(&calipso_doi_list_lock);\n\tlist_del_rcu(&doi_def->list);\n\tspin_unlock(&calipso_doi_list_lock);\n\n\tcall_rcu(&doi_def->rcu, calipso_doi_free_rcu);\n}",
        "output": "1",
        "idx": 5426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = fxArgToByteLength(the, 0, 0);\n\ttxInteger size;\n\tint endian = EndianBig;\n\ttxSlot* value;\n\tif (mxArgc > 1)\n\t\tmxPushSlot(mxArgv(1));\n\telse\n\t\tmxPushUndefined();\n\tvalue = the->stack;\t\n\t(*coercer)(the, value);\n\tif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tendian = EndianLittle;\n\tsize = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);\n\tif ((size < delta) || ((size - delta) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");\n\toffset += view->value.dataView.offset;\n\t(*setter)(the, buffer->value.reference->next, offset, value, endian);\n\tmxPop();\n}",
        "output": "0",
        "idx": 276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\n\nout:\n    g_free(elem);\n}",
        "output": "1",
        "idx": 772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n",
        "output": "1",
        "idx": 1341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)\n{\n\tstruct ptirq_remapping_info *entry;\n\tDEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);\n\tstruct intr_source intr_src;\n\n\tentry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);\n\tif ((entry != NULL) && (entry->vm == vm)) {\n\t\tif (is_entry_active(entry)) {\n\t\t\t/*TODO: disable MSIX device when HV can in future */\n\t\t\tptirq_deactivate_entry(entry);\n\t\t}\n\n\t\tintr_src.is_msi = true;\n\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\n\t\tdev_dbg(DBG_LEVEL_IRQ, \"VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d\",\n\t\t\tvm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);\n\n\t\tptirq_release_entry(entry);\n\t}\n\n}",
        "output": "0",
        "idx": 703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mif_validate(jas_stream_t *in)\n{\n\tuchar buf[MIF_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Was enough data read? */\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t/* Compute the signature value. */\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\t/* Ensure that the signature is correct for this format. */\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 4726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_key_ctx (struct key_ctx *ctx)\n{\n  if (ctx->cipher)\n    {\n      cipher_ctx_cleanup(ctx->cipher);\n      free(ctx->cipher);\n      ctx->cipher = NULL;\n    }\n  if (ctx->hmac)\n    {\n      hmac_ctx_cleanup(ctx->hmac);\n      free(ctx->hmac);\n      ctx->hmac = NULL;\n    }\n}",
        "output": "0",
        "idx": 1399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QBool *qbool_from_bool(bool value)\n\n{\n\n    QBool *qb;\n\n\n\n    qb = g_malloc(sizeof(*qb));\n\n    qb->value = value;\n\n    QOBJECT_INIT(qb, &qbool_type);\n\n\n\n    return qb;\n\n}\n",
        "output": "0",
        "idx": 5914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}",
        "output": "1",
        "idx": 68
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)\n\n{\n\n    switch (drc->state) {\n\n    case SPAPR_DRC_STATE_PHYSICAL_POWERON:\n\n        return RTAS_OUT_SUCCESS; /* Nothing to do */\n\n    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:\n\n        break; /* see below */\n\n    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:\n\n        return RTAS_OUT_PARAM_ERROR; /* not allowed */\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* if the guest is configuring a device attached to this DRC, we\n\n     * should reset the configuration state at this point since it may\n\n     * no longer be reliable (guest released device and needs to start\n\n     * over, or unplug occurred so the FDT is no longer valid)\n\n     */\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;\n\n\n\n    if (drc->unplug_requested) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_isolation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n",
        "output": "0",
        "idx": 4689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n\n{\n\n    int i, len, sz;\n\n    GetBitContext gb;\n\n    int code_table[64];\n\n\n\n    /* get the rle codes (at most 64 bytes) */\n\n    init_get_bits(&gb, src, 64 * 8);\n\n    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {\n\n        code_table[i] = get_sbits(&gb, 4);\n\n        sz += FFABS(code_table[i]);\n\n    }\n\n    src += (get_bits_count(&gb) + 7) / 8;\n\n\n\n    /* do the rle unpacking */\n\n    for (i = 0; i < 64 && dst_size > 0; i++) {\n\n        len = code_table[i];\n\n        if (len < 0) {\n\n            len = -len;\n\n            memset(dst, *src++, FFMIN(len, dst_size));\n\n        } else {\n\n            memcpy(dst, src, FFMIN(len, dst_size));\n\n            src += len;\n\n        }\n\n        dst += len;\n\n        dst_size -= len;\n\n    }\n\n    return src;\n\n}\n",
        "output": "1",
        "idx": 5699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_bson_concat (void)\n{\n   bson_t a = BSON_INITIALIZER;\n   bson_t b = BSON_INITIALIZER;\n   bson_t c = BSON_INITIALIZER;\n\n   bson_append_int32 (&a, \"abc\", 3, 1);\n   bson_append_int32 (&b, \"def\", 3, 1);\n   bson_concat (&a, &b);\n\n   bson_append_int32 (&c, \"abc\", 3, 1);\n   bson_append_int32 (&c, \"def\", 3, 1);\n\n   BSON_ASSERT (0 == bson_compare (&c, &a));\n\n   bson_destroy (&a);\n   bson_destroy (&b);\n   bson_destroy (&c);\n}",
        "output": "0",
        "idx": 6243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)\n{\n    test_common_bounds_server(is, os);\n\n    /* Message type & pad */\n    test_send_u8(os, 0);\n    test_send_u8(os, 0);\n\n    /* num rect */\n    test_send_u16(os, 1);\n    /* x, y, w, h */\n    test_send_u16(os, 90);\n    test_send_u16(os, 90);\n    test_send_u16(os, 10);\n    test_send_u16(os, 10);\n\n    /* encoding=rre */\n    test_send_s32(os, 2);\n\n    /* num rect */\n    test_send_u32(os, 1);\n\n    /* bg pix, fg pix */\n    test_send_u32(os, 0x41414141);\n    test_send_u32(os, 0x42424242);\n\n    /* x, y, w, h */\n    test_send_u16(os, 10);\n    test_send_u16(os, 10000);\n    test_send_u16(os, 1);\n    test_send_u16(os, 1);\n}",
        "output": "0",
        "idx": 5367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HValueMap::HValueMap(Zone* zone, const HValueMap* other)\n    : array_size_(other->array_size_),\n      lists_size_(other->lists_size_),\n      count_(other->count_),\n      present_flags_(other->present_flags_),\n      array_(zone->NewArray<HValueMapListElement>(other->array_size_)),\n      lists_(zone->NewArray<HValueMapListElement>(other->lists_size_)),\n      free_list_head_(other->free_list_head_) {\n  memcpy(array_, other->array_, array_size_ * sizeof(HValueMapListElement));\n  memcpy(lists_, other->lists_, lists_size_ * sizeof(HValueMapListElement));\n}",
        "output": "0",
        "idx": 2514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n\n  if (self.db_ == nullptr) {\n    // Create primary SQLite DB instance.\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n\n  // Internal usage may request the primary connection explicitly.\n  if (primary) {\n    return self.connection_;\n  }\n\n  // Create a 'database connection' for the managed database instance.\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}",
        "output": "1",
        "idx": 3979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n",
        "output": "0",
        "idx": 1949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\n{\n\t/* Map the uid from a global kernel uid */\n\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));\n}",
        "output": "0",
        "idx": 4606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *regs_query_register_name(unsigned int offset)\n{\n\tif (offset >= NUM_GPRS)\n\t\treturn NULL;\n\treturn gpr_names[offset];\n}",
        "output": "0",
        "idx": 6025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Visitor *qobject_input_visitor_new_keyval(QObject *obj)\n\n{\n\n    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);\n\n\n\n    v->visitor.type_int64 = qobject_input_type_int64_keyval;\n\n    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;\n\n    v->visitor.type_bool = qobject_input_type_bool_keyval;\n\n    v->visitor.type_str = qobject_input_type_str;\n\n    v->visitor.type_number = qobject_input_type_number_keyval;\n\n    v->visitor.type_any = qobject_input_type_any;\n\n    v->visitor.type_null = qobject_input_type_null;\n\n    v->visitor.type_size = qobject_input_type_size_keyval;\n\n\n\n    return &v->visitor;\n\n}\n",
        "output": "1",
        "idx": 389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_can_accept(void)\n\n{\n\n    return nb_fds < shared;\n\n}\n",
        "output": "1",
        "idx": 3854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fr_window_set_batch__extract_here (FrWindow *window,\n\t\t\t\t   GFile    *archive)\n{\n\tg_return_if_fail (window != NULL);\n\tg_return_if_fail (archive != NULL);\n\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_LOAD,\n\t\t\t\t       g_object_ref (archive),\n\t\t\t\t       (GFreeFunc) g_object_unref);\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_EXTRACT_HERE,\n\t\t\t\t       extract_to_data_new (window, NULL),\n\t\t\t\t       (GFreeFunc) extract_data_free);\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_CLOSE,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n}",
        "output": "0",
        "idx": 980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "su_catch_sig (int sig)\n{\n  caught_signal = sig;\n}",
        "output": "0",
        "idx": 2929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,\n                                        UINT32 NumInterfaces)\n{\n\tUINT32 inum = 0;\n\n\tif (MsInterfaces)\n\t{\n\t\tfor (inum = 0; inum < NumInterfaces; inum++)\n\t\t{\n\t\t\tmsusb_msinterface_free(MsInterfaces[inum]);\n\t\t}\n\n\t\tfree(MsInterfaces);\n\t}\n}",
        "output": "0",
        "idx": 2383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ssl3_take_mac(SSL *s)\n\t{\n\tconst char *sender;\n\tint slen;\n\n\tif (s->state & SSL_ST_CONNECT)\n\t\t{\n\t\tsender=s->method->ssl3_enc->server_finished_label;\n\t\tslen=s->method->ssl3_enc->server_finished_label_len;\n\t\t}\n\telse\n\t\t{\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\t}",
        "output": "1",
        "idx": 5469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stripe_map_sector(struct stripe_c *sc, sector_t sector,\n\t\t\t      uint32_t *stripe, sector_t *result)\n{\n\tsector_t chunk = dm_target_offset(sc->ti, sector);\n\tsector_t chunk_offset = sector_div(chunk, sc->chunk_size);\n\n\tif (sc->stripes_shift < 0)\n\t\t*stripe = sector_div(chunk, sc->stripes);\n\telse {\n\t\t*stripe = chunk & (sc->stripes - 1);\n\t\tchunk >>= sc->stripes_shift;\n\t}\n\n\t*result = (chunk * sc->chunk_size) + chunk_offset;\n}",
        "output": "0",
        "idx": 5674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
        "output": "1",
        "idx": 1061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_tight_stop(VncState *vs)\n{\n    // switch back to normal output/zlib buffers\n    vs->tight.tight = vs->output;\n    vs->output = vs->tight.tmp;\n}",
        "output": "1",
        "idx": 6012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual const string name() { return \"put_obj_tags\"; }",
        "output": "0",
        "idx": 5599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}",
        "output": "0",
        "idx": 386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);\n\n}\n",
        "output": "1",
        "idx": 5689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (sts) {\t// STS k, Rr\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\n\top->cycles = 2;\n}",
        "output": "1",
        "idx": 5430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int switch_user(uid_t user, gid_t group) {\n    save_egid = getegid();\n    save_euid = geteuid();\n    if (save_euid == user && save_egid == group)\n        return 0;\n    message(MESS_DEBUG, \"switching euid from %u to %u and egid from %u to %u (pid %d)\\n\",\n            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());\n    if (setegid(group) || seteuid(user)) {\n        message(MESS_ERROR, \"error switching euid from %u to %u and egid from %u to %u (pid %d): %s\\n\",\n                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),\n                strerror(errno));\n        return 1;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 1987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(RegexMatchExpression, MatchesElementMultilineOff) {\n    BSONObj match = BSON(\"x\"\n                         << \"az\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"\\naz\");\n    RegexMatchExpression regex;\n    ASSERT(regex.init(\"\", \"^a\", \"\").isOK());\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}",
        "output": "0",
        "idx": 4764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 4132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {\n\tbool res = false;\n\tchar *fcnstr = rz_str_newf(\"%s;\", newsig);\n\tchar *fcnstr_copy = strdup(fcnstr);\n\tchar *fcnname_aux = strtok(fcnstr_copy, \"(\");\n\trz_str_trim_tail(fcnname_aux);\n\tchar *fcnname = NULL;\n\tconst char *ls = rz_str_lchr(fcnname_aux, ' ');\n\tfcnname = strdup(ls ? ls : fcnname_aux);\n\tif (!fcnname) {\n\t\tgoto err;\n\t}\n\t// TODO: move this into rz_analysis_function_set_type_str()\n\tif (strcmp(fcn->name, fcnname)) {\n\t\t(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);\n\t\tfcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);\n\t}\n\trz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);\n\tres = true;\nerr:\n\tfree(fcnname);\n\tfree(fcnstr_copy);\n\tfree(fcnstr);\n\treturn res;\n}",
        "output": "0",
        "idx": 1147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_cmd(ESPState *s)\n{\n    uint8_t busid = fifo8_pop(&s->cmdfifo);\n\n    s->cmdfifo_cdb_offset--;\n\n    /* Ignore extended messages for now */\n    if (s->cmdfifo_cdb_offset) {\n        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);\n        s->cmdfifo_cdb_offset = 0;\n    }\n\n    do_busid_cmd(s, busid);\n}",
        "output": "1",
        "idx": 4732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n  }\n}",
        "output": "1",
        "idx": 6241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,\n\n                                           src - (stride * 2) +\n\n                                           sizeof(uint8_t), stride,\n\n                                           dst, stride);\n\n}\n",
        "output": "0",
        "idx": 1382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_async_encoding_start(VncState *orig, VncState *local)\n{\n    local->vnc_encoding = orig->vnc_encoding;\n    local->features = orig->features;\n    local->ds = orig->ds;\n    local->vd = orig->vd;\n    local->lossy_rect = orig->lossy_rect;\n    local->write_pixels = orig->write_pixels;\n    local->clientds = orig->clientds;\n    local->tight = orig->tight;\n    local->zlib = orig->zlib;\n    local->hextile = orig->hextile;\n    local->zrle = orig->zrle;\n    local->output =  queue->buffer;\n    local->csock = -1; /* Don't do any network work on this thread */\n\n    buffer_reset(&local->output);\n}",
        "output": "1",
        "idx": 5125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,\n\n                              int cpuid, void *opaque)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    return s390x_write_all_elf64_notes(\"CORE\", f, cpu, cpuid, opaque);\n\n}\n",
        "output": "1",
        "idx": 1548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_thread_init(AVCodecContext *avctx)\n\n{\n\n    if (avctx->thread_opaque) {\n\n        av_log(avctx, AV_LOG_ERROR, \"avcodec_thread_init is ignored after avcodec_open\\n\");\n\n        return -1;\n\n    }\n\n\n\n#if HAVE_W32THREADS\n\n    w32thread_init();\n\n#endif\n\n\n\n    if (avctx->codec) {\n\n        validate_thread_parameters(avctx);\n\n\n\n        if (avctx->active_thread_type&FF_THREAD_SLICE)\n\n            return thread_init(avctx);\n\n        else if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            return frame_thread_init(avctx);\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 1654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t  struct ath6kl_vif *vif)\n{\n\tstruct wmi_disconnect_event *ev;\n\twmi->traffic_class = 100;\n\n\tif (len < sizeof(struct wmi_disconnect_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_disconnect_event *) datap;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\\n\",\n\t\t   le16_to_cpu(ev->proto_reason_status), ev->bssid,\n\t\t   ev->disconn_reason, ev->assoc_resp_len);\n\n\twmi->is_wmm_enabled = false;\n\n\tath6kl_disconnect_event(vif, ev->disconn_reason,\n\t\t\t\tev->bssid, ev->assoc_resp_len, ev->assoc_info,\n\t\t\t\tle16_to_cpu(ev->proto_reason_status));\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static float ssim_plane(uint8_t *main, int main_stride,\n\n                        uint8_t *ref, int ref_stride,\n\n                        int width, int height, void *temp)\n\n{\n\n    int z = 0;\n\n    int x, y;\n\n    float ssim = 0.0;\n\n    int (*sum0)[4] = temp;\n\n    int (*sum1)[4] = sum0 + (width >> 2) + 3;\n\n\n\n    width >>= 2;\n\n    height >>= 2;\n\n\n\n    for (y = 1; y < height; y++) {\n\n        for (; z <= y; z++) {\n\n            FFSWAP(void*, sum0, sum1);\n\n            for (x = 0; x < width; x+=2)\n\n                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,\n\n                                &ref[4 * (x + z * ref_stride)], ref_stride,\n\n                                &sum0[x]);\n\n        }\n\n\n\n        ssim += ssim_endn(sum0, sum1, width - 1);\n\n    }\n\n\n\n    return ssim / ((height - 1) * (width - 1));\n\n}\n",
        "output": "0",
        "idx": 3144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  const void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);\n\treturn 1;\n}",
        "output": "0",
        "idx": 2115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(Array, current)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tzval **entry;\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_ZVAL(*entry, 1, 0);\n}",
        "output": "1",
        "idx": 6192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 5984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout);\n\t*offset = bloc;\n}",
        "output": "1",
        "idx": 4946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ffurl_shutdown(URLContext *h, int flags)\n\n{\n\n    if (!h->prot->url_shutdown)\n\n        return AVERROR(EINVAL);\n\n    return h->prot->url_shutdown(h, flags);\n\n}\n",
        "output": "0",
        "idx": 3403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void freed_request(struct request_list *rl, bool sync,\n\t\treq_flags_t rq_flags)\n{\n\tstruct request_queue *q = rl->q;\n\n\tq->nr_rqs[sync]--;\n\trl->count[sync]--;\n\tif (rq_flags & RQF_ELVPRIV)\n\t\tq->nr_rqs_elvpriv--;\n\n\t__freed_request(rl, sync);\n\n\tif (unlikely(rl->starved[sync ^ 1]))\n\t\t__freed_request(rl, sync ^ 1);\n}",
        "output": "0",
        "idx": 3994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold void ff_h264_free_context(H264Context *h)\n\n{\n\n    int i;\n\n\n\n    ff_h264_free_tables(h);\n\n\n\n    if (h->DPB) {\n\n        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n\n            ff_h264_unref_picture(h, &h->DPB[i]);\n\n        av_freep(&h->DPB);\n\n    }\n\n\n\n    h->cur_pic_ptr = NULL;\n\n\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        av_freep(&h->slice_ctx[i].rbsp_buffer);\n\n    av_freep(&h->slice_ctx);\n\n    h->nb_slice_ctx = 0;\n\n\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n\n        av_freep(h->sps_buffers + i);\n\n\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n\n        av_freep(h->pps_buffers + i);\n\n}\n",
        "output": "0",
        "idx": 4149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}",
        "output": "1",
        "idx": 1520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n",
        "output": "1",
        "idx": 3754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 4335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {\n    xmlDumpElementDecl(buf, elem);\n}",
        "output": "0",
        "idx": 5880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n",
        "output": "1",
        "idx": 4118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "copy_mml(MinMaxLen* to, MinMaxLen* from)\n{\n  to->min = from->min;\n  to->max = from->max;\n}",
        "output": "0",
        "idx": 4988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);\n\n}\n",
        "output": "0",
        "idx": 1657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n",
        "output": "1",
        "idx": 6081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n\n  DECLARE_MBSTATE;\n\n  open = 0;\n  send = string + strlen (string);\n\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\n\tcase '[':\n\t  open++;\n\t  continue;\n\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t/*)*/\n\t    return (1);\n\t  continue;\n\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n\n      /* Advance one fewer byte than an entire multibyte character to\n\t account for the auto-increment in the loop above. */\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}",
        "output": "1",
        "idx": 617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline int btrfs_ioctl_ino_lookup(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\t struct btrfs_ioctl_ino_lookup_args *args;\n\t struct inode *inode;\n\tint ret = 0;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = file_inode(file);\n\n\t/*\n\t * Unprivileged query to obtain the containing subvolume root id. The\n\t * path is reset so it's consistent with btrfs_search_path_in_tree.\n\t */\n\tif (args->treeid == 0)\n\t\targs->treeid = BTRFS_I(inode)->root->root_key.objectid;\n\n\tif (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\targs->name[0] = 0;\n\t\tgoto out;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\nout:\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int need_to_gc(void)\n{\n\t/*\n\t * Quickly check if a \"gc\" is needed, by estimating how\n\t * many loose objects there are.  Because SHA-1 is evenly\n\t * distributed, we can check only one and get a reasonable\n\t * estimate.\n\t */\n\tchar path[PATH_MAX];\n\tconst char *objdir = get_object_directory();\n\tDIR *dir;\n\tstruct dirent *ent;\n\tint auto_threshold;\n\tint num_loose = 0;\n\tint needed = 0;\n\n\t/*\n\t * Setting gc.auto to 0 or negative can disable the\n\t * automatic gc\n\t */\n\tif (gc_auto_threshold <= 0)\n\t\treturn 0;\n\n\tif (sizeof(path) <= snprintf(path, sizeof(path), \"%s/17\", objdir)) {\n\t\twarning(\"insanely long object directory %.*s\", 50, objdir);\n\t\treturn 0;\n\t}\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn 0;\n\n\tauto_threshold = (gc_auto_threshold + 255) / 256;\n\twhile ((ent = readdir(dir)) != NULL) {\n\t\tif (strspn(ent->d_name, \"0123456789abcdef\") != 38 ||\n\t\t    ent->d_name[38] != '\\0')\n\t\t\tcontinue;\n\t\tif (++num_loose > auto_threshold) {\n\t\t\tneeded = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclosedir(dir);\n\treturn needed;\n}",
        "output": "0",
        "idx": 2773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hci_cc_write_voice_setting(struct hci_dev *hdev,\n\t\t\t\t       struct sk_buff *skb)\n{\n\t__u8 status = *((__u8 *) skb->data);\n\t__u16 setting;\n\tvoid *sent;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\n\n\tif (status)\n\t\treturn;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\n\tif (!sent)\n\t\treturn;\n\n\tsetting = get_unaligned_le16(sent);\n\n\tif (hdev->voice_setting == setting)\n\t\treturn;\n\n\thdev->voice_setting = setting;\n\n\tBT_DBG(\"%s voice setting 0x%4.4x\", hdev->name, setting);\n\n\tif (hdev->notify)\n\t\thdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);\n}",
        "output": "0",
        "idx": 3073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t\t\toptname != IPV6_XFRM_POLICY)\n\t\terr = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);\n#endif\n\treturn err;\n}",
        "output": "0",
        "idx": 1163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n",
        "output": "1",
        "idx": 5451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QString Avahi::domainToDNS(const QString &domain)\n{\n    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);\n}",
        "output": "1",
        "idx": 5842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],\n\n                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],\n\n                        int i, int zero_nhood, int16_t qmul[2])\n\n{\n\n    uint8_t *token_prob = probs[i][zero_nhood];\n\n    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n\n        return 0;\n\n    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);\n\n}\n",
        "output": "1",
        "idx": 3198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}",
        "output": "1",
        "idx": 4917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v3_keyid (gcry_mpi_t a, u32 *ki)\n{\n  byte *buffer, *p;\n  size_t nbytes;\n\n  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))\n    BUG ();\n  /* fixme: allocate it on the stack */\n  buffer = xmalloc (nbytes);\n  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))\n    BUG ();\n  if (nbytes < 8) /* oops */\n    ki[0] = ki[1] = 0;\n  else\n    {\n      p = buffer + nbytes - 8;\n      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];\n      p += 4;\n      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];\n    }\n  xfree (buffer);\n  return ki[1];\n}",
        "output": "1",
        "idx": 2116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_hb_buffer_next_glyph ( HB_Buffer buffer )\n{\n  HB_Error  error;\n\n  if ( buffer->separate_out )\n    {\n      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );\n      if ( error )\n\treturn error;\n\n      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];\n    }\n\n  buffer->in_pos++;\n  buffer->out_pos++;\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}",
        "output": "1",
        "idx": 880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sha1_final(unsigned char *md, SHACTX c) {\n  SHA1_Final(md, c);\n  SAFE_FREE(c);\n}",
        "output": "0",
        "idx": 5416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned ip_vs_rs_hashkey(int af,\n\t\t\t\t\t    const union nf_inet_addr *addr,\n\t\t\t\t\t    __be16 port)\n{\n\tregister unsigned porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\n\treturn (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)\n\t\t& IP_VS_RTAB_MASK;\n}",
        "output": "0",
        "idx": 376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n\n    PROCNAME(\"gplotMakeOutput\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  /* _WIN32 */\n\n#ifndef OS_IOS /* iOS 11 does not support system() */\n    ignore = system(buf);  /* gnuplot || wgnuplot */\n#endif /* !OS_IOS */\n\n    LEPT_FREE(cmdname);\n    return 0;\n}",
        "output": "1",
        "idx": 1024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n\n\n    vlan = qemu_find_vlan(vlan_id);\n\n\n\n   for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n\n        if (!strcmp(vc->name, device))\n\n            break;\n\n\n\n    if (!vc) {\n\n        monitor_printf(mon, \"can't find device %s\\n\", device);\n\n        return;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n}\n",
        "output": "0",
        "idx": 371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_checksum(ByteIOContext *bc){\n\n    unsigned long checksum= get_checksum(bc);\n\n//    return checksum != get_be32(bc);\n\n\n\n    av_log(NULL, AV_LOG_ERROR, \"%08X %08X\\n\", checksum, (int)get_be32(bc));\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,\n\t\t\t\t      u64 chunk_offset)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tu64 bytes_used;\n\tu64 chunk_type;\n\n\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\tASSERT(cache);\n\tchunk_type = cache->flags;\n\tbtrfs_put_block_group(cache);\n\n\tif (chunk_type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tspin_lock(&fs_info->data_sinfo->lock);\n\t\tbytes_used = fs_info->data_sinfo->bytes_used;\n\t\tspin_unlock(&fs_info->data_sinfo->lock);\n\n\t\tif (!bytes_used) {\n\t\t\tstruct btrfs_trans_handle *trans;\n\t\t\tint ret;\n\n\t\t\ttrans =\tbtrfs_join_transaction(fs_info->tree_root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = btrfs_force_chunk_alloc(trans,\n\t\t\t\t\t\t      BTRFS_BLOCK_GROUP_DATA);\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbtrfs_add_raid_kobjects(fs_info);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 2987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n\n{\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n\n\n\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n\n     */\n\n    /* Sanity check */\n\n    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"_EJ0\", 4));\n\n\n\n    if (!eject) {\n\n        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"EJ0_\", 4);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\n\n\t/* update next pointer */\n\tif (head->next == node) {\n\t\tstruct rb_node *rbn = rb_next(&node->node);\n\n\t\thead->next = rb_entry_safe(rbn, struct timerqueue_node, node);\n\t}\n\trb_erase(&node->node, &head->head);\n\tRB_CLEAR_NODE(&node->node);\n\treturn head->next != NULL;\n}",
        "output": "1",
        "idx": 1105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)\n{\n    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n\n    if (v == NULL) return NULL;\n\n    v ->List      = NULL;\n    v ->nColors   = 0;\n    v ->ContextID  = ContextID;\n\n    while (v -> Allocated < n)\n        GrowNamedColorList(v);\n\n    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));\n    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));\n    v->Prefix[32] = v->Suffix[32] = 0;\n\n    v -> ColorantCount = ColorantCount;\n\n    return v;\n}",
        "output": "1",
        "idx": 5138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, int dstW, int y)\n\n{\n\n\tint i;\n\n\tswitch(c->dstFormat)\n\n\t{\n\n\tcase PIX_FMT_BGR32:\n\n\tcase PIX_FMT_RGB32:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint32_t)\n\n\t\t\t((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];\n\n\t\t\t((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];\n\n\t\t}\n\n\t\tbreak;\n\n\tcase PIX_FMT_RGB24:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint8_t)\n\n\t\t\t((uint8_t*)dest)[0]= r[Y1];\n\n\t\t\t((uint8_t*)dest)[1]= g[Y1];\n\n\t\t\t((uint8_t*)dest)[2]= b[Y1];\n\n\t\t\t((uint8_t*)dest)[3]= r[Y2];\n\n\t\t\t((uint8_t*)dest)[4]= g[Y2];\n\n\t\t\t((uint8_t*)dest)[5]= b[Y2];\n\n\t\t\tdest+=6;\n\n\t\t}\n",
        "output": "1",
        "idx": 5828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}",
        "output": "0",
        "idx": 1484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void consume_one_event(unsigned cpu,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready,\n\t\t\t      bool drop)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\n\thead = q->head[priority];\n\n\t/*\n\t * Reached the tail last time?  Read the new HEAD from the\n\t * control block.\n\t */\n\tif (head == 0) {\n\t\tvirt_rmb(); /* Ensure word is up-to-date before reading head. */\n\t\thead = control_block->head[priority];\n\t}\n\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\n\t/*\n\t * If the link is non-zero, there are more events in the\n\t * queue, otherwise the queue is empty.\n\t *\n\t * If the queue is empty, clear this priority from our local\n\t * copy of the ready word.\n\t */\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(drop))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port);\n\t}\n\n\tq->head[priority] = head;\n}",
        "output": "1",
        "idx": 2671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,\n\n                              int width, int y)\n\n{\n\n    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,\n\n                           0, y, 0, 0, 0, 0, width, 1);\n\n}\n",
        "output": "0",
        "idx": 2523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)\n{\n    if (!node || !sibling) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_nextto(sibling, node, 1, 1);\n}",
        "output": "0",
        "idx": 4040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WORD_LIST *\nexpand_words_no_vars (list)\n     WORD_LIST *list;\n{\n  return (expand_word_list_internal (list, WEXP_NOVARS));",
        "output": "0",
        "idx": 3601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CharDriverState *qemu_chr_open_pipe(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    ChardevHostdev *opts = backend->u.pipe;\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_new0(WinCharState, 1);\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename, errp) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n",
        "output": "0",
        "idx": 5900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    case kTfLiteInt8:\n      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,\n                                            output);\n      break;\n    case kTfLiteInt16:\n      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pair<string, string> splitField(const string& inp, char sepa)\n{\n  pair<string, string> ret;\n  string::size_type cpos=inp.find(sepa);\n  if(cpos==string::npos)\n    ret.first=inp;\n  else {\n    ret.first=inp.substr(0, cpos);\n    ret.second=inp.substr(cpos+1);\n  }\n  return ret;\n}",
        "output": "0",
        "idx": 3425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tswitch (yych) {\n\t\tcase 'a': goto yy18;\n\t\tdefault: goto yy17;\n\t}",
        "output": "1",
        "idx": 158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void s390_machine_reset(void)\n\n{\n\n    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));\n\n\n\n    qemu_devices_reset();\n\n    s390_cmma_reset();\n\n    s390_crypto_reset();\n\n\n\n    /* all cpus are stopped - configure and start the ipl cpu only */\n\n    s390_ipl_prepare_cpu(ipl_cpu);\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);\n\n}\n",
        "output": "1",
        "idx": 678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_arch_init_vcpu(CPUState *cenv)\n\n{\n\n    int ret = 0;\n\n    struct kvm_sregs sregs;\n\n\n\n    sregs.pvr = cenv->spr[SPR_PVR];\n\n    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);\n\n\n\n    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);\n\n\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 1957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\n\t__net_random_once_disable_jump(done_key);\n\n\treturn true;\n}",
        "output": "1",
        "idx": 1301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void win_chr_readfile(CharDriverState *chr)\n{\n    WinCharState *s = chr->opaque;\n    int ret, err;\n    uint8_t buf[READ_BUF_LEN];\n    DWORD size;\n\n    ZeroMemory(&s->orecv, sizeof(s->orecv));\n    s->orecv.hEvent = s->hrecv;\n    ret = ReadFile(s->hcom, buf, s->len, &size, &s->orecv);\n    if (!ret) {\n        err = GetLastError();\n        if (err == ERROR_IO_PENDING) {\n            ret = GetOverlappedResult(s->hcom, &s->orecv, &size, TRUE);\n        }\n    }\n\n    if (size > 0) {\n        qemu_chr_be_write(chr, buf, size);\n    }\n}",
        "output": "0",
        "idx": 2782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n",
        "output": "1",
        "idx": 4267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __kprobes notifier_call_chain(struct notifier_block **nl,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference(*nl);\n\twhile (nb) {\n\t\tnext_nb = rcu_dereference(nb->next);\n\t\tret = nb->notifier_call(nb, val, v);\n\t\tif ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 3082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Status check_index_ordering(const Tensor& indices) {\n    auto findices = indices.flat<int>();\n\n    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {\n      if (findices(i) < findices(i + 1)) {\n        continue;\n      }\n\n      return Status(\n          errors::InvalidArgument(\"Indices are not strictly ordered\"));\n    }\n\n    return Status::OK();\n  }",
        "output": "1",
        "idx": 5627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n\n    if (!pss)\n        return NULL;\n\n    if (pss->maskGenAlgorithm) {\n        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param->type == V_ASN1_SEQUENCE) {\n            p = param->value.sequence->data;\n            plen = param->value.sequence->length;\n            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n\n    return pss;\n}",
        "output": "1",
        "idx": 2777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\traw_spin_lock_init(&cfs_b->lock);\n\tcfs_b->runtime = 0;\n\tcfs_b->quota = RUNTIME_INF;\n\tcfs_b->period = ns_to_ktime(default_cfs_period());\n\n\tINIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);\n\thrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);\n\tcfs_b->period_timer.function = sched_cfs_period_timer;\n\thrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tcfs_b->slack_timer.function = sched_cfs_slack_timer;\n\tcfs_b->distribute_running = 0;\n}",
        "output": "0",
        "idx": 4876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void do_tw (int flags)\n\n{\n\n    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||\n\n                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||\n\n                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||\n\n                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||\n\n                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n",
        "output": "0",
        "idx": 1457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_pack_info_file(const char *infofile)\n{\n\tFILE *fp;\n\tchar line[1000];\n\tint old_cnt = 0;\n\n\tfp = fopen(infofile, \"r\");\n\tif (!fp)\n\t\treturn 1; /* nonexistent is not an error. */\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tint len = strlen(line);\n\t\tif (len && line[len-1] == '\\n')\n\t\t\tline[--len] = 0;\n\n\t\tif (!len)\n\t\t\tcontinue;\n\n\t\tswitch (line[0]) {\n\t\tcase 'P': /* P name */\n\t\t\tif (parse_pack_def(line, old_cnt++))\n\t\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tcase 'D': /* we used to emit D but that was misguided. */\n\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tcase 'T': /* we used to emit T but nobody uses it. */\n\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"unrecognized: %s\", line);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn 0;\n out_stale:\n\tfclose(fp);\n\treturn 1;\n}",
        "output": "1",
        "idx": 230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}",
        "output": "0",
        "idx": 5986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *stroke_color;\n\n  stroke_color=NewPixelWand();\n  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);\n  DrawSetStrokeColor(WmfDrawingWand,stroke_color);\n  stroke_color=DestroyPixelWand(stroke_color);\n}",
        "output": "0",
        "idx": 223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit ipv4_inetpeer_exit(struct net *net)\n{\n\tstruct inet_peer_base *bp = net->ipv4.peers;\n\n\tnet->ipv4.peers = NULL;\n\tinetpeer_invalidate_tree(bp);\n\tkfree(bp);\n}",
        "output": "0",
        "idx": 2166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            g_source_remove(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        s->polling = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (!s->connected)\n\n            qemu_chr_be_generic_open(chr);\n\n        s->connected = 1;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n\n{\n\n    int sum, i, j;\n\n    int coeffs[pred_order];\n\n\n\n    for (i=0; i<pred_order; i++)\n\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n\n\n    for (i=0; i < s->blocksize; i++) {\n\n        sum = s->lpcqoffset;\n\n        for (j=0; j<pred_order; j++)\n\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,\n    int length)\n{\n  int i;\n  int n;\n  GstRMDemuxIndex *index;\n\n  /* The number of index records */\n  n = length / 14;\n\n  if (rmdemux->index_stream == NULL)\n    return;\n\n  /* don't parse the index a second time when operating pull-based and\n   * reaching the end of the file */\n  if (rmdemux->index_stream->index_length > 0) {\n    GST_DEBUG_OBJECT (rmdemux, \"Already have an index for this stream\");\n    return;\n  }\n\n  index = g_malloc (sizeof (GstRMDemuxIndex) * n);\n  rmdemux->index_stream->index = index;\n  rmdemux->index_stream->index_length = n;\n\n  for (i = 0; i < n; i++) {\n    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;\n    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);\n\n    GST_DEBUG_OBJECT (rmdemux, \"Index found for timestamp=%f (at offset=%x)\",\n        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,\n        index[i].offset);\n    data += 14;\n  }\n}",
        "output": "0",
        "idx": 5817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssh_scp_push_file(ssh_scp scp, const char *filename, size_t size, int mode){\n\treturn ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);\n}",
        "output": "1",
        "idx": 5309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cleanup_preferred_base(void)\n{\n\tstruct pbase_tree *it;\n\tunsigned i;\n\n\tit = pbase_tree;\n\tpbase_tree = NULL;\n\twhile (it) {\n\t\tstruct pbase_tree *this = it;\n\t\tit = this->next;\n\t\tfree(this->pcache.tree_data);\n\t\tfree(this);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pbase_tree_cache); i++) {\n\t\tif (!pbase_tree_cache[i])\n\t\t\tcontinue;\n\t\tfree(pbase_tree_cache[i]->tree_data);\n\t\tFREE_AND_NULL(pbase_tree_cache[i]);\n\t}\n\n\tFREE_AND_NULL(done_pbase_paths);\n\tdone_pbase_paths_num = done_pbase_paths_alloc = 0;\n}",
        "output": "0",
        "idx": 433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n",
        "output": "0",
        "idx": 1785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MainWindow::setPreviewScale(int scale)\n{\n    LOG_DEBUG() << scale;\n    switch (scale) {\n    case 360:\n        ui->actionPreview360->setChecked(true);\n        break;\n    case 540:\n        ui->actionPreview540->setChecked(true);\n        break;\n    case 720:\n        ui->actionPreview720->setChecked(true);\n        break;\n    default:\n        ui->actionPreviewNone->setChecked(true);\n        break;\n    }\n    MLT.setPreviewScale(scale);\n    MLT.refreshConsumer();\n}",
        "output": "0",
        "idx": 4394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_rdrand_seed()\n{\n    DEBUG_SEED(\"get_rdrand_seed\");\n    int r;\n    while (_rdrand32_step(&r) == 0);\n    return r;\n}",
        "output": "0",
        "idx": 2582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n",
        "output": "0",
        "idx": 513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}",
        "output": "1",
        "idx": 5098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return kvm_irqchip_assign_irqfd(s, fd, virq, true);\n\n}\n",
        "output": "0",
        "idx": 5887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n",
        "output": "1",
        "idx": 2520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MHD_post_process (struct MHD_PostProcessor *pp,\n                  const char *post_data,\n                  size_t post_data_len)\n{\n  if (0 == post_data_len)\n    return MHD_YES;\n  if (NULL == pp)\n    return MHD_NO;\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_ (\n                                   MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))\n    return post_process_urlencoded (pp,\n                                    post_data,\n                                    post_data_len);\n  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,\n                                 pp->encoding,\n                                 MHD_STATICSTR_LEN_ (\n                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))\n    return post_process_multipart (pp,\n                                   post_data,\n                                   post_data_len);\n  /* this should never be reached */\n  return MHD_NO;\n}",
        "output": "0",
        "idx": 4588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"mov                  %0, %%\"REG_a\"         \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq  (%1, %%\"REG_a\",2), %%mm0             \\n\\t\"\n\n        \"movq 8(%1, %%\"REG_a\",2), %%mm1             \\n\\t\"\n\n        \"psrlw                $8, %%mm0             \\n\\t\"\n\n        \"psrlw                $8, %%mm1             \\n\\t\"\n\n        \"packuswb          %%mm1, %%mm0             \\n\\t\"\n\n        \"movq              %%mm0, (%2, %%\"REG_a\")   \\n\\t\"\n\n        \"add                  $8, %%\"REG_a\"         \\n\\t\"\n\n        \" js                  1b                    \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src+width*2), \"r\" (dst+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++)\n\n        dst[i]= src[2*i+1];\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 1077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPathNodeSetCreateSize(int size) {\n    xmlNodeSetPtr ret;\n\n    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));\n    if (ret == NULL) {\n        xmlXPathErrMemory(NULL, \"creating nodeset\\n\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlNodeSet));\n    if (size < XML_NODESET_DEFAULT)\n\tsize = XML_NODESET_DEFAULT;\n    ret->nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));\n    if (ret->nodeTab == NULL) {\n\txmlXPathErrMemory(NULL, \"creating nodeset\\n\");\n\txmlFree(ret);\n\treturn(NULL);\n    }\n    memset(ret->nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));\n    ret->nodeMax = size;\n    return(ret);\n}",
        "output": "0",
        "idx": 94
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}",
        "output": "0",
        "idx": 2887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BROTLI_INLINE uint32_t BrotliGetAvailableBits(\n    const BrotliBitReader* br) {\n  return (BROTLI_64_BITS ? 64 : 32) - br->bit_pos_;\n}",
        "output": "0",
        "idx": 5132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tbuffer_append_spaces(buf, level+1);\n\t\tsmart_str_append_long(buf, (zend_long) index);\n\t\tsmart_str_appendl(buf, \" => \", 4);\n\n\t} else { /* string key */\n\t\tzend_string *tmp_str;\n\t\tzend_string *ckey = php_addcslashes(key, 0, \"'\\\\\", 2);\n\t\ttmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), \"\\0\", 1, \"' . \\\"\\\\0\\\" . '\", 12);\n\n\t\tbuffer_append_spaces(buf, level + 1);\n\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tsmart_str_append(buf, tmp_str);\n\t\tsmart_str_appendl(buf, \"' => \", 5);\n\n\t\tzend_string_free(ckey);\n\t\tzend_string_free(tmp_str);\n\t}\n\tphp_var_export_ex(zv, level + 2, buf);\n\n\tsmart_str_appendc(buf, ',');\n\tsmart_str_appendc(buf, '\\n');\n}",
        "output": "0",
        "idx": 915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void tcp_mtu_check_reprobe(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tu32 interval;\n\ts32 delta;\n\n\tinterval = net->ipv4.sysctl_tcp_probe_interval;\n\tdelta = tcp_jiffies32 - icsk->icsk_mtup.probe_timestamp;\n\tif (unlikely(delta >= interval * HZ)) {\n\t\tint mss = tcp_current_mss(sk);\n\n\t\t/* Update current search range */\n\t\ticsk->icsk_mtup.probe_size = 0;\n\t\ticsk->icsk_mtup.search_high = tp->rx_opt.mss_clamp +\n\t\t\tsizeof(struct tcphdr) +\n\t\t\ticsk->icsk_af_ops->net_header_len;\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\n\t\t/* Update probe time stamp */\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t}\n}",
        "output": "0",
        "idx": 377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "intorel_shutdown(DestReceiver *self)\n{\n\tDR_intorel *myState = (DR_intorel *) self;\n\n\tFreeBulkInsertState(myState->bistate);\n\n\ttable_finish_bulk_insert(myState->rel, myState->ti_options);\n\n\t/* close rel, but keep lock until commit */\n\ttable_close(myState->rel, NoLock);\n\tmyState->rel = NULL;\n}",
        "output": "0",
        "idx": 5405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "float64 HELPER(ucf64_absd)(float64 a)\n\n{\n\n    return float64_abs(a);\n\n}\n",
        "output": "0",
        "idx": 864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "yaml_parser_scan_directive_name(yaml_parser_t *parser,\n        yaml_mark_t start_mark, yaml_char_t **name)\n{\n    yaml_string_t string = NULL_STRING;\n\n    if (!STRING_INIT(parser, string, INITIAL_STRING_SIZE)) goto error;\n\n    /* Consume the directive name. */\n\n    if (!CACHE(parser, 1)) goto error;\n\n    while (IS_ALPHA(parser->buffer))\n    {\n        if (!READ(parser, string)) goto error;\n        if (!CACHE(parser, 1)) goto error;\n    }\n\n    /* Check if the name is empty. */\n\n    if (string.start == string.pointer) {\n        yaml_parser_set_scanner_error(parser, \"while scanning a directive\",\n                start_mark, \"could not find expected directive name\");\n        goto error;\n    }\n\n    /* Check for an blank character after the name. */\n\n    if (!IS_BLANKZ(parser->buffer)) {\n        yaml_parser_set_scanner_error(parser, \"while scanning a directive\",\n                start_mark, \"found unexpected non-alphabetical character\");\n        goto error;\n    }\n\n    *name = string.start;\n\n    return 1;\n\nerror:\n    STRING_DEL(parser, string);\n    return 0;\n}",
        "output": "0",
        "idx": 408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    LibQuviContext *qc = s->priv_data;\n\n    return av_read_frame(qc->fmtctx, pkt);\n\n}\n",
        "output": "1",
        "idx": 3194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "includeFile(FileInfo *nested, CharsString *includedFile,\n\t\tCharacterClass **characterClasses,\n\t\tTranslationTableCharacterAttributes *characterClassAttribute,\n\t\tshort opcodeLengths[], TranslationTableOffset *newRuleOffset,\n\t\tTranslationTableRule **newRule, RuleName **ruleNames,\n\t\tTranslationTableHeader **table) {\n\tint k;\n\tchar includeThis[MAXSTRING];\n\tchar **tableFiles;\n\tint rv;\n\tfor (k = 0; k < includedFile->length; k++)\n\t\tincludeThis[k] = (char)includedFile->chars[k];\n\tincludeThis[k] = 0;\n\ttableFiles = _lou_resolveTable(includeThis, nested->fileName);\n\tif (tableFiles == NULL) {\n\t\terrorCount++;\n\t\treturn 0;\n\t}\n\tif (tableFiles[1] != NULL) {\n\t\terrorCount++;\n\t\tfree_tablefiles(tableFiles);\n\t\t_lou_logMessage(LOG_ERROR,\n\t\t\t\t\"Table list not supported in include statement: 'include %s'\",\n\t\t\t\tincludeThis);\n\t\treturn 0;\n\t}\n\trv = compileFile(*tableFiles, characterClasses, characterClassAttribute,\n\t\t\topcodeLengths, newRuleOffset, newRule, ruleNames, table);\n\tfree_tablefiles(tableFiles);\n\treturn rv;\n}",
        "output": "1",
        "idx": 1270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,\n\t\t\t     struct sk_buff *skb)\n{\n\tif (!ieee80211_is_mgmt(fc))\n\t\treturn 0;\n\n\tif (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))\n\t\treturn 0;\n\n\tif (!ieee80211_is_robust_mgmt_frame(skb))\n\t\treturn 0;\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 2097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 5635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n",
        "output": "1",
        "idx": 128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int binder_transactions_show(struct seq_file *m, void *unused)\n{\n\tstruct binder_proc *proc;\n\n\tseq_puts(m, \"binder transactions:\\n\");\n\tmutex_lock(&binder_procs_lock);\n\thlist_for_each_entry(proc, &binder_procs, proc_node)\n\t\tprint_binder_proc(m, proc, 0);\n\tmutex_unlock(&binder_procs_lock);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n\n                           int *x1, int *y1, int *x2, int *y2)\n\n{\n\n    int i, hs, ms, ss, he, me, se;\n\n\n\n    for (i=0; i<2; i++) {\n\n        /* try to read timestamps in either the first or second line */\n\n        int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n\n                       \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n\n                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,\n\n                       x1, x2, y1, y2);\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n        if (c >= 8) {\n\n            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n\n            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;\n\n            return buf;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n",
        "output": "1",
        "idx": 1796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LJ_NOINLINE void lj_err_run(lua_State *L)\n{\n  ptrdiff_t ef = finderrfunc(L);\n  if (ef) {\n    TValue *errfunc = restorestack(L, ef);\n    TValue *top = L->top;\n    lj_trace_abort(G(L));\n    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {\n      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));\n      lj_err_throw(L, LUA_ERRERR);\n    }\n    L->status = LUA_ERRERR;\n    copyTV(L, top, top-1);\n    copyTV(L, top-1, errfunc);\n    L->top = top+1;\n    lj_vm_call(L, top, 1+1);  /* Stack: |errfunc|msg| -> |msg| */\n  }\n  lj_err_throw(L, LUA_ERRRUN);\n}",
        "output": "1",
        "idx": 3944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(ldap_dn2ufn)\n{\n\tchar *dn, *ufn;\n\tint dn_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &dn, &dn_len) != SUCCESS) {\n\t\treturn;\n\t}\n\n\tufn = ldap_dn2ufn(dn);\n\n\tif (ufn != NULL) {\n\t\tRETVAL_STRING(ufn, 1);\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\tldap_memfree(ufn);\n#endif\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "0",
        "idx": 2710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xenfb_send_motion(struct XenInput *xenfb,\n\n\t\t\t     int rel_x, int rel_y, int rel_z)\n\n{\n\n    union xenkbd_in_event event;\n\n\n\n    memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n\n    event.type = XENKBD_TYPE_MOTION;\n\n    event.motion.rel_x = rel_x;\n\n    event.motion.rel_y = rel_y;\n\n#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207\n\n    event.motion.rel_z = rel_z;\n\n#endif\n\n\n\n    return xenfb_kbd_event(xenfb, &event);\n\n}\n",
        "output": "0",
        "idx": 3977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init init_script_binfmt(void)\n{\n\tregister_binfmt(&script_format);\n\treturn 0;\n}",
        "output": "0",
        "idx": 6228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int emulated_exitfn(CCIDCardState *base)\n\n{\n\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n\n\n\n    vevent_queue_vevent(vevent); /* stop vevent thread */\n\n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n\n    card->quit_apdu_thread = 1; /* stop handle_apdu thread */\n\n    qemu_cond_signal(&card->handle_apdu_cond);\n\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n\n                      &card->apdu_thread_quit_mutex);\n\n    /* handle_apdu thread stopped, can destroy all of it's mutexes */\n\n    qemu_cond_destroy(&card->handle_apdu_cond);\n\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n\n    qemu_mutex_destroy(&card->vreader_mutex);\n\n    qemu_mutex_destroy(&card->event_list_mutex);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xen_platform_initfn(PCIDevice *dev)\n{\n    PCIXenPlatformState *d = XEN_PLATFORM(dev);\n    uint8_t *pci_conf;\n    pci_conf = dev->config;\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n    pci_config_set_prog_interface(pci_conf, 0);\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n    platform_ioport_bar_setup(d);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);\n    /* reserve 16MB mmio address for share memory*/\n    platform_mmio_setup(d);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &d->mmio_bar);\n    platform_fixed_ioport_init(d);\n    return 0;\n}",
        "output": "1",
        "idx": 4513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "localtime_r(const time_t *t, struct tm *tm)\n{\n    auto struct tm *tmp = localtime(t);\n    if (tmp)\n\t*tm = *tmp;\n    return tmp;\n}",
        "output": "0",
        "idx": 1819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    struct nand_state_t *s = opaque;\n\n    uint32_t r;\n\n    int rdy;\n\n\n\n    r = nand_getio(s->nand);\n\n    nand_getpins(s->nand, &rdy);\n\n    s->rdy = rdy;\n\n\n\n    DNAND(printf(\"%s addr=%x r=%x\\n\", __func__, addr, r));\n\n    return r;\n\n}\n",
        "output": "0",
        "idx": 3691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)\n{\n    virtio_scsi_common_unrealize(dev, errp);\n}",
        "output": "1",
        "idx": 4327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)\n{\n\tu8 rc = 0;\n\n\tif (!BP_NOMCP(bp)) {\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\trc = bnx2x_test_link(&bp->link_params, &bp->link_vars,\n\t\t\t\t     is_serdes);\n\t\tbnx2x_release_phy_lock(bp);\n\t} else\n\t\tBNX2X_ERR(\"Bootcode is missing - can not test link\\n\");\n\n\treturn rc;\n}",
        "output": "0",
        "idx": 1127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)\n{\n\tchar *v = NULL, *f = NULL, *u = NULL;\n\tint rc;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\n\trc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!rc && v)\n\t\trc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);\n\tif (!rc && f)\n\t\trc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);\n\tif (!rc && u)\n\t\trc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);\n\tif (!rc)\n\t\trc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);\n\n\tfree(v);\n\tfree(f);\n\tfree(u);\n\n\treturn rc;\n}",
        "output": "0",
        "idx": 4065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bio_dirty_fn(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct bio *bio;\n\n\tspin_lock_irqsave(&bio_dirty_lock, flags);\n\tbio = bio_dirty_list;\n\tbio_dirty_list = NULL;\n\tspin_unlock_irqrestore(&bio_dirty_lock, flags);\n\n\twhile (bio) {\n\t\tstruct bio *next = bio->bi_private;\n\n\t\tbio_set_pages_dirty(bio);\n\t\tbio_release_pages(bio);\n\t\tbio_put(bio);\n\t\tbio = next;\n\t}\n}",
        "output": "0",
        "idx": 237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void atomic2gen (lua_State *L, global_State *g) {\n  /* sweep all elements making them old */\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old = g->survival = g->allgc;\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  /* base for memory control */\n  finishgencycle(L, g);\n}",
        "output": "1",
        "idx": 1454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}",
        "output": "1",
        "idx": 1833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,\n\n                              TCGReg r1, TCGReg r2, TCGReg rn,\n\n                              tcg_target_long ofs, bool pre, bool w)\n\n{\n\n    insn |= 1u << 31; /* ext */\n\n    insn |= pre << 24;\n\n    insn |= w << 23;\n\n\n\n    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);\n\n    insn |= (ofs & (0x7f << 3)) << (15 - 3);\n\n\n\n    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);\n\n}\n",
        "output": "0",
        "idx": 5959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_matrix_create(x->numrows_, x->numcols_);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}",
        "output": "1",
        "idx": 5446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CharDriverState *qmp_chardev_open_serial(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    ChardevHostdev *serial = backend->serial;\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n}\n",
        "output": "0",
        "idx": 4174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n",
        "output": "1",
        "idx": 6206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    /* TODO: low address protection once we flush the tlb on cr changes */\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    /* TODO: storage key handling */\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n",
        "output": "1",
        "idx": 3123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }",
        "output": "1",
        "idx": 3241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)\n\n{\n\n    char buffer[32];\n\n    if (time) {\n\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));\n\n        av_metadata_set2(metadata, \"creation_time\", buffer, 0);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 6110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\treturn e;\n}",
        "output": "1",
        "idx": 6019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ldb_msg_append_value(struct ldb_message *msg,\n\t\t\t const char *attr_name,\n\t\t\t const struct ldb_val *val,\n\t\t\t int flags)\n{\n\treturn ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);\n}",
        "output": "0",
        "idx": 2042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {\n    /* prepare websocket frames to backend */\n    /* (caller should verify r->reqbody_queue) */\n    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/\n    handler_ctx *hctx = (handler_ctx *)gwhctx;\n    if (0 == mod_wstunnel_frame_recv(hctx))\n        return HANDLER_GO_ON;\n    else {\n        /*(error)*/\n        /* future: might differentiate client close request from client error,\n         *         and then send 1000 or 1001 */\n        request_st * const r = hctx->gw.r;\n        DEBUG_LOG_INFO(\"disconnected from client (fd=%d)\", r->con->fd);\n        DEBUG_LOG_DEBUG(\"send close response to client (fd=%d)\", r->con->fd);\n        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(\"1000\")); /* 1000 Normal Closure */\n        gw_handle_request_reset(r, hctx->gw.plugin_data);\n        return HANDLER_FINISHED;\n    }\n}",
        "output": "0",
        "idx": 5534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int send_solid_rect(VncState *vs)\n{\n    size_t bytes;\n\n    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */\n\n    if (vs->tight.pixel24) {\n        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);\n        bytes = 3;\n    } else {\n        bytes = vs->clientds.pf.bytes_per_pixel;\n    }\n\n    vnc_write(vs, vs->tight.tight.buffer, bytes);\n    return 1;\n}",
        "output": "1",
        "idx": 5621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)\n{\n\t/* Pending single-step? */\n\tif (thread_info_flags & _TIF_SINGLESTEP) {\n#ifndef CONFIG_MN10300_USING_JTAG\n\t\tregs->epsw |= EPSW_T;\n\t\tclear_thread_flag(TIF_SINGLESTEP);\n#else\n\t\tBUG(); /* no h/w single-step if using JTAG unit */\n#endif\n\t}\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(__frame);\n\t}\n}",
        "output": "1",
        "idx": 4535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)\n{\n    shaper->base_direction = dir;\n}",
        "output": "0",
        "idx": 4527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int32 MkvWriter::Position(int64 position) {\n  if (!file_)\n    return -1;\n\n#ifdef _MSC_VER\n  return _fseeki64(file_, position, SEEK_SET);\n#else\n  return fseeko(file_, static_cast<off_t>(position), SEEK_SET);\n#endif\n}",
        "output": "1",
        "idx": 4047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n\n                   int w, int h, enum PixelFormat pix_fmt, int align)\n\n{\n\n    int i, ret;\n\n    uint8_t *buf;\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        linesizes[i] = FFALIGN(linesizes[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n\n        return ret;\n\n    buf = av_malloc(ret + align);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n\n        av_free(buf);\n\n        return ret;\n\n    }\n\n    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)\n\n        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n\n\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 83
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\t/* Make sure the string is properly terminated. */\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\n\treturn ;\n} /* psf_asciiheader_printf */",
        "output": "1",
        "idx": 1081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)\n{\n    InputStream *ist = s->opaque;\n    FrameBuffer *buf;\n    int ret, i;\n    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)\n        return ret;\n    buf              = ist->buffer_pool;\n    ist->buffer_pool = buf->next;\n    buf->next        = NULL;\n    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {\n        av_freep(&buf->base[0]);\n        av_free(buf);\n        ist->dr1 = 0;\n        if ((ret = alloc_buffer(s, ist, &buf)) < 0)\n            return ret;\n    }\n    buf->refcount++;\n    frame->opaque        = buf;\n    frame->type          = FF_BUFFER_TYPE_USER;\n    frame->extended_data = frame->data;\n    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;\n    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {\n        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't\n        frame->data[i]     = buf->data[i];\n        frame->linesize[i] = buf->linesize[i];\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SSL_set_accept_state(SSL *s)\n\t{\n\ts->server=1;\n\ts->shutdown=0;\n\ts->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;\n\ts->handshake_func=s->method->ssl_accept;\n\t/* clear the current cipher */\n\tssl_clear_cipher_ctx(s);\n\t}",
        "output": "0",
        "idx": 1504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 2174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)\n{\n\treturn rxq->tail == rxq->head;\n}",
        "output": "0",
        "idx": 510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n",
        "output": "0",
        "idx": 4547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Http::Context& PerListenerFactoryContextImpl::httpContext() {\n  return listener_factory_context_base_->httpContext();\n}",
        "output": "0",
        "idx": 820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_uncompress( compress_filter_context_t *zfx, z_stream *zs )\n{\n    int rc;\n\n    /****************\n     * PGP uses a windowsize of 13 bits. Using a negative value for\n     * it forces zlib not to expect a zlib header.  This is a\n     * undocumented feature Peter Gutmann told me about.\n     *    \n     * We must use 15 bits for the inflator because CryptoEx uses 15\n     * bits thus the output would get scrambled w/o error indication\n     * if we would use 13 bits.  For the uncompressing this does not\n     * matter at all.\n     */\n    if( (rc = zfx->algo == 1? inflateInit2( zs, -15)\n\t\t\t    : inflateInit( zs )) != Z_OK ) {\n\tlog_fatal(\"zlib problem: %s\\n\", zs->msg? zs->msg :\n\t\t\t       rc == Z_MEM_ERROR ? \"out of core\" :\n\t\t\t       rc == Z_VERSION_ERROR ? \"invalid lib version\" :\n\t\t\t\t\t\t       \"unknown error\" );\n    }\n\n    zfx->inbufsize = 2048;\n    zfx->inbuf = xmalloc( zfx->inbufsize );\n    zs->avail_in = 0;\n}",
        "output": "1",
        "idx": 4351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)\n{\n    banOrUnban(bufferInfo, msg, true);\n}",
        "output": "0",
        "idx": 4824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf  = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n    uint64_t size    = avio_rl64(pb);\n\n    uint16_t nb_desc = avio_rl16(pb);\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_desc; i++) {\n\n        uint16_t name_len, type, val_len;\n\n        uint8_t *name = NULL;\n\n\n\n        name_len = avio_rl16(pb);\n\n        if (!name_len)\n\n            return AVERROR_INVALIDDATA;\n\n        name = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         name_len);\n\n        type    = avio_rl16(pb);\n\n        val_len = avio_rl16(pb);\n\n\n\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)\n{\n\t/* FIXME: Need to do more checks */\n\tif (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {\n\t\tint visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\n\t\tif ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n\n    return 0;\n}",
        "output": "1",
        "idx": 841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_file_unmount_mountable_with_operation (GFile               *file,\n                                         GMountUnmountFlags   flags,\n                                         GMountOperation     *mount_operation,\n                                         GCancellable        *cancellable,\n                                         GAsyncReadyCallback  callback,\n                                         gpointer             user_data)\n{\n  GFileIface *iface;\n\n  g_return_if_fail (G_IS_FILE (file));\n\n  iface = G_FILE_GET_IFACE (file);\n\n  if (iface->unmount_mountable == NULL && iface->unmount_mountable_with_operation == NULL)\n    {\n      g_task_report_new_error (file, callback, user_data,\n                               g_file_unmount_mountable_with_operation,\n                               G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                               _(\"Operation not supported\"));\n      return;\n    }\n\n  if (iface->unmount_mountable_with_operation != NULL)\n    (* iface->unmount_mountable_with_operation) (file,\n                                                 flags,\n                                                 mount_operation,\n                                                 cancellable,\n                                                 callback,\n                                                 user_data);\n  else\n    (* iface->unmount_mountable) (file,\n                                  flags,\n                                  cancellable,\n                                  callback,\n                                  user_data);\n}",
        "output": "0",
        "idx": 1464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n",
        "output": "1",
        "idx": 1424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)\n{\n  int rc;\n  struct OutStruct *out=(struct OutStruct *)stream;\n  struct Configurable *config = out->config;\n  if(out && !out->stream) {\n    /* open file for writing */\n    out->stream=fopen(out->filename, \"wb\");\n    if(!out->stream)\n      return -1; /* failure */\n  }\n\n  if(config->recvpersecond) {\n    /*\n     * We know when we received data the previous time. We know how much data\n     * we get now. Make sure that this is not faster than we are told to run.\n     * If we're faster, sleep a while *before* doing the fwrite() here.\n     */\n\n    time_t timediff;\n    time_t now;\n\n    now = time(NULL);\n    timediff = now - config->lastrecvtime;\n    if( size*nmemb > config->recvpersecond*timediff) {\n      /* figure out how many milliseconds to rest */\n      go_sleep ( (size*nmemb)*1000/config->recvpersecond - timediff*1000 );\n      now = time(NULL);\n    }\n    config->lastrecvtime = now;\n  }\n\n  rc = fwrite(buffer, size, nmemb, out->stream);\n  \n  if(config->nobuffer)\n    /* disable output buffering */\n    fflush(out->stream);\n  \n  return rc;\n}",
        "output": "0",
        "idx": 5980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vda_h264_end_frame(AVCodecContext *avctx)\n{\n    H264Context *h                      = avctx->priv_data;\n    struct vda_context *vda_ctx         = avctx->hwaccel_context;\n    AVFrame *frame                      = &h->cur_pic_ptr->f;\n    struct vda_buffer *context;\n    AVBufferRef *buffer;\n    int status;\n    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)\n    status = vda_sync_decode(vda_ctx);\n    frame->data[3] = (void*)vda_ctx->cv_buffer;\n    if (status)\n        av_log(avctx, AV_LOG_ERROR, \"Failed to decode frame (%d)\\n\", status);",
        "output": "1",
        "idx": 464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int dvdsub_close(AVCodecContext *avctx)\n\n{\n\n    DVDSubContext *ctx = avctx->priv_data;\n\n    av_freep(&ctx->buf);\n\n    ctx->buf_size = 0;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AnyP::Uri::path() const\n{\n    // RFC 3986 section 3.3 says path can be empty (path-abempty).\n    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to \"/\"\n    // at least when sending and using. We must still accept path-abempty as input.\n    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))\n        return SlashPath();\n\n    return path_;\n}",
        "output": "0",
        "idx": 2352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}",
        "output": "1",
        "idx": 4189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { // optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base  = dy / adx;\n\n        int x     = x0;\n\n        uint8_t y = y0;\n\n        int err   = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool virtio_ipl_disk_is_valid(void)\n\n{\n\n    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());\n\n}\n",
        "output": "0",
        "idx": 3725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n",
        "output": "1",
        "idx": 5572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_chr_update_read_handler(CharDriverState *chr,\n                                        GMainContext *context,\n                                        int tag)\n{\n    TCPCharDriver *s = chr->opaque;\n\n    if (!s->connected) {\n        return;\n    }\n\n    remove_fd_in_watch(chr);\n    if (s->ioc) {\n        chr->fd_in_tag = io_add_watch_poll(s->ioc,\n                                           tcp_chr_read_poll,\n                                           tcp_chr_read, chr,\n                                           context);\n    }\n}",
        "output": "1",
        "idx": 172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return &pair->list;\n}",
        "output": "1",
        "idx": 821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],\n\n                                   int order, int qlevel, int len, int bps)\n\n{\n\n    int i, j;\n\n    int ebps = 1 << (bps-1);\n\n    unsigned sigma = 0;\n\n\n\n    for (i = order; i < len; i++)\n\n        sigma |= decoded[i] + ebps;\n\n\n\n    if (sigma < 2*ebps)\n\n        return;\n\n\n\n    for (i = len - 1; i >= order; i--) {\n\n        int64_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (int64_t)decoded[i-order+j];\n\n        decoded[i] -= p >> qlevel;\n\n    }\n\n    for (i = order; i < len; i++, decoded++) {\n\n        int32_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (uint32_t)decoded[j];\n\n        decoded[j] += p >> qlevel;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n",
        "output": "1",
        "idx": 213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NumberFormatTest::verifyFieldPositionIterator(\n        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {\n    int32_t idx = 0;\n    FieldPosition fp;\n    while (iter.next(fp)) {\n        if (expected[idx].spos == -1) {\n            errln(\"Iterator should have ended. got %d\", fp.getField());\n            return;\n        }\n        assertEquals(\"id\", expected[idx].id, fp.getField());\n        assertEquals(\"start\", expected[idx].spos, fp.getBeginIndex());\n        assertEquals(\"end\", expected[idx].epos, fp.getEndIndex());\n        ++idx;\n    }\n    if (expected[idx].spos != -1) {\n        errln(\"Premature end of iterator. expected %d\", expected[idx].id);\n    }\n}",
        "output": "0",
        "idx": 4595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)\n{\n\tVFS_FIND(chdir);\n\treturn handle->fns->chdir_fn(handle, path);\n}",
        "output": "0",
        "idx": 2681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)\n{\n        opj_tcp_t * l_tcp = 00;\n        OPJ_UINT32 l_nb_tiles = 0;\n        OPJ_UINT32 l_max_poc = 0;\n        OPJ_UINT32 i;\n\n        l_tcp = p_j2k->m_cp.tcps;\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);\n                ++l_tcp;\n        }\n\n        ++l_max_poc;\n\n        return 4 + 9 * l_max_poc;\n}",
        "output": "0",
        "idx": 4308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ptrace_notify(int exit_code)\n{\n\tsiginfo_t info;\n\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\n\tmemset(&info, 0, sizeof info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\t/* Let the debugger run.  */\n\tspin_lock_irq(&current->sighand->siglock);\n\tptrace_stop(exit_code, 1, &info);\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
        "output": "0",
        "idx": 972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ext2_xattr(void)\n{\n\treturn 0;\n}",
        "output": "1",
        "idx": 4643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlBufAddLen(xmlBufPtr buf, size_t len) {\n    if ((buf == NULL) || (buf->error))\n        return(-1);\n    CHECK_COMPAT(buf)\n    if (len > (buf->size - buf->use))\n        return(-1);\n    buf->use += len;\n    UPDATE_COMPAT(buf)\n    if (buf->size > buf->use)\n        buf->content[buf->use] = 0;\n    else\n        return(-1);\n    return(0);\n}",
        "output": "0",
        "idx": 6229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Supports_Condition_Obj Parser::parse_supports_operator()\n  {\n    Supports_Condition_Obj cond = parse_supports_condition_in_parens();\n    if (cond.isNull()) return {};\n\n    while (true) {\n      Supports_Operator::Operand op = Supports_Operator::OR;\n      if (lex < kwd_and >()) { op = Supports_Operator::AND; }\n      else if(!lex < kwd_or >()) { break; }\n\n      lex < css_whitespace >();\n      Supports_Condition_Obj right = parse_supports_condition_in_parens();\n\n      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));\n      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);\n    }\n    return cond;\n  }",
        "output": "0",
        "idx": 4110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case 128:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 5065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n",
        "output": "0",
        "idx": 5203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n",
        "output": "1",
        "idx": 1466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hugetlb_get_unmapped_area(struct file *file, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct hstate *h = hstate_file(file);\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long task_size = TASK_SIZE;\n\n\tif (test_thread_flag(TIF_32BIT))\n\t\ttask_size = STACK_TOP32;\n\n\tif (len & ~huge_page_mask(h))\n\t\treturn -EINVAL;\n\tif (len > task_size)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED) {\n\t\tif (prepare_hugepage_range(file, addr, len))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (addr) {\n\t\taddr = ALIGN(addr, huge_page_size(h));\n\t\tvma = find_vma(mm, addr);\n\t\tif (task_size - len >= addr &&\n\t\t    (!vma || addr + len <= vma->vm_start))\n\t\t\treturn addr;\n\t}\n\tif (mm->get_unmapped_area == arch_get_unmapped_area)\n\t\treturn hugetlb_get_unmapped_area_bottomup(file, addr, len,\n\t\t\t\tpgoff, flags);\n\telse\n\t\treturn hugetlb_get_unmapped_area_topdown(file, addr, len,\n\t\t\t\tpgoff, flags);\n}",
        "output": "1",
        "idx": 1148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n",
        "output": "1",
        "idx": 4835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n",
        "output": "0",
        "idx": 3055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void shmem_dir_free(struct page *page)\n{\n\t__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);\n}",
        "output": "0",
        "idx": 705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_h264_init_dequant_tables(H264Context *h)\n\n{\n\n    int i, x;\n\n    init_dequant4_coeff_table(h);\n\n    if (h->pps.transform_8x8_mode)\n\n        init_dequant8_coeff_table(h);\n\n    if (h->sps.transform_bypass) {\n\n        for (i = 0; i < 6; i++)\n\n            for (x = 0; x < 16; x++)\n\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n\n        if (h->pps.transform_8x8_mode)\n\n            for (i = 0; i < 6; i++)\n\n                for (x = 0; x < 64; x++)\n\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rand_fork(void)\n{\n    rand_fork_count++;\n}",
        "output": "1",
        "idx": 5359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int count(struct cstate *g, Renode *node)\n{\n\tint min, max, n;\n\tif (!node) return 0;\n\tswitch (node->type) {\n\tdefault: return 1;\n\tcase P_CAT: return count(g, node->x) + count(g, node->y);\n\tcase P_ALT: return count(g, node->x) + count(g, node->y) + 2;\n\tcase P_REP:\n\t\tmin = node->m;\n\t\tmax = node->n;\n\t\tif (min == max) n = count(g, node->x) * min;\n\t\telse if (max < REPINF) n = count(g, node->x) * max + (max - min);\n\t\telse n = count(g, node->x) * (min + 1) + 2;\n\t\tif (n < 0 || n > REG_MAXPROG) die(g, \"program too large\");\n\t\treturn n;\n\tcase P_PAR: return count(g, node->x) + 2;\n\tcase P_PLA: return count(g, node->x) + 2;\n\tcase P_NLA: return count(g, node->x) + 2;\n\t}\n}",
        "output": "1",
        "idx": 5883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n",
        "output": "0",
        "idx": 4436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)\n{\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast16_t rlvlno;\n\n\tif (tcmpt->rlvls) {\n\t\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl_destroy(rlvl);\n\t\t}\n\t\tjas_free(tcmpt->rlvls);\n\t}\n\n\tif (tcmpt->data) {\n\t\tjas_seq2d_destroy(tcmpt->data);\n\t}\n\tif (tcmpt->tsfb) {\n\t\tjpc_tsfb_destroy(tcmpt->tsfb);\n\t}\n}",
        "output": "1",
        "idx": 5117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n",
        "output": "0",
        "idx": 2046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void restore_stack_limit (lua_State *L) {\n  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1);\n  if (L->size_ci > LUAI_MAXCALLS) {  /* there was an overflow? */\n    int inuse = cast_int(L->ci - L->base_ci);\n    if (inuse + 1 < LUAI_MAXCALLS)  /* can `undo' overflow? */\n      luaD_reallocCI(L, LUAI_MAXCALLS);\n  }\n}",
        "output": "0",
        "idx": 2716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n\n                         AVFilterBufferRef *picref, int flags)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!picref) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n        ret = check_format_change(buffer_filter, picref);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)\n\n        buf = picref;\n\n    else\n\n        buf = copy_buffer_ref(buffer_filter, picref);\n\n\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        if (buf != picref)\n\n            avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n    c->nb_failed_requests = 0;\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 6303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Suffix(myword, suffix)\n    char *myword;\n    char *suffix;\n{\n    register int i;\n    register int j;\n    i = strlen(myword);\n    j = strlen(suffix);\n\n    if (i > j)\n    {\n\treturn (STRCMP((myword + i - j), suffix));\n    } else\n    {\n\treturn (-1);\n    }\n}",
        "output": "0",
        "idx": 203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool val_native(THD *thd, Native *to)\n  {\n    return has_value() ? Time(thd, this).to_native(to, decimals) : true;\n  }",
        "output": "0",
        "idx": 2024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  CharPtr grow_buffer(std::size_t n) {\n    std::size_t size = buffer_.size();\n    buffer_.resize(size + n);\n    return internal::make_ptr(&buffer_[size], n);\n  }",
        "output": "0",
        "idx": 5782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ts_format(netdissect_options *ndo\n#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION\n_U_\n#endif\n, int sec, int usec, char *buf)\n{\n\tconst char *format;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tswitch (ndo->ndo_tstamp_precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tformat = \"%02d:%02d:%02d.%06u\";\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tformat = \"%02d:%02d:%02d.%09u\";\n\t\tbreak;\n\n\tdefault:\n\t\tformat = \"%02d:%02d:%02d.{unknown}\";\n\t\tbreak;\n\t}\n#else\n\tformat = \"%02d:%02d:%02d.%06u\";\n#endif\n\n\tsnprintf(buf, TS_BUF_SIZE, format,\n                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);\n\n        return buf;\n}",
        "output": "0",
        "idx": 5543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */\n{\n\tzend_trait_alias *alias, **alias_ptr;\n\n\tif ((alias_ptr = ce->trait_aliases)) {\n\t\talias = *alias_ptr;\n\t\twhile (alias) {\n\t\t\tif (alias->alias_len == len &&\n\t\t\t\t!strncasecmp(name, alias->alias, alias->alias_len)) {\n\t\t\t\treturn alias->alias;\n\t\t\t}\n\t\t\talias_ptr++;\n\t\t\talias = *alias_ptr;\n\t\t}\n\t}\n\n\treturn name;\n}",
        "output": "0",
        "idx": 4877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "*/\nstatic void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n\n  mysql->stmts= pruned_list;",
        "output": "1",
        "idx": 1258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);\n\n\n\n    /* USB misc control 1/2 */\n\n    pci_set_long(pci_conf + 0x40,0x00001000);\n\n    /* PM capability */\n\n    pci_set_long(pci_conf + 0x80,0x00020001);\n\n    /* USB legacy support  */\n\n    pci_set_long(pci_conf + 0xc0,0x00002000);\n\n\n\n    return usb_uhci_common_initfn(s);\n\n}\n",
        "output": "0",
        "idx": 2590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n",
        "output": "1",
        "idx": 2960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n",
        "output": "1",
        "idx": 493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_5(SANMVideoContext *ctx)\n\n{\n\n#if HAVE_BIGENDIAN\n\n    uint16_t *frm;\n\n    int npixels;\n\n#endif\n\n    uint8_t *dst = (uint8_t*)ctx->frm0;\n\n\n\n    if (rle_decode(ctx, dst, ctx->buf_size))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n#if HAVE_BIGENDIAN\n\n    npixels = ctx->npixels;\n\n    frm = ctx->frm0;\n\n    while (npixels--)\n\n        *frm++ = av_bswap16(*frm);\n\n#endif\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qapi_dealloc_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    void **obj = qapi_dealloc_pop(qov);\n\n    if (obj) {\n\n        g_free(*obj);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static php_cli_server_chunk *php_cli_server_chunk_immortal_new(const char *buf, size_t len) /* {{{ */\n{\n\tphp_cli_server_chunk *chunk = pemalloc(sizeof(php_cli_server_chunk), 1);\n\tif (!chunk) {\n\t\treturn NULL;\n\t}\n\n\tchunk->type = PHP_CLI_SERVER_CHUNK_IMMORTAL;\n\tchunk->next = NULL;\n\tchunk->data.immortal.p = buf;\n\tchunk->data.immortal.len = len;\n\treturn chunk;\n} /* }}} */",
        "output": "0",
        "idx": 4770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)\n\n{\n\n    // attempt to keep aspect during typical resolution switches\n\n    if (!sar.num)\n\n        sar = (AVRational){1, 1};\n\n\n\n    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});\n\n    return sar;\n\n}\n",
        "output": "1",
        "idx": 2261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n",
        "output": "0",
        "idx": 3569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "valid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}",
        "output": "0",
        "idx": 4498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xan_huffman_decode(unsigned char *dest, unsigned char *src)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    int counter = 0;\n\n\n\n    unsigned char bits = *ptr++;\n\n\n\n    while ( val != 0x16 ) {\n\n        if ( (1 << counter) & bits )\n\n            val = src[byte + val - 0x17];\n\n        else\n\n            val = src[val - 0x17];\n\n\n\n        if ( val < 0x16 ) {\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n\n\n        if (counter++ == 7) {\n\n            counter = 0;\n\n            bits = *ptr++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 3873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void fix_from_value(Derivation dv, const Metadata metadata)\n  {\n    fix_charset_and_length(str_value.charset(), dv, metadata);\n  }",
        "output": "0",
        "idx": 1137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crypt_reencrypt_info LUKS2_reencrypt_get_params(struct luks2_hdr *hdr,\n\tstruct crypt_params_reencrypt *params)\n{\n\tcrypt_reencrypt_info ri;\n\n\tri = LUKS2_reencrypt_status(hdr);\n\tif (ri == CRYPT_REENCRYPT_NONE || ri == CRYPT_REENCRYPT_INVALID || !params)\n\t\treturn ri;\n\n\tparams->mode = reencrypt_mode(hdr);\n\tparams->direction = reencrypt_direction(hdr);\n\tparams->resilience = reencrypt_resilience_type(hdr);\n\tparams->hash = reencrypt_resilience_hash(hdr);\n\tparams->data_shift = reencrypt_data_shift(hdr) >> SECTOR_SHIFT;\n\tparams->max_hotzone_size = 0;\n\tif (LUKS2_get_segment_id_by_flag(hdr, \"backup-moved-segment\") >= 0)\n\t\tparams->flags |= CRYPT_REENCRYPT_MOVE_FIRST_SEGMENT;\n\n\treturn ri;\n}",
        "output": "0",
        "idx": 2689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int orinoco_ioctl_getsens(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *srq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tu16 val;\n\tint err;\n\tunsigned long flags;\n\n\tif (!priv->has_sensitivity)\n\t\treturn -EOPNOTSUPP;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFSYSTEMSCALE, &val);\n\torinoco_unlock(priv, &flags);\n\n\tif (err)\n\t\treturn err;\n\n\tsrq->value = val;\n\tsrq->fixed = 0; /* auto */\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {\n    FontView *fv = (FontView *) GDrawGetUserData(gw);\n    int i, gid, doit;\n    EncMap *map = fv->b.map;\n    SplineFont *sf = fv->b.sf;\n    int merge = SelMergeType(e);\n    int layer = fv->b.active_layer;\n\n    for ( i=0; i< map->enccount; ++i ) {\n\tdoit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&\n\t\tsf->glyphs[gid]->layers[layer].refs==NULL &&\n\t\tsf->glyphs[gid]->layers[layer].splines!=NULL );\n\tfv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];\n    }\n    GDrawRequestExpose(fv->v,NULL,false);\n}",
        "output": "0",
        "idx": 1846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pattern_get_fallback (gpointer data)\n{\n    RsvgPattern *pattern = data;\n\n    return pattern->fallback;\n}",
        "output": "1",
        "idx": 5252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ & /*reqMessage*/,\n                                       DcmDataset * /*reqDataset*/)\n{\n  // we default to success\n  return STATUS_Success;\n}",
        "output": "0",
        "idx": 2946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;",
        "output": "1",
        "idx": 4375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n",
        "output": "0",
        "idx": 137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval = -1;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        goto out;\n\n    }\n\n    idx = (addr >> 6) & 0x3;\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        retval = opp->tifr;\n\n        goto out;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        retval = opp->timers[idx].ticc;\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        retval = opp->timers[idx].tibc;\n\n        break;\n\n    case 0x20: /* TIPV (TIPV) */\n\n        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    case 0x30: /* TIDE (TIDR) */\n\n        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    }\n\n\n\nout:\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n",
        "output": "1",
        "idx": 3242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ZRLE_ENCODE (int x, int y, int w, int h,\n\t\t  zrleOutStream* os, void* buf\n                  EXTRA_ARGS\n                  )\n{\n  int ty;\n  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {\n    int tx, th = rfbZRLETileHeight;\n    if (th > y+h-ty) th = y+h-ty;\n    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {\n      int tw = rfbZRLETileWidth;\n      if (tw > x+w-tx) tw = x+w-tx;\n\n      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);\n\n      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,\n\t\t      cl->zywrleLevel, cl->zywrleBuf);\n    }\n  }\n  zrleOutStreamFlush(os);\n}",
        "output": "1",
        "idx": 1450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 2562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,\n\t\tu16 portstatus)\n{\n\tu16 link_state;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn false;\n\n\tif (test_bit(port1, hub->warm_reset_bits))\n\t\treturn true;\n\n\tlink_state = portstatus & USB_PORT_STAT_LINK_STATE;\n\treturn link_state == USB_SS_PORT_LS_SS_INACTIVE\n\t\t|| link_state == USB_SS_PORT_LS_COMP_MOD;\n}",
        "output": "0",
        "idx": 735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(HeaderMapImplTest, InlineInsert) {\n  HeaderMapImpl headers;\n  EXPECT_TRUE(headers.empty());\n  EXPECT_EQ(0, headers.size());\n  EXPECT_EQ(nullptr, headers.Host());\n  headers.insertHost().value(std::string(\"hello\"));\n  EXPECT_FALSE(headers.empty());\n  EXPECT_EQ(1, headers.size());\n  EXPECT_EQ(\":authority\", headers.Host()->key().getStringView());\n  EXPECT_EQ(\"hello\", headers.Host()->value().getStringView());\n  EXPECT_EQ(\"hello\", headers.get(Headers::get().Host)->value().getStringView());\n}",
        "output": "1",
        "idx": 1298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned get_mmio_spte_access(u64 spte)\n{\n\treturn spte & shadow_mmio_access_mask;\n}",
        "output": "0",
        "idx": 115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n",
        "output": "0",
        "idx": 5224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_chr_free_common(CharDriverState *chr)\n{\n    g_free(chr->filename);\n    g_free(chr->label);\n    if (chr->logfd != -1) {\n        close(chr->logfd);\n    }\n    qemu_mutex_destroy(&chr->chr_write_lock);\n    g_free(chr);\n}",
        "output": "1",
        "idx": 4551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint32_t str_j = 0;\n    uint32_t index1;\n\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_ARRAY;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, val);\n    }\n\n    return node;\n}",
        "output": "1",
        "idx": 4306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 5035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = curbuf;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tbuf = get_buf_arg(&argvars[0]);\n\tif (buf == NULL)\n\t    return;\n    }\n    invoke_listeners(buf);\n}",
        "output": "0",
        "idx": 3111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t pause_once_data_source_read_callback(\n    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,\n    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {\n  my_user_data *ud = user_data;\n  if (ud->data_source_read_cb_paused == 0) {\n    ++ud->data_source_read_cb_paused;\n    return NGHTTP2_ERR_PAUSE;\n  }\n\n  return fixed_length_data_source_read_callback(session, stream_id, buf, len,\n                                                data_flags, source, user_data);\n}",
        "output": "0",
        "idx": 1958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_string_opt(const char *s, unsigned len, const char *opt,\n\t\t\t  char **val)\n{\n\tint i;\n\tunsigned opt_len = strlen(opt);\n\tchar *d;\n\n\tif (*val)\n\t\tfree(*val);\n\t*val = (char *) malloc(len - opt_len + 1);\n\tif (!*val) {\n\t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n\t\treturn 0;\n\t}\n\n\td = *val;\n\ts += opt_len;\n\tlen -= opt_len;\n\tfor (i = 0; i < len; i++) {\n\t\tif (s[i] == '\\\\' && i + 1 < len)\n\t\t\ti++;\n\t\t*d++ = s[i];\n\t}\n\t*d = '\\0';\n\treturn 1;\n}",
        "output": "0",
        "idx": 1406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)\n{\n    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);\n\n    sdc->init = pxa2xx_ssp_init;\n}",
        "output": "0",
        "idx": 758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n",
        "output": "0",
        "idx": 1200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebContents::CanOverscrollContent() {\n  return false;\n}",
        "output": "0",
        "idx": 1530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\nout:\n\treturn ret;\n}",
        "output": "1",
        "idx": 3815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}",
        "output": "1",
        "idx": 5977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_socket_client_connect_async (GSocketClient       *client,\n\t\t\t       GSocketConnectable  *connectable,\n\t\t\t       GCancellable        *cancellable,\n\t\t\t       GAsyncReadyCallback  callback,\n\t\t\t       gpointer             user_data)\n{\n  GSocketClientAsyncConnectData *data;\n\n  g_return_if_fail (G_IS_SOCKET_CLIENT (client));\n\n  data = g_slice_new0 (GSocketClientAsyncConnectData);\n  data->client = client;\n  data->connectable = g_object_ref (connectable);\n\n  if (can_use_proxy (client))\n    {\n      data->enumerator = g_socket_connectable_proxy_enumerate (connectable);\n      if (client->priv->proxy_resolver &&\n          G_IS_PROXY_ADDRESS_ENUMERATOR (data->enumerator))\n        {\n          g_object_set (G_OBJECT (data->enumerator),\n                        \"proxy-resolver\", client->priv->proxy_resolver,\n                        NULL);\n        }\n    }\n  else\n    data->enumerator = g_socket_connectable_enumerate (connectable);\n\n  data->task = g_task_new (client, cancellable, callback, user_data);\n  g_task_set_source_tag (data->task, g_socket_client_connect_async);\n  g_task_set_task_data (data->task, data, (GDestroyNotify)g_socket_client_async_connect_data_free);\n\n  enumerator_next_async (data);\n}",
        "output": "1",
        "idx": 2006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Field_decimal::store(longlong nr, bool unsigned_val)\n{\n  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;\n  char buff[22];\n  uint length, int_part;\n  char fyllchar;\n  uchar *to;\n\n  if (nr < 0 && unsigned_flag && !unsigned_val)\n  {\n    overflow(1);\n    return 1;\n  }\n  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);\n  int_part= field_length- (dec  ? dec+1 : 0);\n\n  if (length > int_part)\n  {\n    overflow(!unsigned_val && nr < 0L);\t\t/* purecov: inspected */\n    return 1;\n  }\n\n  fyllchar = zerofill ? (char) '0' : (char) ' ';\n  to= ptr;\n  for (uint i=int_part-length ; i-- > 0 ;)\n    *to++ = fyllchar;\n  memcpy(to,buff,length);\n  if (dec)\n  {\n    to[length]='.';\n    bfill(to+length+1,dec,'0');\n  }\n  return 0;\n}",
        "output": "0",
        "idx": 4715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n\n{\n\n    read_local_name_rp params;\n\n    params.status = HCI_SUCCESS;\n\n    memset(params.name, 0, sizeof(params.name));\n\n    if (hci->device.lmp_name)\n\n        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n\n\n\n    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);\n\n}\n",
        "output": "1",
        "idx": 2828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragIPv4NoDataTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int id = 12;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* This packet has an offset > 0, more frags set to 0 and no data. */\n    p = BuildTestPacket(id, 1, 0, 'A', 0);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should\n     * have been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 6088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n",
        "output": "0",
        "idx": 3891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n",
        "output": "1",
        "idx": 6136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n",
        "output": "1",
        "idx": 5090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipoctal_init(IPackDevice *ip)\n\n{\n\n    IPOctalState *s = IPOCTAL(ip);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < N_CHANNELS; i++) {\n\n        SCC2698Channel *ch = &s->ch[i];\n\n        ch->ipoctal = s;\n\n\n\n        /* Redirect IP-Octal channels to host character devices */\n\n        if (ch->devpath) {\n\n            const char chr_name[] = \"ipoctal\";\n\n            char label[ARRAY_SIZE(chr_name) + 2];\n\n            static int index;\n\n\n\n            snprintf(label, sizeof(label), \"%s%d\", chr_name, index);\n\n\n\n            ch->dev = qemu_chr_new(label, ch->devpath, NULL);\n\n\n\n            if (ch->dev) {\n\n                index++;\n\n\n                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,\n\n                                      hostdev_receive, hostdev_event, ch);\n\n                DPRINTF(\"Redirecting channel %u to %s (%s)\\n\",\n\n                        i, ch->devpath, label);\n\n            } else {\n\n                DPRINTF(\"Could not redirect channel %u to %s\\n\",\n\n                        i, ch->devpath);\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 2753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)\n{\n    core_dir_config *this_dir = ap_get_core_module_config(sec);\n\n    if (!this_dir) {\n        return;\n    }\n\n    if (this_dir->opts & OPT_UNSET) {\n        opts->add = (opts->add & ~this_dir->opts_remove)\n                   | this_dir->opts_add;\n        opts->remove = (opts->remove & ~this_dir->opts_add)\n                      | this_dir->opts_remove;\n        opts->opts = (opts->opts & ~opts->remove) | opts->add;\n    }\n    else {\n        opts->opts = this_dir->opts;\n        opts->add = this_dir->opts_add;\n        opts->remove = this_dir->opts_remove;\n    }\n\n    if (!(this_dir->override & OR_UNSET)) {\n        opts->override = this_dir->override;\n        opts->override_opts = this_dir->override_opts;\n    }\n\n    if (this_dir->override_list != NULL) {\n        opts->override_list = this_dir->override_list;\n    }\n}",
        "output": "0",
        "idx": 4473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gtk_clist_set_column_auto_resize (GtkCList *clist,\n\t\t\t\t  gint      column,\n\t\t\t\t  gboolean  auto_resize)\n{\n  g_return_if_fail (clist != NULL);\n  g_return_if_fail (GTK_IS_CLIST (clist));\n\n  if (column < 0 || column >= clist->columns)\n    return;\n  if (clist->column[column].auto_resize == auto_resize)\n    return;\n\n  clist->column[column].auto_resize = auto_resize;\n  if (auto_resize)\n    {\n      clist->column[column].resizeable = FALSE;\n      if (!GTK_CLIST_AUTO_RESIZE_BLOCKED(clist))\n\t{\n\t  gint width;\n\n\t  width = gtk_clist_optimal_column_width (clist, column);\n\t  gtk_clist_set_column_width (clist, column, width);\n\t}\n    }\n\n  if (GTK_WIDGET_VISIBLE (clist))\n    size_allocate_title_buttons (clist);\n}",
        "output": "0",
        "idx": 2932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tiff_set_rgb_fields(gx_device_tiff *tfdev)\n{\n    cmm_profile_t *icc_profile;\n\n    if (tfdev->icc_struct->postren_profile != NULL)\n        icc_profile = tfdev->icc_struct->postren_profile;\n    else if (tfdev->icc_struct->oi_profile != NULL)\n        icc_profile = tfdev->icc_struct->oi_profile;\n    else\n        icc_profile = tfdev->icc_struct->device_profile[0];\n\n    switch (icc_profile->data_cs) {\n        case gsRGB:\n            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            break;\n        case gsCIELAB:\n            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB);\n            break;\n        default:\n            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            break;\n    }\n    TIFFSetField(tfdev->tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    TIFFSetField(tfdev->tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\n    tiff_set_compression((gx_device_printer *)tfdev, tfdev->tif,\n                         tfdev->Compression, tfdev->MaxStripSize);\n}",
        "output": "0",
        "idx": 1279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}",
        "output": "0",
        "idx": 3902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    pcms->vmport = value;\n\n}\n",
        "output": "0",
        "idx": 734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }",
        "output": "0",
        "idx": 2626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n",
        "output": "1",
        "idx": 817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "node_new_anychar(void)\n{\n  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);\n  return node;\n}",
        "output": "0",
        "idx": 1115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 2991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 3348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void warnf(struct GlobalConfig *config, const char *fmt, ...)\n{\n  if(!config->mute) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = WARN_TEXTWIDTH-1;\n\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}",
        "output": "1",
        "idx": 1584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    int ret = 0;\n\n\n\n    if (bdrv_set_key(bs, password) != 0) {\n\n        monitor_printf(mon, \"invalid password\\n\");\n\n        ret = -EPERM;\n\n    }\n\n    if (mon->password_completion_cb)\n\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n",
        "output": "0",
        "idx": 1746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){\n\tvoid *res = NULL;\n\tRBuffer *tbuf = NULL;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\ttbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\t\t \n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = r_bin_dex_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res;\n}",
        "output": "0",
        "idx": 1125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PS_CREATE_SID_FUNC(mm)\n{\n\tchar *sid;\n\tPS_MM_DATA;\n\n\tsid = php_session_create_id((void **)&data, newlen TSRMLS_CC);\n\n\treturn sid;\n}",
        "output": "1",
        "idx": 3565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_moverect(VTermRect dest, VTermRect src, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    int\t\tcount = src.start_row - dest.start_row;\n\n    /* Scrolling up is done much more efficiently by deleting lines instead of\n     * redrawing the text. But avoid doing this multiple times, postpone until\n     * the redraw happens. */\n    if (dest.start_col == src.start_col\n\t    && dest.end_col == src.end_col\n\t    && dest.start_row < src.start_row)\n    {\n\tif (dest.start_row == 0)\n\t    term->tl_postponed_scroll += count;\n\telse\n\t    term_scroll_up(term, dest.start_row, count);\n    }\n\n    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);\n    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);\n    set_dirty_snapshot(term);\n\n    /* Note sure if the scrolling will work correctly, let's do a complete\n     * redraw later. */\n    redraw_buf_later(term->tl_buffer, NOT_VALID);\n    return 1;\n}",
        "output": "0",
        "idx": 1004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  inline CImg<_cimg_Tfloat> pseudoinvert(const CImg<T>& instance, const bool use_LU=false) {\n    return instance.get_pseudoinvert(use_LU);\n  }",
        "output": "0",
        "idx": 2662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_config_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      const char *config_dir = g_getenv (\"FLATPAK_CONFIG_DIR\");\n      if (config_dir != NULL)\n        setup_value = (gsize) config_dir;\n      else\n        setup_value = (gsize) FLATPAK_CONFIGDIR;\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return (const char *) path;\n}",
        "output": "0",
        "idx": 4447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n",
        "output": "1",
        "idx": 4627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tbdecode_node bdecode_node::dict_find_dict(std::string key) const\n\t{\n\t\tbdecode_node ret = dict_find(key);\n\t\tif (ret.type() == bdecode_node::dict_t)\n\t\t\treturn ret;\n\t\treturn bdecode_node();\n\t}",
        "output": "0",
        "idx": 4332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void block_job_resume_all(void)\n\n{\n\n    BlockJob *job = NULL;\n\n    while ((job = block_job_next(job))) {\n\n        AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n        aio_context_acquire(aio_context);\n\n        block_job_resume(job);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\n{\n    gint     offset_start;\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}",
        "output": "0",
        "idx": 5220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {\n\tqWarning()<<\"Bonjour reported browser error \"<< err;\n}",
        "output": "0",
        "idx": 3496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n",
        "output": "1",
        "idx": 4121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification)\n{\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = qualification;\n\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tto_vmx(vcpu)->nested.sync_shadow_vmcs = true;\n}",
        "output": "0",
        "idx": 3808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 3258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n",
        "output": "1",
        "idx": 445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_rsvg_node_init (RsvgNode * self)\n{\n    self->parent = NULL;\n    self->children = g_ptr_array_new ();\n    self->state = g_new (RsvgState, 1);\n    rsvg_state_init (self->state);\n    self->free = _rsvg_node_free;\n    self->draw = _rsvg_node_draw_nothing;\n    self->set_atts = _rsvg_node_dont_set_atts;\n    self->type = NULL;\n}",
        "output": "1",
        "idx": 5933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),\n\t\t       void *userdata, const void *buf, size_t len)\n{\n\tds_stream_ctxt_t\t*stream_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) userdata;\n\n\txb_ad(stream_ctxt != NULL);\n\txb_ad(stream_ctxt->dest_file != NULL);\n\n\tif (!ds_write(stream_ctxt->dest_file, buf, len)) {\n\t\treturn len;\n\t}\n\treturn -1;\n}",
        "output": "0",
        "idx": 5431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[node->outputs->data[index]];\n  } else {\n    return context->GetTensor(context, node->outputs->data[index]);\n  }\n}",
        "output": "1",
        "idx": 5013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, size,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n",
        "output": "0",
        "idx": 4339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __io_put_task(struct task_struct *task, int nr)\n{\n\tstruct io_uring_task *tctx = task->io_uring;\n\n\tpercpu_counter_sub(&tctx->inflight, nr);\n\tif (unlikely(atomic_read(&tctx->in_idle)))\n\t\twake_up(&tctx->wait);\n\tput_task_struct_many(task, nr);\n}",
        "output": "0",
        "idx": 306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *ask_new_shell(char *question, char *oldshell)\n{\n\tint len;\n\tchar *ans = NULL;\n\tsize_t dummy = 0;\n\n\tif (!oldshell)\n\t\toldshell = \"\";\n\tprintf(\"%s [%s]:\", question, oldshell);\n\tputchar(' ');\n\n\tif (getline(&ans, &dummy, stdin) < 0)\n\t\treturn NULL;\n\n\t/* remove the newline at the end of ans. */\n\tltrim_whitespace((unsigned char *) ans);\n\tlen = rtrim_whitespace((unsigned char *) ans);\n\tif (len == 0)\n\t\treturn NULL;\n\treturn ans;\n}",
        "output": "0",
        "idx": 5178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_i_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  enum Type type() const { return COPY_STR_ITEM; }",
        "output": "0",
        "idx": 52
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 4086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)\n\n{\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR4 update: CR4=%08x\\n\", (uint32_t)env->cr[4]);\n\n#endif\n\n    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=\n\n        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {\n\n        tlb_flush(env, 1);\n\n    }\n\n    /* SSE handling */\n\n    if (!(env->cpuid_features & CPUID_SSE))\n\n        new_cr4 &= ~CR4_OSFXSR_MASK;\n\n    if (new_cr4 & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    env->cr[4] = new_cr4;\n\n}\n",
        "output": "0",
        "idx": 4388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,\n                              const T& a4, const T& a5, const T& a6, const T& a7,\n                              const T& a8, const T& a9, const T& a10, const T& a11,\n                              const T& a12) {\n      CImg<T> r(13,1);\n      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;\n      r[10] = a10; r[11] = a11; r[12] = a12;\n      return r;\n    }",
        "output": "0",
        "idx": 1434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nouveau_sgdma_create_ttm(struct ttm_buffer_object *bo, uint32_t page_flags)\n{\n\tstruct nouveau_drm *drm = nouveau_bdev(bo->bdev);\n\tstruct nouveau_sgdma_be *nvbe;\n\n\tnvbe = kzalloc(sizeof(*nvbe), GFP_KERNEL);\n\tif (!nvbe)\n\t\treturn NULL;\n\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA)\n\t\tnvbe->ttm.ttm.func = &nv04_sgdma_backend;\n\telse\n\t\tnvbe->ttm.ttm.func = &nv50_sgdma_backend;\n\n\tif (ttm_dma_tt_init(&nvbe->ttm, bo, page_flags))\n\t\t/*\n\t\t * A failing ttm_dma_tt_init() will call ttm_tt_destroy()\n\t\t * and thus our nouveau_sgdma_destroy() hook, so we don't need\n\t\t * to free nvbe here.\n\t\t */\n\t\treturn NULL;\n\treturn &nvbe->ttm.ttm;\n}",
        "output": "1",
        "idx": 1631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int input_init(void)\n{\n\tGKeyFile *config;\n\tGError *err = NULL;\n\n\tconfig = load_config_file(CONFIGDIR \"/input.conf\");\n\tif (config) {\n\t\tint idle_timeout;\n\t\tgboolean uhid_enabled;\n\n\t\tidle_timeout = g_key_file_get_integer(config, \"General\",\n\t\t\t\t\t\t\t\"IdleTimeout\", &err);\n\t\tif (!err) {\n\t\t\tDBG(\"input.conf: IdleTimeout=%d\", idle_timeout);\n\t\t\tinput_set_idle_timeout(idle_timeout * 60);\n\t\t} else\n\t\t\tg_clear_error(&err);\n\n\t\tuhid_enabled = g_key_file_get_boolean(config, \"General\",\n\t\t\t\t\t\t\t\"UserspaceHID\", &err);\n\t\tif (!err) {\n\t\t\tDBG(\"input.conf: UserspaceHID=%s\", uhid_enabled ?\n\t\t\t\t\t\t\t\"true\" : \"false\");\n\t\t\tinput_enable_userspace_hid(uhid_enabled);\n\t\t} else\n\t\t\tg_clear_error(&err);\n\t}\n\n\tbtd_profile_register(&input_profile);\n\n\tif (config)\n\t\tg_key_file_free(config);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void memory_region_add_eventfd(MemoryRegion *mr,\n\n                               hwaddr addr,\n\n                               unsigned size,\n\n                               bool match_data,\n\n                               uint64_t data,\n\n                               EventNotifier *e)\n\n{\n\n    MemoryRegionIoeventfd mrfd = {\n\n        .addr.start = int128_make64(addr),\n\n        .addr.size = int128_make64(size),\n\n        .match_data = match_data,\n\n        .data = data,\n\n        .e = e,\n\n    };\n\n    unsigned i;\n\n\n\n    adjust_endianness(mr, &mrfd.data, size);\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n\n            break;\n\n        }\n\n    }\n\n    ++mr->ioeventfd_nb;\n\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n\n    mr->ioeventfds[i] = mrfd;\n\n    ioeventfd_update_pending |= mr->enabled;\n\n    memory_region_transaction_commit();\n\n}\n",
        "output": "1",
        "idx": 4230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n\n                             int poc, int ref_flag)\n\n{\n\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n\n\n    if (ref == s->ref)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!ref) {\n\n        ref = generate_missing_ref(s, poc);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    list->list[list->nb_refs] = ref->poc;\n\n    list->ref[list->nb_refs]  = ref;\n\n    list->nb_refs++;\n\n\n\n    mark_ref(ref, ref_flag);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_int */",
        "output": "1",
        "idx": 70
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PrintUsageAndExit()\n{\n    fprintf(stderr, \n            BANNER \n            \"\\n\\nusage: mp4fragment [options] <input> <output>\\n\"\n            \"options are:\\n\"\n            \"  --verbosity <n> sets the verbosity (details) level to <n> (between 0 and 3)\\n\"\n            \"  --debug enable debugging information output\\n\"\n            \"  --quiet don't print out notice messages\\n\"\n            \"  --fragment-duration <milliseconds> (default = automatic)\\n\"\n            \"  --timescale <n> (use 10000000 for Smooth Streaming compatibility)\\n\"\n            \"  --track <track-id or type> only include media from one track (pass a track ID or 'audio' or 'video')\\n\"\n            \"  --index (re)create the segment index\\n\"\n            );\n    exit(1);\n}",
        "output": "0",
        "idx": 2049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_init_main_loop(void)\n\n{\n\n    int ret;\n\n\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_init_sigbus();\n\n\n\n    return qemu_event_init();\n\n}\n",
        "output": "1",
        "idx": 573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  inline bool get_glyph (hb_codepoint_t  unicode,\n\t\t\t hb_codepoint_t  variation_selector,\n\t\t\t hb_codepoint_t *glyph) const\n  {\n    if (unlikely (variation_selector))\n    {\n      switch (this->uvs_table->get_glyph_variant (unicode,\n\t\t\t\t\t\t  variation_selector,\n\t\t\t\t\t\t  glyph))\n      {\n\tcase OT::GLYPH_VARIANT_NOT_FOUND:\treturn false;\n\tcase OT::GLYPH_VARIANT_FOUND:\t\treturn true;\n\tcase OT::GLYPH_VARIANT_USE_DEFAULT:\tbreak;\n      }\n    }\n\n    return this->table->get_glyph (unicode, glyph);\n  }",
        "output": "0",
        "idx": 1901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)\n{\n    fdctrl->config = fdctrl->fifo[2];\n    fdctrl->precomp_trk =  fdctrl->fifo[3];\n    /* No result back */\n    fdctrl_reset_fifo(fdctrl);\n}",
        "output": "0",
        "idx": 4377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rend_get_service_list_mutable(smartlist_t* substitute_service_list)\n{\n  if (substitute_service_list) {\n    return substitute_service_list;\n  }\n\n  /* If no special service list is provided, then just use the global one. */\n\n  if (BUG(!rend_service_list)) {\n    /* No global HS list, which is a programmer error. */\n    return NULL;\n  }\n\n  return rend_service_list;\n}",
        "output": "0",
        "idx": 3476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n\n                                  cavs_vector *col_mv)\n\n{\n\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n\n    int den = h->direct_den[col_mv->ref];\n\n    int m = FF_SIGNBIT(col_mv->x);\n\n\n\n    pmv_fw->dist = h->dist[1];\n\n    pmv_bw->dist = h->dist[0];\n\n    pmv_fw->ref = 1;\n\n    pmv_bw->ref = 0;\n\n    /* scale the co-located motion vector according to its temporal span */\n\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n    m = FF_SIGNBIT(col_mv->y);\n\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n}\n",
        "output": "1",
        "idx": 4872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}",
        "output": "0",
        "idx": 3097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}",
        "output": "1",
        "idx": 2373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)\n{\n\tzval *val;\n\n\tMAKE_STD_ZVAL(*retval);\n\tarray_init(*retval);\n\n\tif (snmp_object->session == NULL) {\n\t\treturn SUCCESS;\n\t}\n\t\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);\n\tadd_assoc_zval(*retval, \"hostname\", val);\n\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_LONG(val, snmp_object->session->remote_port);\n\tadd_assoc_zval(*retval, \"port\", val);\n\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_LONG(val, snmp_object->session->timeout);\n\tadd_assoc_zval(*retval, \"timeout\", val);\n\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_LONG(val, snmp_object->session->retries);\n\tadd_assoc_zval(*retval, \"retries\", val);\n\t\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 2497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
        "output": "0",
        "idx": 3980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)\n{\n\tint *old = NULL, *new = NULL;\n\tsize_t old_size = 0, new_size = new_alloc * sizeof(new[0]);\n\tunsigned long flags;\n\n\tnew = pcpu_mem_zalloc(new_size);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/* acquire pcpu_lock and switch to new area map */\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tif (new_alloc <= chunk->map_alloc)\n\t\tgoto out_unlock;\n\n\told_size = chunk->map_alloc * sizeof(chunk->map[0]);\n\told = chunk->map;\n\n\tmemcpy(new, old, old_size);\n\n\tchunk->map_alloc = new_alloc;\n\tchunk->map = new;\n\tnew = NULL;\n\nout_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * pcpu_mem_free() might end up calling vfree() which uses\n\t * IRQ-unsafe lock and thus can't be called under pcpu_lock.\n\t */\n\tpcpu_mem_free(old);\n\tpcpu_mem_free(new);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    return AVERROR(ENOSYS);\n}",
        "output": "1",
        "idx": 2109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Scanner::pop_finished_files()\n{\n    // Pop all files that have been fully processed (file upper bound\n    // in buffer points before the first character of current lexeme),\n    // except for the first (main) file which must always remain at the\n    // bottom of the stack.\n    size_t i = files.size();\n    DASSERT(i > 0);\n    for (;;) {\n        --i;\n        Input *in = files[i];\n        if (i == 0 || in->eo >= tok) break;\n        files.pop_back();\n        delete in;\n    }\n}",
        "output": "0",
        "idx": 6024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus LeakyReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  LeakyReluOpData* data = reinterpret_cast<LeakyReluOpData*>(node->user_data);\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n      output->type == kTfLiteInt16) {\n    const auto* params =\n        reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n\n    double alpha_multiplier =\n        input->params.scale * params->alpha / output->params.scale;\n    QuantizeMultiplier(alpha_multiplier, &data->output_multiplier_alpha,\n                       &data->output_shift_alpha);\n    double identity_multiplier = input->params.scale / output->params.scale;\n    QuantizeMultiplier(identity_multiplier, &data->output_multiplier_identity,\n                       &data->output_shift_identity);\n  }\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}",
        "output": "1",
        "idx": 2485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int credssp_skip_ts_request(int length)\n{\n\tlength += ber_skip_integer(2);\n\tlength += ber_skip_contextual_tag(3);\n\tlength += der_skip_sequence_tag(length);\n\treturn length;\n}",
        "output": "1",
        "idx": 2829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}",
        "output": "1",
        "idx": 3501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_encode_base64_length(const njs_str_t *src, size_t *out_size)\n{\n    size_t  size;\n\n    size = (src->length == 0) ? 0 : njs_base64_encoded_length(src->length);\n\n    if (out_size != NULL) {\n        *out_size = size;\n    }\n\n    return size;\n}",
        "output": "0",
        "idx": 1364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(imagesetstyle)\n{\n\tzval *IM, *styles;\n\tgdImagePtr im;\n\tint * stylearr;\n\tint index;\n\tHashPosition pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &styles) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* copy the style values in the stylearr */\n\tstylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);\n\n\tzend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);\n\n\tfor (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))\t{\n\t\tzval ** item;\n\n\t\tif (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconvert_to_long_ex(item);\n\n\t\tstylearr[index++] = Z_LVAL_PP(item);\n\t}\n\n\tgdImageSetStyle(im, stylearr, index);\n\n\tefree(stylearr);\n\n\tRETURN_TRUE;\n}",
        "output": "1",
        "idx": 4568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_free_idnconverted_hostname(struct hostname *host)\n{\n#if defined(USE_LIBIDN2)\n  if(host->encalloc) {\n    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was\n                                 allocated by libidn */\n    host->encalloc = NULL;\n  }\n#elif defined(USE_WIN32_IDN)\n  free(host->encalloc); /* must be freed with free() since this was\n                           allocated by curl_win32_idn_to_ascii */\n  host->encalloc = NULL;\n#else\n  (void)host;\n#endif\n}",
        "output": "0",
        "idx": 4155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evbuffer_chain_new(size_t size)\n{\n\tstruct evbuffer_chain *chain;\n\tsize_t to_alloc;\n\n\tsize += EVBUFFER_CHAIN_SIZE;\n\n\t/* get the next largest memory that can hold the buffer */\n\tto_alloc = MIN_BUFFER_SIZE;\n\twhile (to_alloc < size)\n\t\tto_alloc <<= 1;\n\n\t/* we get everything in one chunk */\n\tif ((chain = mm_malloc(to_alloc)) == NULL)\n\t\treturn (NULL);\n\n\tmemset(chain, 0, EVBUFFER_CHAIN_SIZE);\n\n\tchain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;\n\n\t/* this way we can manipulate the buffer to different addresses,\n\t * which is required for mmap for example.\n\t */\n\tchain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);\n\n\tchain->refcnt = 1;\n\n\treturn (chain);\n}",
        "output": "1",
        "idx": 6319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)\n\n{\n\n    int i;\n\n\n\n    s->dts    =\n\n    s->pts    = AV_NOPTS_VALUE;\n\n    s->pos    = -1;\n\n    s->offset = 0;\n\n    for (i = 0; i < AV_PARSER_PTS_NB; i++) {\n\n        if (s->cur_offset + off >= s->cur_frame_offset[i] &&\n\n            (s->frame_offset < s->cur_frame_offset[i] ||\n\n             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame\n\n            // check disabled since MPEG-TS does not send complete PES packets\n\n            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){\n\n\n\n            s->dts    = s->cur_frame_dts[i];\n\n            s->pts    = s->cur_frame_pts[i];\n\n            s->pos    = s->cur_frame_pos[i];\n\n            s->offset = s->next_frame_offset - s->cur_frame_offset[i];\n\n            if (remove)\n\n                s->cur_frame_offset[i] = INT64_MAX;\n\n            if (s->cur_offset + off < s->cur_frame_end[i])\n\n                break;\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double y2scr_sub(ASS_Renderer *render_priv, double y)\n{\n    if (render_priv->state.explicit)\n        return y2scr_pos(render_priv, y);\n    if (render_priv->settings.use_margins)\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0)\n            + FFMAX(render_priv->settings.bottom_margin, 0);\n    else\n        return y * render_priv->orig_height_nocrop /\n            render_priv->track->PlayResY +\n            FFMAX(render_priv->settings.top_margin, 0);\n}",
        "output": "0",
        "idx": 3452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void slc_sync(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slcan\t  *sl;\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty)\n\t\t\tcontinue;\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_close(dev);\n\t}\n}",
        "output": "0",
        "idx": 1042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE))\n\t\tfuse_link_write_file(file);\n\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}",
        "output": "0",
        "idx": 6235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_session *session = priv->session;\n\tunsigned int len = skb->len;\n\tint ret = l2tp_xmit_skb(session, skb, session->hdr_len);\n\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tatomic_long_add(len, &priv->tx_bytes);\n\t\tatomic_long_inc(&priv->tx_packets);\n\t} else {\n\t\tatomic_long_inc(&priv->tx_dropped);\n\t}\n\treturn NETDEV_TX_OK;\n}",
        "output": "0",
        "idx": 3614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libgsm_decode_frame(AVCodecContext *avctx,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt) {\n\n    uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);\n\n\n\n    if (*data_size < out_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (buf_size < avctx->block_align) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch(avctx->codec_id) {\n\n    case CODEC_ID_GSM:\n\n        if(gsm_decode(avctx->priv_data,buf,data)) return -1;\n\n        break;\n\n    case CODEC_ID_GSM_MS:\n\n        if(gsm_decode(avctx->priv_data,buf,data) ||\n\n           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;\n\n    }\n\n\n\n    *data_size = out_size;\n\n    return avctx->block_align;\n\n}\n",
        "output": "0",
        "idx": 2920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline const WCHAR *GetDirW(int index)\n    {\n\tWCHAR *ptr = dirTableW[index];\n\tif (!ptr) {\n\t    /* simulate the existence of this drive */\n\t    ptr = szLocalBufferW;\n\t    ptr[0] = 'A' + index;\n\t    ptr[1] = ':';\n\t    ptr[2] = '\\\\';\n\t    ptr[3] = 0;\n\t}\n\treturn ptr;\n    };",
        "output": "0",
        "idx": 2659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void stdp_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}",
        "output": "0",
        "idx": 4796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvmppc_reset_htab(int shift_hint)\n\n{\n\n    uint32_t shift = shift_hint;\n\n\n\n    if (!kvm_enabled()) {\n\n        /* Full emulation, tell caller to allocate htab itself */\n\n        return 0;\n\n    }\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n\n        int ret;\n\n        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n\n        if (ret == -ENOTTY) {\n\n            /* At least some versions of PR KVM advertise the\n\n             * capability, but don't implement the ioctl().  Oops.\n\n             * Return 0 so that we allocate the htab in qemu, as is\n\n             * correct for PR. */\n\n            return 0;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n        return shift;\n\n    }\n\n\n\n    /* We have a kernel that predates the htab reset calls.  For PR\n\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n\n     * this era, it has allocated a 16MB fixed size hash table already. */\n\n    if (kvmppc_is_pr(kvm_state)) {\n\n        /* PR - tell caller to allocate htab */\n\n        return 0;\n\n    } else {\n\n        /* HV - assume 16MB kernel allocated htab */\n\n        return 24;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n",
        "output": "1",
        "idx": 3673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}",
        "output": "0",
        "idx": 5329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct neigh_table *tbl;\n\tint t, family, s_t;\n\n\tread_lock(&neigh_tbl_lock);\n\tfamily = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;\n\ts_t = cb->args[0];\n\n\tfor (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {\n\t\tif (t < s_t || (family && tbl->family != family))\n\t\t\tcontinue;\n\t\tif (t > s_t)\n\t\t\tmemset(&cb->args[1], 0, sizeof(cb->args) -\n\t\t\t\t\t\tsizeof(cb->args[0]));\n\t\tif (neigh_dump_table(tbl, skb, cb) < 0)\n\t\t\tbreak;\n\t}\n\tread_unlock(&neigh_tbl_lock);\n\n\tcb->args[0] = t;\n\treturn skb->len;\n}",
        "output": "0",
        "idx": 6139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t/*\n\t\t * Base is simply the segment selector shifted 4\n\t\t * bits to the right.\n\t\t */\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t/*\n\t\t * Only FS or GS will have a base address, the rest of\n\t\t * the segments' bases are forced to 0.\n\t\t */\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t/*\n\t\t\t * swapgs was called at the kernel entry point. Thus,\n\t\t\t * MSR_KERNEL_GS_BASE will have the user-space GS base.\n\t\t\t */\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t/* In protected mode the segment selector cannot be null. */\n\tif (!sel)\n\t\treturn -1L;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\n\treturn get_desc_base(desc);\n}",
        "output": "1",
        "idx": 1856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n\n\n    src1 += c->chrSrcOffset;\n\n    src2 += c->chrSrcOffset;\n\n\n\n    if (c->chrToYV12) {\n\n        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst, dstWidth);\n\n}\n",
        "output": "1",
        "idx": 4753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bw_conf1_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    PCIBus *b = opaque;\n\n    pci_data_write(b, addr, val, size);\n\n}\n",
        "output": "0",
        "idx": 6022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *rxe_find_route6(struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\tstruct dst_entry *ndst;\n\tstruct flowi6 fl6 = { { 0 } };\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_oif = ndev->ifindex;\n\tmemcpy(&fl6.saddr, saddr, sizeof(*saddr));\n\tmemcpy(&fl6.daddr, daddr, sizeof(*daddr));\n\tfl6.flowi6_proto = IPPROTO_UDP;\n\n\tif (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),\n\t\t\t\t\t\trecv_sockets.sk6->sk, &ndst, &fl6))) {\n\t\tpr_err_ratelimited(\"no route to %pI6\\n\", daddr);\n\t\tgoto put;\n\t}\n\n\tif (unlikely(ndst->error)) {\n\t\tpr_err(\"no route to %pI6\\n\", daddr);\n\t\tgoto put;\n\t}\n\n\treturn ndst;\nput:\n\tdst_release(ndst);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 5951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n    free(ctx);\n\n}\n",
        "output": "0",
        "idx": 5413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)\n{\n    ptr_t result;\n    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);\n\n    GC_ASSERT(I_HOLD_LOCK());\n    result = GC_alloc_large(lb, k, flags);\n    if (result != NULL\n          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {\n        /* Clear the whole block, in case of GC_realloc call. */\n        BZERO(result, n_blocks * HBLKSIZE);\n    }\n    return result;\n}",
        "output": "1",
        "idx": 3671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (bdrv) {\n\n        bdrv_get_geometry(bdrv, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->bdrv = bdrv;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;\n\n    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);\n\n    memset(sd->function_group, 0, sizeof(int) * 6);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = 0;\n\n}\n",
        "output": "0",
        "idx": 5273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n",
        "output": "0",
        "idx": 3429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mux_chr_close(struct CharDriverState *chr)\n{\n    MuxDriver *d = chr->opaque;\n\n    qemu_chr_fe_deinit(&d->chr);\n    g_free(d);\n}",
        "output": "1",
        "idx": 1225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n",
        "output": "1",
        "idx": 2530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n",
        "output": "1",
        "idx": 3210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zzip_mem_disk_fread (void* ptr, _zzip_size_t size, _zzip_size_t nmemb,\n                     ZZIP_DISK_FILE* file) {\n    return zzip_disk_fread(ptr, size, nmemb, file); }",
        "output": "1",
        "idx": 3421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)\n{\n\tunsigned long flags;\n\n\tif (!xs->tx)\n\t\treturn;\n\n\tspin_lock_irqsave(&umem->xsk_list_lock, flags);\n\tlist_del_rcu(&xs->list);\n\tspin_unlock_irqrestore(&umem->xsk_list_lock, flags);\n}",
        "output": "0",
        "idx": 1332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n",
        "output": "1",
        "idx": 1874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;",
        "output": "1",
        "idx": 1954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void allocHeaders() override {\n    ASSERT(nullptr == absl::get<ResponseHeaderMapPtr>(headers_or_trailers_));\n    ASSERT(!processing_trailers_);\n    headers_or_trailers_.emplace<ResponseHeaderMapPtr>(ResponseHeaderMapImpl::create());\n  }",
        "output": "0",
        "idx": 2942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,\n\t\tunsigned int length, gfp_t gfp)\n{\n\tstruct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);\n\n\tif (NET_IP_ALIGN && skb)\n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\treturn skb;",
        "output": "0",
        "idx": 3150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n",
        "output": "1",
        "idx": 5304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtbt_setup_realtek(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t/* Read ROM Version */\n\tskb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"ROM version %u\", *((__u8 *) (skb->data + 1)));\n\n\tkfree_skb(skb);\n\treturn 0;\n}",
        "output": "0",
        "idx": 5172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bson_iterator_int_raw( const bson_iterator *i ) {\n    int out;\n    bson_little_endian32( &out, bson_iterator_value( i ) );\n    return out;\n}",
        "output": "0",
        "idx": 3442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prov_msg_recv(void)\n{\n\tk_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);\n\n\tif (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {\n\t\tBT_ERR(\"Incorrect FCS\");\n\t\treturn;\n\t}\n\n\tgen_prov_ack_send(link.rx.id);\n\n\tif (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {\n\t\tBT_WARN(\"Unexpected msg 0x%02x on invalidated link\",\n\t\t\tlink.rx.buf->data[0]);\n\t\tprov_failed(PROV_ERR_UNEXP_PDU);\n\t\treturn;\n\t}\n\n\tlink.cb->recv(&pb_adv, link.cb_data, link.rx.buf);\n}",
        "output": "0",
        "idx": 3459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cooked(\n\tstruct parse *pcmd,\n\tFILE *fp\n\t)\n{\n\trawmode = 0;\n\t(void) fprintf(fp, \"Output set to cooked\\n\");\n\treturn;\n}",
        "output": "0",
        "idx": 405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_rq_clock(rq);\n\tsched_info_dequeued(p);\n\tp->sched_class->dequeue_task(rq, p, flags);\n\tp->se.on_rq = 0;\n}",
        "output": "0",
        "idx": 569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void agent_read_complete(UdscsConnection *conn,\n    struct udscs_message_header *header, uint8_t *data)\n{\n    switch (header->type) {\n    case VDAGENTD_GUEST_XORG_RESOLUTION:\n        do_agent_xorg_resolution(conn, header, data);\n        break;\n    case VDAGENTD_CLIPBOARD_GRAB:\n    case VDAGENTD_CLIPBOARD_REQUEST:\n    case VDAGENTD_CLIPBOARD_DATA:\n    case VDAGENTD_CLIPBOARD_RELEASE:\n        do_agent_clipboard(conn, header, data);\n        break;\n    case VDAGENTD_FILE_XFER_STATUS:\n        do_agent_file_xfer_status(conn, header, data);\n        break;\n\n    default:\n        syslog(LOG_ERR, \"unknown message from vdagent: %u, ignoring\",\n               header->type);\n    }\n}",
        "output": "0",
        "idx": 4404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int mp_decode_init(AVCodecContext *avctx)\n\n{\n\n    MotionPixelsContext *mp = avctx->priv_data;\n\n    int w4 = (avctx->width  + 3) & ~3;\n\n    int h4 = (avctx->height + 3) & ~3;\n\n\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"extradata too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    motionpixels_tableinit();\n\n    mp->avctx = avctx;\n\n    ff_dsputil_init(&mp->dsp, avctx);\n\n    mp->changes_map = av_mallocz(avctx->width * h4);\n\n    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;\n\n    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));\n\n    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&mp->frame);\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 6027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\t\t\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\t\n\t\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}",
        "output": "1",
        "idx": 270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int merge_extent_mapping(struct extent_map_tree *em_tree,\n\t\t\t\tstruct extent_map *existing,\n\t\t\t\tstruct extent_map *em,\n\t\t\t\tu64 map_start, u64 map_len)\n{\n\tu64 start_diff;\n\n\tBUG_ON(map_start < em->start || map_start >= extent_map_end(em));\n\tstart_diff = map_start - em->start;\n\tem->start = map_start;\n\tem->len = map_len;\n\tif (em->block_start < EXTENT_MAP_LAST_BYTE &&\n\t    !test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\tem->block_start += start_diff;\n\t\tem->block_len -= start_diff;\n\t}\n\treturn add_extent_mapping(em_tree, em);\n}",
        "output": "0",
        "idx": 1460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFFormFieldObjectHelper::getChoices()\n{\n    std::vector<std::string> result;\n    if (! isChoice())\n    {\n        return result;\n    }\n    QPDFObjectHandle opt = getInheritableFieldValue(\"/Opt\");\n    if (opt.isArray())\n    {\n        size_t n = opt.getArrayNItems();\n        for (size_t i = 0; i < n; ++i)\n        {\n            QPDFObjectHandle item = opt.getArrayItem(i);\n            if (item.isString())\n            {\n                result.push_back(item.getUTF8Value());\n            }\n        }\n    }\n    return result;\n}",
        "output": "1",
        "idx": 2653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n",
        "output": "1",
        "idx": 3989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t runtime_active_kids_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev->power.ignore_children ?\n\t\t0 : atomic_read(&dev->power.child_count));\n}",
        "output": "1",
        "idx": 5851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n",
        "output": "0",
        "idx": 6008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tchar *value = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\tif (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {\n\t\tvalue = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t}\n\tif (value == NULL) {\n\t\tr_list_foreach (cp_list, iter, item) {\n\t\t\tif (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {\n\t\t\t\tvalue = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}",
        "output": "0",
        "idx": 3828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDF::flattenPagesTree()\n{\n    // If not already done, flatten the /Pages structure and\n    // initialize pageobj_to_pages_pos.\n\n    if (! this->m->pageobj_to_pages_pos.empty())\n    {\n        return;\n    }\n\n    // Push inherited objects down to the /Page level.  As a side\n    // effect this->m->all_pages will also be generated.\n    pushInheritedAttributesToPage(true, true);\n\n    QPDFObjectHandle pages = getRoot().getKey(\"/Pages\");\n\n    size_t const len = this->m->all_pages.size();\n    for (size_t pos = 0; pos < len; ++pos)\n    {\n        // populate pageobj_to_pages_pos and fix parent pointer\n        insertPageobjToPage(this->m->all_pages.at(pos), toI(pos), true);\n        this->m->all_pages.at(pos).replaceKey(\"/Parent\", pages);\n    }\n\n    pages.replaceKey(\"/Kids\", QPDFObjectHandle::newArray(this->m->all_pages));\n    // /Count has not changed\n    if (pages.getKey(\"/Count\").getUIntValue() != len)\n    {\n        throw std::logic_error(\"/Count is wrong after flattening pages tree\");\n    }\n}",
        "output": "0",
        "idx": 1698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void save_native_fp_fsave(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    uint16_t fpuc;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    asm volatile (\"fsave %0\" : : \"m\" (*fp));\n\n    env->fpuc = fp->fpuc;\n\n    env->fpstt = (fp->fpus >> 11) & 7;\n\n    env->fpus = fp->fpus & ~0x3800;\n\n    fptag = fp->fptag;\n\n    for(i = 0;i < 8; i++) {\n\n        env->fptags[i] = ((fptag & 3) == 3);\n\n        fptag >>= 2;\n\n    }\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    /* we must restore the default rounding state */\n\n    fpuc = 0x037f | (env->fpuc & (3 << 10));\n\n    asm volatile(\"fldcw %0\" : : \"m\" (fpuc));\n\n}\n",
        "output": "0",
        "idx": 4165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int has_handler(pid_t pid, int signal) {\n\tif (signal > 0 && signal <= SIGRTMAX) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tEUID_ROOT();\n\t\tFILE *fp = fopen(fname, \"re\");\n\t\tEUID_USER();\n\t\tfree(fname);\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\twhile (fgets(buf, BUFLEN, fp)) {\n\t\t\t\tif (strncmp(buf, \"SigCgt:\", 7) == 0) {\n\t\t\t\t\tunsigned long long val;\n\t\t\t\t\tif (sscanf(buf + 7, \"%llx\", &val) != 1) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tval >>= (signal - 1);\n\t\t\t\t\tval &= 1ULL;\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn val;  // 1 if process has a handler for the signal, else 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 4158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n",
        "output": "0",
        "idx": 5672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 1128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long do_sigreturn(CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\ttarget_sigset_t target_set;\n\n\tsigset_t set;\n\n\tint i;\n\n\n\n\tframe_addr = env->regs[R_SP];\n\n\t/* Make sure the guest isn't playing games.  */\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n\t\tgoto badframe;\n\n\n\n\t/* Restore blocked signals */\n\n\tif (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n\t\tgoto badframe;\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\ttarget_to_host_sigset_internal(&set, &target_set);\n\n        do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n\trestore_sigcontext(&frame->sc, env);\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[10];\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n",
        "output": "1",
        "idx": 4352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}",
        "output": "1",
        "idx": 3851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    sprintf(pidstr, \"%d\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n",
        "output": "0",
        "idx": 4062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qxl_destroy_primary(PCIQXLDevice *d, qxl_async_io async)\n{\n    if (d->mode == QXL_MODE_UNDEFINED) {\n        return 0;\n    }\n    trace_qxl_destroy_primary(d->id);\n    d->mode = QXL_MODE_UNDEFINED;\n    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);\n    qxl_spice_reset_cursor(d);\n    return 1;\n}",
        "output": "0",
        "idx": 6302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)\n\n{\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\",\n\n                    info->name, info->bus_info->name);\n\n    if (info->alias)\n\n        pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias);\n\n    if (info->desc)\n\n        pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc);\n\n    if (info->no_user)\n\n        pos += snprintf(dest+pos, len-pos, \", no-user\");\n\n    return pos;\n\n}\n",
        "output": "0",
        "idx": 3719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n",
        "output": "1",
        "idx": 2081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void io_mem_init(void)\n{\n    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);\n    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n\n    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,\n     * which can be called without the iothread mutex.\n     */\n    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n    memory_region_clear_global_locking(&io_mem_notdirty);\n\n    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n}",
        "output": "0",
        "idx": 3539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)\n{\n    // no extensions supported yet\n    return 0;\n}",
        "output": "0",
        "idx": 3504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GError *add(char *label, char *server, char *username, char *secret) {\n\tGError *err = NULL;\n\n\tsecret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,\n\t\t\tserver, secret, NULL, &err,\n\t\t\t\"label\", label,\n\t\t\t\"server\", server,\n\t\t\t\"username\", username,\n\t\t\t\"docker_cli\", \"1\",\n\t\t\tNULL);\n\treturn err;\n}",
        "output": "0",
        "idx": 598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RGWListBucketMultiparts_ObjStore::get_params()\n{\n  delimiter = s->info.args.get(\"delimiter\");\n  prefix = s->info.args.get(\"prefix\");\n  string str = s->info.args.get(\"max-uploads\");\n  op_ret = parse_value_and_bound(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, default_max);\n  if (op_ret < 0) {\n    return op_ret;\n  }\n\n  string key_marker = s->info.args.get(\"key-marker\");\n  string upload_id_marker = s->info.args.get(\"upload-id-marker\");\n  if (!key_marker.empty())\n    marker.init(key_marker, upload_id_marker);\n\n  return 0;\n}",
        "output": "1",
        "idx": 2743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void drbg_set_testdata(struct drbg_state *drbg,\n\t\t\t\t     struct drbg_test_data *test_data)\n{\n\tif (!test_data || !test_data->testentropy)\n\t\treturn;\n\tmutex_lock(&drbg->drbg_mutex);;\n\tdrbg->test_data = test_data;\n\tmutex_unlock(&drbg->drbg_mutex);\n}",
        "output": "1",
        "idx": 5011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void veth_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tdata[0] = priv->peer->ifindex;\n}",
        "output": "0",
        "idx": 3680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n",
        "output": "0",
        "idx": 952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    CImg(const T *const values, const unsigned int size_x, const unsigned int size_y=1,\n         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false) {\n      const size_t siz = safe_size(size_x,size_y,size_z,size_c);\n      if (values && siz) {\n        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c; _is_shared = is_shared;\n        if (_is_shared) _data = const_cast<T*>(values);\n        else {\n          try { _data = new T[siz]; } catch (...) {\n            _width = _height = _depth = _spectrum = 0; _data = 0;\n            throw CImgInstanceException(_cimg_instance\n                                        \"CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u).\",\n                                        cimg_instance,\n                                        cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),\n                                        size_x,size_y,size_z,size_c);\n          }\n          std::memcpy(_data,values,siz*sizeof(T));\n        }\n      } else { _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0; }\n    }",
        "output": "0",
        "idx": 2065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Wait for any event occuring either on the display \\c disp1, \\c disp2, \\c disp3, \\c disp4, ... \\c disp10.\n    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,\n                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,\n                     CImgDisplay& disp10) {\n      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =\n        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;\n      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||\n              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&\n             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&\n             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)\n        wait_all();",
        "output": "0",
        "idx": 5800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}",
        "output": "1",
        "idx": 5780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int blkid_probe_enable_partitions(blkid_probe pr, int enable)\n{\n\tpr->chains[BLKID_CHAIN_PARTS].enabled = enable;\n\treturn 0;\n}",
        "output": "0",
        "idx": 2957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_symsel(struct symsel_s *symsel, char *p)\n{\n\tchar *q;\n\tint tn, td, n;\n\n\tsymsel->bar = strtod(p, &q);\n\tif (*q >= 'a' && *q <= 'z')\n\t\tsymsel->seq = *q++ - 'a';\n\telse\n\t\tsymsel->seq = 0;\n\tif (*q == ':') {\n\t\tif (sscanf(q + 1, \"%d/%d%n\", &tn, &td, &n) != 2\n\t\t || td <= 0)\n\t\t\treturn 0;\n\t\tsymsel->time = BASE_LEN * tn / td;\n\t\tq += 1 + n;\n\t} else {\n\t\tsymsel->time = 0;\n\t}\n\treturn q;\n}",
        "output": "0",
        "idx": 4560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalMul<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n             output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(context,\n                         \"Mul only supports FLOAT32, INT32 and quantized UINT8,\"\n                         \" INT8 and INT16 now, got %d.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_key_length(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));\n}",
        "output": "0",
        "idx": 2685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n",
        "output": "0",
        "idx": 4844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cm_format_apr(struct cm_apr_msg *apr_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  enum ib_cm_apr_status status,\n\t\t\t  void *info,\n\t\t\t  u8 info_length,\n\t\t\t  const void *private_data,\n\t\t\t  u8 private_data_len)\n{\n\tcm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);\n\tapr_msg->local_comm_id = cm_id_priv->id.local_id;\n\tapr_msg->remote_comm_id = cm_id_priv->id.remote_id;\n\tapr_msg->ap_status = (u8) status;\n\n\tif (info && info_length) {\n\t\tapr_msg->info_length = info_length;\n\t\tmemcpy(apr_msg->info, info, info_length);\n\t}\n\n\tif (private_data && private_data_len)\n\t\tmemcpy(apr_msg->private_data, private_data, private_data_len);\n}",
        "output": "0",
        "idx": 5623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pmd_huge(pmd_t pmd)\n{\n\treturn !pmd_none(pmd) &&\n\t\t(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;\n}",
        "output": "0",
        "idx": 2750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoll(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; /* we _can_ in fact seek */\n}",
        "output": "1",
        "idx": 1286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n\n  RectangleInfo\n    bounds;\n\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      /*\n        the two images are the same, merge time delays and delete one.\n      */\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}",
        "output": "1",
        "idx": 989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {\n      return resize(disp.width(),disp.height(),force_redraw);\n    }",
        "output": "0",
        "idx": 4452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n",
        "output": "0",
        "idx": 2545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,\n                                              BrotliBitReader* br) {\n  uint32_t code;\n  uint32_t nbits;\n  code = ReadSymbol(table, br);\n  nbits = kBlockLengthPrefixCode[code].nbits;  /* nbits == 2..24 */\n  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);\n}",
        "output": "1",
        "idx": 5023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 2815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool LOGGER::flush_general_log()\n{\n  /*\n    Now we lock logger, as nobody should be able to use logging routines while\n    log tables are closed\n  */\n  logger.lock_exclusive();\n\n  /* Reopen general log file */\n  if (opt_log)\n    file_log_handler->get_mysql_log()->reopen_file();\n\n  /* End of log flush */\n  logger.unlock();\n\n  return 0;\n}",
        "output": "0",
        "idx": 4041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n",
        "output": "0",
        "idx": 4241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XML_SetCharacterDataHandler(XML_Parser parser,\n                            XML_CharacterDataHandler handler)\n{\n  if (parser != NULL)\n    parser->m_characterDataHandler = handler;\n}",
        "output": "0",
        "idx": 5383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "valid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 4825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void incNumConnections() override { ++num_listener_connections_; }",
        "output": "1",
        "idx": 2945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 6329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int default_lockmgr_cb(void **arg, enum AVLockOp op)\n\n{\n\n    void * volatile * mutex = arg;\n\n    int err;\n\n\n\n    switch (op) {\n\n    case AV_LOCK_CREATE:\n\n        return 0;\n\n    case AV_LOCK_OBTAIN:\n\n        if (!*mutex) {\n\n            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            if ((err = pthread_mutex_init(tmp, NULL))) {\n\n                av_free(tmp);\n\n                return AVERROR(err);\n\n            }\n\n            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {\n\n                pthread_mutex_destroy(tmp);\n\n                av_free(tmp);\n\n            }\n\n        }\n\n\n\n        if ((err = pthread_mutex_lock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_RELEASE:\n\n        if ((err = pthread_mutex_unlock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_DESTROY:\n\n        if (*mutex)\n\n            pthread_mutex_destroy(*mutex);\n\n        av_free(*mutex);\n\n        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n",
        "output": "1",
        "idx": 766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "statement_cleanup(statement *stmt)\n{\n  statement *ptr, *nptr;\n  if (!stmt)\n    return;\n\n  for (ptr= stmt; ptr; ptr= nptr)\n  {\n    nptr= ptr->next;\n    if (ptr->string)\n      my_free(ptr->string, MYF(0)); \n    my_free(ptr, MYF(0));\n  }\n}",
        "output": "0",
        "idx": 4360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n",
        "output": "1",
        "idx": 3325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,\n\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t struct sock *sk, gfp_t gfp)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);\n\n\tif (!retval)\n\t\tgoto nodata;\n\tif (!sk)\n\t\tpr_debug(\"%s: chunkifying skb:%p w/o an sk\\n\", __func__, skb);\n\n\tINIT_LIST_HEAD(&retval->list);\n\tretval->skb\t\t= skb;\n\tretval->asoc\t\t= (struct sctp_association *)asoc;\n\tretval->singleton\t= 1;\n\n\tretval->fast_retransmit = SCTP_CAN_FRTX;\n\n\t/* Polish the bead hole.  */\n\tINIT_LIST_HEAD(&retval->transmitted_list);\n\tINIT_LIST_HEAD(&retval->frag_list);\n\tSCTP_DBG_OBJCNT_INC(chunk);\n\trefcount_set(&retval->refcnt, 1);\n\nnodata:\n\treturn retval;\n}",
        "output": "0",
        "idx": 4108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dataiterator_skip_attribute(Dataiterator *di)\n{\n  if (di->state == di_nextsolvableattr)\n    di->state = di_nextsolvablekey;\n  else\n    di->state = di_nextkey;\n}",
        "output": "0",
        "idx": 5656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)\n{\n    if (ga_is_frozen(ga_state)) {\n        return GUEST_FSFREEZE_STATUS_FROZEN;\n    }\n\n    return GUEST_FSFREEZE_STATUS_THAWED;\n}",
        "output": "0",
        "idx": 5770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)\n{\n\tState *state;\n\tbool ret = false;\n\n\tif (!p11_virtual_is_wrapper (module))\n\t\treturn false;\n\n\tp11_lock ();\n\tfor (state = all_instances; state != NULL; state = state->next)\n\t\tif (state->wrapped == module) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\tp11_unlock ();\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)\n{\n\treturn hdr->ip_version >> 4;\n}",
        "output": "0",
        "idx": 5084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_before_set(VALUE self, VALUE space_before)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space_before, T_STRING);\n    len = RSTRING_LEN(space_before);\n    if (len == 0) {\n        if (state->space_before) {\n            ruby_xfree(state->space_before);\n            state->space_before = NULL;\n            state->space_before_len = 0;\n        }\n    } else {\n        if (state->space_before) ruby_xfree(state->space_before);\n        state->space_before = strdup(RSTRING_PTR(space_before));\n        state->space_before_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 3523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 2348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "writeTarData(\n#ifdef HAVE_LIBZ\n\t\t\t gzFile ztarfile,\n#endif\n\t\t\t FILE *tarfile, char *buf, int r, char *current_file)\n{\n#ifdef HAVE_LIBZ\n\tif (ztarfile != NULL)\n\t{\n\t\tif (gzwrite(ztarfile, buf, r) != r)\n\t\t{\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"%s: could not write to compressed file \\\"%s\\\": %s\\n\"),\n\t\t\t\t\tprogname, current_file, get_gz_error(ztarfile));\n\t\t\tdisconnect_and_exit(1);\n\t\t}\n\t}\n\telse\n#endif\n\t{\n\t\tif (fwrite(buf, r, 1, tarfile) != 1)\n\t\t{\n\t\t\tfprintf(stderr, _(\"%s: could not write to file \\\"%s\\\": %s\\n\"),\n\t\t\t\t\tprogname, current_file, strerror(errno));\n\t\t\tdisconnect_and_exit(1);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 4442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n",
        "output": "1",
        "idx": 4907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n",
        "output": "1",
        "idx": 2954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dummy_data_cb (void *opaque, const void *buffer, size_t length)\n{\n  (void)opaque;\n  (void)buffer;\n  (void)length;\n  return 0;\n}",
        "output": "0",
        "idx": 3450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n\n{\n\n    cirrus_fill_t rop_func;\n\n\n\n    if (blit_is_unsafe(s)) {\n\n        return 0;\n\n    }\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\n             s->cirrus_blt_dstpitch,\n\n             s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t     s->cirrus_blt_height);\n\n    cirrus_bitblt_reset(s);\n\n    return 1;\n\n}\n",
        "output": "1",
        "idx": 897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {\n    xmlXPathObjectPtr ret;\n\n    if (start == NULL)\n\treturn(NULL);\n    if (end == NULL)\n\treturn(NULL);\n\n    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n    if (ret == NULL) {\n        xmlXPtrErrMemory(\"allocating range\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n    ret->type = XPATH_RANGE;\n    ret->user = start;\n    ret->index = -1;\n    ret->user2 = end;\n    ret->index2 = -1;\n    xmlXPtrRangeCheckOrder(ret);\n    return(ret);\n}",
        "output": "1",
        "idx": 3007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}",
        "output": "1",
        "idx": 143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n",
        "output": "0",
        "idx": 4416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool is_valid_option_list(const char *param)\n\n{\n\n    size_t buflen = strlen(param) + 1;\n\n    char *buf = g_malloc(buflen);\n\n    const char *p = param;\n\n    bool result = true;\n\n\n\n    while (*p) {\n\n        p = get_opt_value(buf, buflen, p);\n\n        if (*p && !*++p) {\n\n            result = false;\n\n            goto out;\n\n        }\n\n\n\n        if (!*buf || *buf == ',') {\n\n            result = false;\n\n            goto out;\n\n        }\n\n    }\n\n\n\nout:\n\n    free(buf);\n\n    return result;\n\n}\n",
        "output": "0",
        "idx": 1676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_write_guest_virt_system(gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_write_guest(vcpu->kvm, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}",
        "output": "0",
        "idx": 29
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n",
        "output": "1",
        "idx": 2345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n",
        "output": "1",
        "idx": 1259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,\n                                    const TfLiteTensor* input,\n                                    const TfLiteTensor* filter,\n                                    int16* depth_multiplier) {\n  int num_filter_channels = SizeOfDimension(filter, 3);\n  int num_input_channels = SizeOfDimension(input, 3);\n  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);\n\n  *depth_multiplier = num_filter_channels / num_input_channels;\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 5089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void setCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {\n        return;\n    }\n\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);\n}",
        "output": "0",
        "idx": 4740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 95
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)\n\n{\n\n    int i;\n\n    for (i = 0; i < width; i++) {\n\n        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
        "output": "0",
        "idx": 5107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n\n    if (!server || !prefix)\n        return;\n\n    /* free previous values */\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n\n    /* assign new values */\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 4463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Release(void *ctx)\n\n{\n\n    ContextInfo *ci;\n\n    ci = (ContextInfo *) ctx;\n\n\n\n    if (ci->cache) {\n\n        imlib_context_set_image(ci->cache->image);\n\n        imlib_free_image();\n\n        av_free(ci->cache);\n\n    }\n\n    if (ctx) {\n\n        if (ci->imageOverlaid) {\n\n            imlib_context_set_image(ci->imageOverlaid);\n\n            imlib_free_image();\n\n        }\n\n        ff_eval_free(ci->expr_x);\n\n        ff_eval_free(ci->expr_y);\n\n        ff_eval_free(ci->expr_R);\n\n        ff_eval_free(ci->expr_G);\n\n        ff_eval_free(ci->expr_B);\n\n        sws_freeContext(ci->toRGB_convert_ctx);\n\n        sws_freeContext(ci->fromRGB_convert_ctx);\n\n        av_free(ctx);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        if (window->priv->lock_pid > 0) {\n                gs_window_dialog_finish (window);\n        }\n\n        remove_popup_dialog_idle (window);\n        remove_command_watches (window);\n        remove_watchdog_timer (window);\n\n        if (window->priv->lock_box != NULL) {\n                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));\n                window->priv->lock_box = NULL;\n\n                g_signal_emit (window, signals [DIALOG_DOWN], 0);\n        }\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}",
        "output": "1",
        "idx": 3246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "1",
        "idx": 1931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)\n{\n\tint status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,\n\t\t\t\t    &data->arg.seq_args, &data->res.seq_res, 1);\n\tif (status == 0) {\n\t\tupdate_changeattr(dir, &data->res.dir_cinfo);\n\t\tnfs_post_op_update_inode(dir, data->res.dir_fattr);\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\t}\n\treturn status;\n}",
        "output": "0",
        "idx": 3939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "errno_t sssctl_logs_remove(struct sss_cmdline *cmdline,\n                           struct sss_tool_ctx *tool_ctx,\n                           void *pvt)\n{\n    struct sssctl_logs_opts opts = {0};\n    errno_t ret;\n\n    /* Parse command line. */\n    struct poptOption options[] = {\n        {\"delete\", 'd', POPT_ARG_NONE, &opts.delete, 0, _(\"Delete log files instead of truncating\"), NULL },\n        POPT_TABLEEND\n    };\n\n    ret = sss_tool_popt(cmdline, options, SSS_TOOL_OPT_OPTIONAL, NULL, NULL);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_CRIT_FAILURE, \"Unable to parse command arguments\\n\");\n        return ret;\n    }\n\n    if (opts.delete) {\n        PRINT(\"Deleting log files...\\n\");\n        ret = sss_remove_subtree(LOG_PATH);\n        if (ret != EOK) {\n            ERROR(\"Unable to remove log files\\n\");\n            return ret;\n        }\n\n        sss_signal(SIGHUP);\n    } else {\n        PRINT(\"Truncating log files...\\n\");\n        ret = sssctl_run_command(\"truncate --no-create --size 0 \" LOG_FILES);\n        if (ret != EOK) {\n            ERROR(\"Unable to truncate log files\\n\");\n            return ret;\n        }\n    }\n\n    return EOK;\n}",
        "output": "1",
        "idx": 1178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}",
        "output": "1",
        "idx": 5536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Panic(const char *fmtstr, ...)\n{\n   /* Ignored */\n   sLog(log_warning, \"Panic callback invoked. \\n\");\n   exit(1);\n}",
        "output": "1",
        "idx": 571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanCheck(const sraSpan *span, const char *text) {\n  /* Check the span is valid! */\n  if (span->start == span->end) {\n    printf(text); \n    printf(\":%d-%d\\n\", span->start, span->end);\n  }\n}",
        "output": "0",
        "idx": 5947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dse_delete_plugin(Slapi_Entry *entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\") ||\n        slapi_entry_attr_hasvalue(entry, \"nsslapd-PluginEnabled\", \"off\") ||\n        !config_get_dynamic_plugins()) {\n        /*\n         * This is not a plugin, this plugin was not enabled to begin with, or we\n         * are not allowing dynamic updates .\n         */\n        return rc;\n    }\n    rc = plugin_delete(entry, returntext, 0 /* not locked */);\n\n    return rc;\n}",
        "output": "0",
        "idx": 3057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n\n    int i, dc = (block[0] + 15) >> 5;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += line_size;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n",
        "output": "0",
        "idx": 2277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "opj_bool j2k_write_eoc_v2(\topj_j2k_v2_t *p_j2k,\n\t\t\t\t\t\t\tstruct opj_stream_private *p_stream,\n\t\t\t\t\t\t\tstruct opj_event_mgr * p_manager )\n{\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\tassert(p_stream != 00);\n\t\n\topj_write_bytes(p_j2k->m_specific_param.m_encoder.m_header_tile_data,J2K_MS_EOC,2);\t\t\t\t\t/* EOC */\n\t\n\n/* UniPG>> */\n#ifdef USE_JPWL\n\t/* update markers struct */\n\t/*\n\tj2k_add_marker(p_j2k->cstr_info, J2K_MS_EOC, p_stream_tell(p_stream) - 2, 2);\n*/\n#endif /* USE_JPWL */\n\n\tif ( opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,2,p_manager) != 2) {\n\t\treturn OPJ_FALSE;\n\t}\n\n\tif ( ! opj_stream_flush(p_stream,p_manager) ) {\n\t\treturn OPJ_FALSE;\n\t}\n\n\treturn OPJ_TRUE;\n}",
        "output": "0",
        "idx": 1111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }",
        "output": "0",
        "idx": 6101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n",
        "output": "0",
        "idx": 628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n",
        "output": "1",
        "idx": 565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __init early_fixup_exception(unsigned long *ip)\n{\n\tconst struct exception_table_entry *fixup;\n\tunsigned long new_ip;\n\n\tfixup = search_exception_tables(*ip);\n\tif (fixup) {\n\t\tnew_ip = ex_fixup_addr(fixup);\n\n\t\tif (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {\n\t\t\t/* uaccess handling not supported during early boot */\n\t\t\treturn 0;\n\t\t}\n\n\t\t*ip = new_ip;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 5087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\n      static double mp_dot(_cimg_math_parser& mp) {\n        const unsigned int siz = (unsigned int)mp.opcode[4];\n        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).\n          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));",
        "output": "0",
        "idx": 4438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n",
        "output": "0",
        "idx": 5957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 5944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Header headerFree(Header h)\n{\n    (void) headerUnlink(h);\n\n    if (h == NULL || h->nrefs > 0)\n\treturn NULL;\n\n    if (h->index) {\n\tindexEntry entry = h->index;\n\tint i;\n\tfor (i = 0; i < h->indexUsed; i++, entry++) {\n\t    if ((h->flags & HEADERFLAG_ALLOCATED) && ENTRY_IS_REGION(entry)) {\n\t\tif (entry->length > 0) {\n\t\t    int32_t * ei = entry->data;\n\t\t    if ((ei - 2) == h->blob) h->blob = _free(h->blob);\n\t\t    entry->data = NULL;\n\t\t}\n\t    } else if (!ENTRY_IN_REGION(entry)) {\n\t\tentry->data = _free(entry->data);\n\t    }\n\t    entry->data = NULL;\n\t}\n\th->index = _free(h->index);\n    }\n\n    h = _free(h);\n    return NULL;\n}",
        "output": "0",
        "idx": 1436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)\n\n{\n\n    OfDpaFlow *flow;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;\n\n\n\n    flow = g_new0(OfDpaFlow, 1);\n\n    if (!flow) {\n\n        return NULL;\n\n    }\n\n\n\n    flow->cookie = cookie;\n\n    flow->mask.tbl_id = 0xffffffff;\n\n\n\n    flow->stats.install_time = flow->stats.refresh_time = now;\n\n\n\n    return flow;\n\n}\n",
        "output": "1",
        "idx": 4300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL rdp_security_stream_init(rdpRdp* rdp, wStream* s, BOOL sec_header)\n{\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tif (rdp->do_crypt)\n\t{\n\t\tif (!Stream_SafeSeek(s, 12))\n\t\t\treturn FALSE;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t{\n\t\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_header)\n\t{\n\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 2096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\n\tspin_lock_init(&port->dev_list_lock);\n}",
        "output": "1",
        "idx": 5701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n",
        "output": "0",
        "idx": 5509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n",
        "output": "1",
        "idx": 3206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}",
        "output": "1",
        "idx": 4457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n",
        "output": "1",
        "idx": 5471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n",
        "output": "1",
        "idx": 6103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "runMainLoop(WorkingObjects &wo) {\n\tev::io feedbackFdWatcher(eventLoop);\n\tev::sig sigintWatcher(eventLoop);\n\tev::sig sigtermWatcher(eventLoop);\n\tev::sig sigquitWatcher(eventLoop);\n\t\n\tif (feedbackFdAvailable()) {\n\t\tfeedbackFdWatcher.set<&feedbackFdBecameReadable>();\n\t\tfeedbackFdWatcher.start(FEEDBACK_FD, ev::READ);\n\t\twriteArrayMessage(FEEDBACK_FD, \"initialized\", NULL);\n\t}\n\tsigintWatcher.set<&caughtExitSignal>();\n\tsigintWatcher.start(SIGINT);\n\tsigtermWatcher.set<&caughtExitSignal>();\n\tsigtermWatcher.start(SIGTERM);\n\tsigquitWatcher.set<&printInfo>();\n\tsigquitWatcher.start(SIGQUIT);\n\t\n\tP_WARN(\"PassengerLoggingAgent online, listening at \" << socketAddress);\n\tev_run(eventLoop, 0);\n}",
        "output": "1",
        "idx": 3686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdk_pixbuf_copy (const GdkPixbuf *pixbuf)\n{\n\tguchar *buf;\n\tint size;\n\n\tg_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);\n\n\t/* Calculate a semi-exact size.  Here we copy with full rowstrides;\n\t * maybe we should copy each row individually with the minimum\n\t * rowstride?\n\t */\n\n\tsize = gdk_pixbuf_get_byte_length (pixbuf);\n\n\tbuf = g_try_malloc (size * sizeof (guchar));\n\tif (!buf)\n\t\treturn NULL;\n\n\tmemcpy (buf, pixbuf->pixels, size);\n\n\treturn gdk_pixbuf_new_from_data (buf,\n\t\t\t\t\t pixbuf->colorspace, pixbuf->has_alpha,\n\t\t\t\t\t pixbuf->bits_per_sample,\n\t\t\t\t\t pixbuf->width, pixbuf->height,\n\t\t\t\t\t pixbuf->rowstride,\n\t\t\t\t\t free_buffer,\n\t\t\t\t\t NULL);\n}",
        "output": "1",
        "idx": 3625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_swevent_init_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\thrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thwc->hrtimer.function = perf_swevent_hrtimer;\n\n\t/*\n\t * Since hrtimers have a fixed rate, we can do a static freq->period\n\t * mapping and avoid the whole period adjust feedback stuff.\n\t */\n\tif (event->attr.freq) {\n\t\tlong freq = event->attr.sample_freq;\n\n\t\tevent->attr.sample_period = NSEC_PER_SEC / freq;\n\t\thwc->sample_period = event->attr.sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t\thwc->last_period = hwc->sample_period;\n\t\tevent->attr.freq = 0;\n\t}\n}",
        "output": "0",
        "idx": 5176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct device *device_find_child(struct device *parent, void *data,\n\t\t\t\t int (*match)(struct device *dev, void *data))\n{\n\tstruct klist_iter i;\n\tstruct device *child;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tklist_iter_init(&parent->p->klist_children, &i);\n\twhile ((child = next_device(&i)))\n\t\tif (match(child, data) && get_device(child))\n\t\t\tbreak;\n\tklist_iter_exit(&i);\n\treturn child;\n}",
        "output": "0",
        "idx": 2027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,\n\n                        const char *default_devaddr)\n\n{\n\n    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;\n\n    PCIDevice *pci_dev;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);\n\n    pci_dev = pci_create(pci_nic_names[i], devaddr);\n\n    dev = &pci_dev->qdev;\n\n    if (nd->id)\n\n        dev->id = qemu_strdup(nd->id);\n\n    dev->nd = nd;\n\n    qdev_init(dev);\n\n    nd->private = dev;\n\n    return pci_dev;\n\n}\n",
        "output": "1",
        "idx": 2621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void  Ins_ALIGNRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance;\n    (void)args;\n\n    if ( CUR.top < CUR.GS.loop )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    while ( CUR.GS.loop > 0 )\n    {\n      CUR.args--;\n\n      point = (Int)CUR.stack[CUR.args];\n\n      if ( BOUNDS( point, CUR.zp1.n_points ) )\n      {\n        CUR.error = TT_Err_Invalid_Reference;\n        return;\n      }\n\n      distance = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                     CUR.zp0.cur_x[CUR.GS.rp0],\n                                   CUR.zp1.cur_y[point] -\n                                     CUR.zp0.cur_y[CUR.GS.rp0] );\n\n      CUR_Func_move( &CUR.zp1, point, -distance );\n      CUR.GS.loop--;\n    }\n\n    CUR.GS.loop = 1;\n    CUR.new_top = CUR.args;\n  }",
        "output": "0",
        "idx": 2068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n",
        "output": "0",
        "idx": 3914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Item *Item_decimal::neg(THD *thd)\n{\n  my_decimal_neg(&decimal_value);\n  unsigned_flag= 0;\n  name= 0;\n  max_length= my_decimal_precision_to_length_no_truncation(\n                      decimal_value.intg + decimals, decimals, unsigned_flag);\n  return this;\n}",
        "output": "0",
        "idx": 4967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mv_GenerateOper(StringInfo buf, Oid opoid)\n{\n\tHeapTuple\topertup;\n\tForm_pg_operator operform;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));\n\tif (!HeapTupleIsValid(opertup))\n\t\telog(ERROR, \"cache lookup failed for operator %u\", opoid);\n\toperform = (Form_pg_operator) GETSTRUCT(opertup);\n\tAssert(operform->oprkind == 'b');\n\n\tappendStringInfo(buf, \"OPERATOR(%s.%s)\",\n\t\t\t\tquote_identifier(get_namespace_name(operform->oprnamespace)),\n\t\t\t\t\t NameStr(operform->oprname));\n\n\tReleaseSysCache(opertup);\n}",
        "output": "0",
        "idx": 188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding extended_master_secret \"\n                        \"extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}",
        "output": "0",
        "idx": 4415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t rebind_store(struct device_driver *dev, const char *buf,\n\t\t\t\t size_t count)\n{\n\tint ret;\n\tint len;\n\tstruct bus_id_priv *bid;\n\n\t/* buf length should be less that BUSID_SIZE */\n\tlen = strnlen(buf, BUSID_SIZE);\n\n\tif (!(len < BUSID_SIZE))\n\t\treturn -EINVAL;\n\n\tbid = get_busid_priv(buf);\n\tif (!bid)\n\t\treturn -ENODEV;\n\n\t/* mark the device for deletion so probe ignores it during rescan */\n\tbid->status = STUB_BUSID_OTHER;\n\n\tret = do_rebind((char *) buf, bid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* delete device from busid_table */\n\tdel_match_busid((char *) buf);\n\n\treturn count;\n}",
        "output": "1",
        "idx": 5189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int input_scancode_to_scalar(const struct input_keymap_entry *ke,\n\t\t\t     unsigned int *scancode)\n{\n\tswitch (ke->len) {\n\tcase 1:\n\t\t*scancode = *((u8 *)ke->scancode);\n\t\tbreak;\n\n\tcase 2:\n\t\t*scancode = *((u16 *)ke->scancode);\n\t\tbreak;\n\n\tcase 4:\n\t\t*scancode = *((u32 *)ke->scancode);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}",
        "output": "1",
        "idx": 6029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n",
        "output": "1",
        "idx": 5985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean id_match_value(gpointer key, gpointer value, gpointer user_data)\n{\n  if (value == *(gpointer *)user_data) {\n\t*(int *)user_data = (uintptr_t)key;\n\treturn true;\n  }\n  return false;\n}",
        "output": "0",
        "idx": 2240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}",
        "output": "1",
        "idx": 3363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}",
        "output": "1",
        "idx": 2225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_socket_client_tls_handshake_callback (GObject      *object,\n\t\t\t\t\tGAsyncResult *result,\n\t\t\t\t\tgpointer      user_data)\n{\n  GSocketClientAsyncConnectData *data = user_data;\n\n  if (g_tls_connection_handshake_finish (G_TLS_CONNECTION (object),\n\t\t\t\t\t result,\n\t\t\t\t\t &data->last_error))\n    {\n      g_object_unref (data->connection);\n      data->connection = G_IO_STREAM (object);\n\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_TLS_HANDSHAKED, data->connectable, data->connection);\n      g_socket_client_async_connect_complete (data);\n    }\n  else\n    {\n      g_object_unref (object);\n      enumerator_next_async (data);\n    }\n}",
        "output": "1",
        "idx": 3388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)\n{\n\tif (implementor->type == ZEND_USER_CLASS &&\n\t\t!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&\n\t\t!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)\n\t) {\n\t\tzend_error(E_ERROR, \"DateTimeInterface can't be implemented by user classes\");\n\t}\n\n\treturn SUCCESS;",
        "output": "0",
        "idx": 1034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n",
        "output": "1",
        "idx": 5094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\trefcount_inc(&fc->count);\n\treturn fc;\n}",
        "output": "0",
        "idx": 5876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,\n    njs_value_t *retval)\n{\n    njs_array_t     *array;\n    njs_value_t     *value;\n    njs_jump_off_t  ret;\n\n    static const njs_function_t  concat = {\n          .native = 1,\n          .args_offset = 1,\n          .u.native = njs_string_prototype_concat\n    };\n\n    value = njs_scope_valid_value(vm, (njs_index_t) retval);\n\n    if (!njs_is_primitive(value)) {\n        array = njs_array(value);\n\n        ret = njs_function_frame(vm, (njs_function_t *) &concat,\n                                 &njs_string_empty, array->start,\n                                 array->length, 0);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        ret = njs_function_frame_invoke(vm, value);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return sizeof(njs_vmcode_template_literal_t);\n}",
        "output": "0",
        "idx": 5218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qb_log_blackbox_write_to_file(const char *filename)\n{\n\tssize_t written_size = 0;\n\tstruct qb_log_target *t;\n\tstruct _blackbox_file_header header;\n\tint fd = open(filename, O_CREAT | O_RDWR | O_EXCL, 0700);\n\n\tif (fd < 0) {\n\t\treturn -errno;\n\t}\n\n\t/* Write header, so we know this is a 'new' format blackbox */\n\theader.word_size = QB_BLACKBOX_HEADER_WORDSIZE;\n\theader.read_pt   = QB_BLACKBOX_HEADER_READPT;\n\theader.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;\n\theader.version   = QB_BLACKBOX_HEADER_VERSION;\n\theader.hash      = QB_BLACKBOX_HEADER_HASH;\n\twritten_size = write(fd, &header, sizeof(header));\n\tif (written_size < sizeof(header)) {\n\t\tclose(fd);\n\t\treturn written_size;\n\t}\n\n\tt = qb_log_target_get(QB_LOG_BLACKBOX);\n\tif (t->instance) {\n\t\twritten_size += qb_rb_write_to_file(t->instance, fd);\n\t} else {\n\t\twritten_size = -ENOENT;\n\t}\n\tclose(fd);\n\n\treturn written_size;\n}",
        "output": "1",
        "idx": 6087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_image_rva_map (MonoImage *image, guint32 addr)\n{\n\tMonoCLIImageInfo *iinfo = image->image_info;\n\tconst int top = iinfo->cli_section_count;\n\tMonoSectionTable *tables = iinfo->cli_section_tables;\n\tint i;\n\t\n\tfor (i = 0; i < top; i++){\n\t\tif ((addr >= tables->st_virtual_address) &&\n\t\t    (addr < tables->st_virtual_address + tables->st_raw_data_size)){\n\t\t\tif (!iinfo->cli_sections [i]) {\n\t\t\t\tif (!mono_image_ensure_section_idx (image, i))\n\t\t\t\t\treturn NULL;\n\t\t\t}\n#ifdef HOST_WIN32\n\t\t\tif (image->is_module_handle)\n\t\t\t\treturn image->raw_data + addr;\n#endif\n\t\t\treturn (char*)iinfo->cli_sections [i] +\n\t\t\t\t(addr - tables->st_virtual_address);\n\t\t}\n\t\ttables++;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int link_set_ipv4_forward(Link *link) {\n        const char *p = NULL, *v;\n        int r;\n\n        if (link->flags & IFF_LOOPBACK)\n                return 0;\n\n        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)\n                return 0;\n\n        p = strjoina(\"/proc/sys/net/ipv4/conf/\", link->ifname, \"/forwarding\");\n        v = one_zero(link_ipv4_forward_enabled(link));\n\n        r = write_string_file(p, v, 0);\n        if (r < 0) {\n                /* If the right value is set anyway, don't complain */\n                if (verify_one_line_file(p, v) > 0)\n                        return 0;\n\n                log_link_warning_errno(link, r, \"Cannot configure IPv4 forwarding for interface %s: %m\", link->ifname);\n        }\n\n        return 0;\n}",
        "output": "0",
        "idx": 610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}",
        "output": "1",
        "idx": 5940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iobuf_temp_with_content (const char *buffer, size_t length)\n{\n  iobuf_t a;\n\n  a = iobuf_alloc (3, length);\n  memcpy (a->d.buf, buffer, length);\n  a->d.len = length;\n\n  return a;\n}",
        "output": "1",
        "idx": 1803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t helper_fcmp_un(uint32_t a, uint32_t b)\n\n{\n\n    CPU_FloatU fa, fb;\n\n    uint32_t r = 0;\n\n\n\n    fa.l = a;\n\n    fb.l = b;\n\n\n\n    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {\n\n        update_fpu_flags(float_flag_invalid);\n\n        r = 1;\n\n    }\n\n\n\n    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {\n\n        r = 1;\n\n    }\n\n\n\n    return r;\n\n}\n",
        "output": "0",
        "idx": 5109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tWARN_ONCE(1, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->AddrB_port)\n\t\treturn;\n\n\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\n}",
        "output": "0",
        "idx": 3771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static irqreturn_t gfar_transmit(int irq, void *grp_id)\n{\n\tstruct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;\n\tunsigned long flags;\n\tu32 imask;\n\n\tif (likely(napi_schedule_prep(&grp->napi_tx))) {\n\t\tspin_lock_irqsave(&grp->grplock, flags);\n\t\timask = gfar_read(&grp->regs->imask);\n\t\timask &= IMASK_TX_DISABLED;\n\t\tgfar_write(&grp->regs->imask, imask);\n\t\tspin_unlock_irqrestore(&grp->grplock, flags);\n\t\t__napi_schedule(&grp->napi_tx);\n\t} else {\n\t\t/* Clear IEVENT, so interrupts aren't called again\n\t\t * because of the packets that have already arrived.\n\t\t */\n\t\tgfar_write(&grp->regs->ievent, IEVENT_TX_MASK);\n\t}\n\n\treturn IRQ_HANDLED;\n}",
        "output": "0",
        "idx": 1167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AuthorizationManagerImpl::_invalidateRelevantCacheData(const char* op,\n                                                            const NamespaceString& ns,\n                                                            const BSONObj& o,\n                                                            const BSONObj* o2) {\n    if (ns == AuthorizationManager::rolesCollectionNamespace ||\n        ns == AuthorizationManager::versionCollectionNamespace) {\n        invalidateUserCache();\n        return;\n    }\n\n    if (*op == 'i' || *op == 'd' || *op == 'u') {\n        // If you got into this function isAuthzNamespace() must have returned true, and we've\n        // already checked that it's not the roles or version collection.\n        invariant(ns == AuthorizationManager::usersCollectionNamespace);\n\n        StatusWith<UserName> userName = (*op == 'u')\n            ? extractUserNameFromIdString((*o2)[\"_id\"].str())\n            : extractUserNameFromIdString(o[\"_id\"].str());\n\n        if (!userName.isOK()) {\n            warning() << \"Invalidating user cache based on user being updated failed, will \"\n                         \"invalidate the entire cache instead: \"\n                      << userName.getStatus();\n            invalidateUserCache();\n            return;\n        }\n        invalidateUserByName(userName.getValue());\n    } else {\n        invalidateUserCache();\n    }\n}",
        "output": "0",
        "idx": 5577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}",
        "output": "1",
        "idx": 767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usb_host_init(void)\n\n{\n\n    const struct libusb_pollfd **poll;\n\n    int i, rc;\n\n\n\n    if (ctx) {\n\n        return 0;\n\n    }\n\n    rc = libusb_init(&ctx);\n\n    if (rc != 0) {\n\n        return -1;\n\n    }\n\n    libusb_set_debug(ctx, loglevel);\n\n\n\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n\n                                usb_host_del_fd,\n\n                                ctx);\n\n    poll = libusb_get_pollfds(ctx);\n\n    if (poll) {\n\n        for (i = 0; poll[i] != NULL; i++) {\n\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n\n        }\n\n    }\n\n    free(poll);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 2207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            /* module check */\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n\n            /* direct name check */\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}",
        "output": "1",
        "idx": 4897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n",
        "output": "0",
        "idx": 369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n\n  return (filename);\n}",
        "output": "1",
        "idx": 1006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr6_table **mrt)\n{\n\tint err;\n\tstruct ip6mr_result res;\n\tstruct fib_lookup_arg arg = {\n\t\t.result = &res,\n\t\t.flags = FIB_LOOKUP_NOREF,\n\t};\n\n\terr = fib_rules_lookup(net->ipv6.mr6_rules_ops,\n\t\t\t       flowi6_to_flowi(flp6), 0, &arg);\n\tif (err < 0)\n\t\treturn err;\n\t*mrt = res.mrt;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}",
        "output": "1",
        "idx": 2315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n",
        "output": "1",
        "idx": 4864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(MultipleIterator, valid)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it, *retval = NULL;\n\tlong                         expect, valid;\n\n\tintern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!zend_hash_num_elements(&intern->storage)) {\n\t\tRETURN_FALSE;\n\t}\n\n\texpect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {\n\t\tit = element->obj;\n\t\tzend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, \"valid\", &retval);\n\n\t\tif (retval) {\n\t\t\tvalid = Z_LVAL_P(retval);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t} else {\n\t\t\tvalid = 0;\n\t\t}\n\n\t\tif (expect != valid) {\n\t\t\tRETURN_BOOL(!expect);\n\t\t}\n\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n\n\tRETURN_BOOL(expect);\n}",
        "output": "1",
        "idx": 85
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_settabvar(typval_T *argvars, typval_T *rettv)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    rettv->vval.v_number = 0;\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc((unsigned)STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\t/* Restore current tabpage */\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}",
        "output": "1",
        "idx": 3807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}",
        "output": "1",
        "idx": 5040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_visitor_out_string(TestOutputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    char *string = (char *) \"Q E M U\";\n\n    Error *err = NULL;\n\n    QObject *obj;\n\n\n\n    visit_type_str(data->ov, &string, NULL, &err);\n\n    g_assert(!err);\n\n\n\n    obj = qmp_output_get_qobject(data->qov);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);\n\n\n\n    qobject_decref(obj);\n\n}\n",
        "output": "0",
        "idx": 4357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        //need more data!\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n\n    //\u63e1\u624b\u7ed3\u675f\uff0c\u8fdb\u5165\u547d\u4ee4\u6a21\u5f0f\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}",
        "output": "0",
        "idx": 2397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dev_match_devt(struct device *dev, void *data)\n{\n\tdev_t *devt = data;\n\treturn dev->devt == *devt;\n}",
        "output": "0",
        "idx": 2484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "output": "0",
        "idx": 1749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned etag_match(const char *hdr[], const char *etag)\n{\n    unsigned i, match = 0;\n    tok_t tok;\n    char *token;\n\n    for (i = 0; !match && hdr[i]; i++) {\n\ttok_init(&tok, hdr[i], \",\", TOK_TRIMLEFT|TOK_TRIMRIGHT);\n\twhile (!match && (token = tok_next(&tok))) {\n\t    if (!etagcmp(token, etag)) match = 1;\n\t}\n\ttok_fini(&tok);\n    }\n\n    return match;\n}",
        "output": "0",
        "idx": 4425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}",
        "output": "1",
        "idx": 3292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, setInfoClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileInfo;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->info_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 1214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ModuleTypeList *find_type(module_init_type type)\n\n{\n\n    ModuleTypeList *l;\n\n\n\n    init_types();\n\n\n\n    l = &init_type_list[type];\n\n\n\n    return l;\n\n}\n",
        "output": "0",
        "idx": 5638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n",
        "output": "1",
        "idx": 2727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}",
        "output": "1",
        "idx": 6163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline CmdLine::CmdLine() :\n        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),\n        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),\n        configsvr(false), quota(false), quotaFiles(8), cpu(false),\n        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),\n        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),\n        syncdelay(60), noUnixSocket(false), doFork(0), socket(\"/tmp\"), maxConns(DEFAULT_MAX_CONN),\n        logAppend(false), logWithSyslog(false)\n    {\n        started = time(0);\n\n        journalCommitInterval = 0; // 0 means use default\n        dur = false;\n#if defined(_DURABLEDEFAULTON)\n        dur = true;\n#endif\n        if( sizeof(void*) == 8 )\n            dur = true;\n#if defined(_DURABLEDEFAULTOFF)\n        dur = false;\n#endif\n\n#ifdef MONGO_SSL\n        sslOnNormalPorts = false;\n#endif\n    }",
        "output": "1",
        "idx": 4725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n",
        "output": "1",
        "idx": 544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n",
        "output": "1",
        "idx": 2604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void uninit(AVFilterContext *ctx)\n\n{\n\n    ZScaleContext *s = ctx->priv;\n\n\n\n    zimg_filter_graph_free(s->graph);\n\n\n    av_freep(&s->tmp);\n\n    s->tmp_size = 0;\n\n}",
        "output": "1",
        "idx": 5861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,\n                         gsize        *len_out)\n{\n  gsize len = bwrap->fds->len;\n  int *res = (int *) g_array_free (bwrap->fds, FALSE);\n\n  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));\n  *len_out = len;\n  return res;\n}",
        "output": "0",
        "idx": 3570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int amr_wb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRWBContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 16000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 16000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->last_bitrate    = avctx->bit_rate;\n\n\n\n    avctx->frame_size  = 320;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->state     = E_IF_init();\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 1565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ModuleExport void UnregisterCALSImage(void)\n{\n  (void) UnregisterMagickInfo(\"CAL\");\n  (void) UnregisterMagickInfo(\"CALS\");\n}",
        "output": "0",
        "idx": 4050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    FWCfgState *s = opaque;\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)\n\n        || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n",
        "output": "0",
        "idx": 4277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      static double mp_log10(_cimg_math_parser& mp) {\n        return std::log10(_mp_arg(2));\n      }",
        "output": "0",
        "idx": 1306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; /* We wrote to 4 extra bytes from the header */\n\n}\n",
        "output": "0",
        "idx": 4486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void p54u_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *dev = usb_get_intfdata(intf);\n\tstruct p54u_priv *priv;\n\n\tif (!dev)\n\t\treturn;\n\n\tpriv = dev->priv;\n\twait_for_completion(&priv->fw_wait_load);\n\tp54_unregister_common(dev);\n\n\tusb_put_dev(interface_to_usbdev(intf));\n\trelease_firmware(priv->fw);\n\tp54_free_common(dev);\n}",
        "output": "1",
        "idx": 4604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)\n{\n  int r;\n#define CMP_FIELD(field) do {                   \\\n    if (a->field != b->field) {                 \\\n      return 0;                                 \\\n    }                                           \\\n  } while (0)\n  CMP_FIELD(policy_type);\n  CMP_FIELD(is_private);\n  /* refcnt and is_canonical are irrelevant to equality,\n   * they are hash table implementation details */\n  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))\n    return 0;\n  CMP_FIELD(maskbits);\n  CMP_FIELD(prt_min);\n  CMP_FIELD(prt_max);\n#undef CMP_FIELD\n  return 1;\n}",
        "output": "0",
        "idx": 2369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)\n\n{\n\n    GIOStatus status = G_IO_STATUS_NORMAL;\n\n    size_t count;\n\n\n\n    while (size) {\n\n        status = ga_channel_write(c, buf, size, &count);\n\n        if (status == G_IO_STATUS_NORMAL) {\n\n            size -= count;\n\n            buf += count;\n\n        } else if (status != G_IO_STATUS_AGAIN) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return status;\n\n}\n",
        "output": "1",
        "idx": 4970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n",
        "output": "1",
        "idx": 3062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_ofp15_group_properties(struct ofpbuf *msg,\n                             enum ofp11_group_type group_type,\n                             enum ofp15_group_mod_command group_cmd,\n                             struct ofputil_group_props *gp,\n                             size_t properties_len)\n{\n    struct ofpbuf properties = ofpbuf_const_initializer(\n        ofpbuf_pull(msg, properties_len), properties_len);\n    while (properties.size > 0) {\n        struct ofpbuf payload;\n        enum ofperr error;\n        uint64_t type;\n\n        error = ofpprop_pull(&properties, &payload, &type);\n        if (error) {\n            return error;\n        }\n\n        switch (type) {\n        case OFPPROP_EXP(NTR_VENDOR_ID, NTRT_SELECTION_METHOD):\n        case OFPPROP_EXP(NTR_COMPAT_VENDOR_ID, NTRT_SELECTION_METHOD):\n            error = parse_group_prop_ntr_selection_method(&payload, group_type,\n                                                          group_cmd, gp);\n            break;\n\n        default:\n            error = OFPPROP_UNKNOWN(false, \"group\", type);\n            break;\n        }\n\n        if (error) {\n            return error;\n        }\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 5955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    rtl8139_do_receive(opaque, buf, size, 1);\n\n}\n",
        "output": "0",
        "idx": 4582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n\n                              int64_t wanted_timestamp, int flags)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    a = -1;\n\n    b = nb_entries;\n\n\n\n    // Optimize appending index entries at the end.\n\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n\n        a = b - 1;\n\n\n\n    while (b - a > 1) {\n\n        m         = (a + b) >> 1;\n\n\n\n        // Search for the next non-discarded packet.\n\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n\n            m++;\n\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n\n                m = b - 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp >= wanted_timestamp)\n\n            b = m;\n\n        if (timestamp <= wanted_timestamp)\n\n            a = m;\n\n    }\n\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n\n        while (m >= 0 && m < nb_entries &&\n\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n\n\n    if (m == nb_entries)\n\n        return -1;\n\n    return m;\n\n}\n",
        "output": "0",
        "idx": 2308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cookie_string(AVDictionary *dict, char **cookies)\n\n{\n\n    AVDictionaryEntry *e = NULL;\n\n    int len = 1;\n\n\n\n    // determine how much memory is needed for the cookies string\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n\n\n    // reallocate the cookies\n\n    e = NULL;\n\n    if (*cookies) av_free(*cookies);\n\n    *cookies = av_malloc(len);\n\n    if (!cookies) return AVERROR(ENOMEM);\n\n    *cookies[0] = '\\0';\n\n\n\n    // write out the cookies\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 4072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,\n\tint keyslot,\n\tconst char *keyfile,\n\tsize_t keyfile_size,\n\tsize_t keyfile_offset,\n\tconst char *new_keyfile,\n\tsize_t new_keyfile_size,\n\tsize_t new_keyfile_offset)\n{\n\treturn crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,\n\t\t\t\tkeyfile, keyfile_size, keyfile_offset,\n\t\t\t\tnew_keyfile, new_keyfile_size, new_keyfile_offset);\n}",
        "output": "0",
        "idx": 2943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void emb_close_connection(struct st_connection *cn)\n{\n  if (!cn->has_thread)\n    return;\n  wait_query_thread_done(cn);\n  signal_connection_thd(cn, EMB_END_CONNECTION);\n  pthread_join(cn->tid, NULL);\n  cn->has_thread= FALSE;\n  pthread_mutex_destroy(&cn->query_mutex);\n  pthread_cond_destroy(&cn->query_cond);\n  pthread_mutex_destroy(&cn->result_mutex);\n  pthread_cond_destroy(&cn->result_cond);\n}",
        "output": "0",
        "idx": 5024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\n\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 2417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_socket_block_time (RSocket *s, int block, int sec, int usec) {\n\treturn -1;\n}",
        "output": "1",
        "idx": 6270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n",
        "output": "1",
        "idx": 3235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}",
        "output": "0",
        "idx": 4789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mark_all_jobs_as_dead ()\n{\n  register int i;\n  sigset_t set, oset;\n\n  if (js.j_jobslots == 0)\n    return;\n\n  BLOCK_CHILD (set, oset);\n\n  /* XXX could use js.j_firstj here */\n  for (i = 0; i < js.j_jobslots; i++)\n    if (jobs[i])\n      {\n\tjobs[i]->state = JDEAD;\n\tjs.j_ndead++;\n      }\n\n  UNBLOCK_CHILD (oset);\n}",
        "output": "0",
        "idx": 2909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned int get_uint(ShortenContext *s, int k)\n\n{\n\n    if (s->version != 0)\n\n        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);\n\n    return get_ur_golomb_shorten(&s->gb, k);\n\n}\n",
        "output": "1",
        "idx": 4235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n\n{\n\n    int len;\n\n    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;\n\n\n\n    if (block_mig_state.zero_blocks &&\n\n        buffer_is_zero(blk->buf, BLOCK_SIZE)) {\n\n        flags |= BLK_MIG_FLAG_ZERO_BLOCK;\n\n    }\n\n\n\n    /* sector number and flags */\n\n    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)\n\n                     | flags);\n\n\n\n    /* device name */\n\n    len = strlen(bdrv_get_device_name(blk->bmds->bs));\n\n    qemu_put_byte(f, len);\n\n    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);\n\n\n\n    /* if a block is zero we need to flush here since the network\n\n     * bandwidth is now a lot higher than the storage device bandwidth.\n\n     * thus if we queue zero blocks we slow down the migration */\n\n    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {\n\n        qemu_fflush(f);\n\n        return;\n\n    }\n\n\n\n    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);\n\n}\n",
        "output": "1",
        "idx": 3386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_mpv_frame_end(MpegEncContext *s)\n\n{\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n    } else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    emms_c();\n\n\n\n    if (s->current_picture.reference)\n\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n\n}\n",
        "output": "0",
        "idx": 5941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* The memory barrier implicit in atomic_xchg makes sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    if (atomic_xchg(&bh->scheduled, 1) == 0) {\n\n        aio_notify(ctx);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 4262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*re_ast)->flags = 0;\n  (*re_ast)->root_node = NULL;\n\n  return ERROR_SUCCESS;\n}",
        "output": "1",
        "idx": 1602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n",
        "output": "0",
        "idx": 1093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_vfs_backend_dav_finalize (GObject *object)\n{\n  GVfsBackendDav *dav_backend;\n\n  dav_backend = G_VFS_BACKEND_DAV (object);\n\n#ifdef HAVE_AVAHI\n  if (dav_backend->resolver != NULL)\n    {\n      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);\n      g_object_unref (dav_backend->resolver);\n    }\n#endif\n\n  mount_auth_info_free (&(dav_backend->auth_info));\n  \n  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);\n}",
        "output": "0",
        "idx": 4049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;",
        "output": "1",
        "idx": 2387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int minimum_frame_bits(VC2EncContext *s)\n\n{\n\n    int slice_x, slice_y, bits = 0;\n\n    s->size_scaler = 64;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n\n            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);\n\n        }\n\n    }\n\n    return bits;\n\n}\n",
        "output": "1",
        "idx": 5264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\n\t/* create the WBMP */\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn;\n\t}\n\n\t/* fill up the WBMP structure */\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\n\t/* write the WBMP to a gd file descriptor */\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t}\n\n\t/* des submitted this bugfix: gdFree the memory. */\n\tfreewbmp(wbmp);\n}",
        "output": "1",
        "idx": 1488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "term_buffer_source(j_decompress_ptr)\n{\n}",
        "output": "0",
        "idx": 4274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline Http2Stream* GetStream(Http2Session* session,\n                              int32_t id,\n                              nghttp2_data_source* source) {\n  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);\n  if (stream == nullptr)\n    stream = session->FindStream(id);\n  CHECK_NE(stream, nullptr);\n  CHECK_EQ(id, stream->id());\n  return stream;\n}",
        "output": "0",
        "idx": 1432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = rsvd_bits(maxphyaddr, 51);\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}",
        "output": "0",
        "idx": 755
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->peer);\n\n\n\n    /* remove from list, if necessary */\n\n    if (bs->device_name[0] != '\\0') {\n\n        QTAILQ_REMOVE(&bdrv_states, bs, list);\n\n    }\n\n\n\n    bdrv_close(bs);\n\n    if (bs->file != NULL) {\n\n        bdrv_delete(bs->file);\n\n    }\n\n\n\n    assert(bs != bs_snapshots);\n\n    qemu_free(bs);\n\n}\n",
        "output": "1",
        "idx": 2396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,\n\t\t\t    uint init_alloc, uint alloc_increment)\n{\n  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))\n    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);\n}",
        "output": "0",
        "idx": 3858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n",
        "output": "1",
        "idx": 5440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void forward_timer_base(struct timer_base *base)\n{\n\tunsigned long jnow = READ_ONCE(jiffies);\n\n\t/*\n\t * We only forward the base when it's idle and we have a delta between\n\t * base clock and jiffies.\n\t */\n\tif (!base->is_idle || (long) (jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n}",
        "output": "0",
        "idx": 5517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t get_lease(struct dhcp_packet *packet)\n{\n\tuint8_t *option;\n\tuint32_t lease_seconds;\n\n\toption = dhcp_get_option(packet, DHCP_LEASE_TIME);\n\tif (!option)\n\t\treturn 3600;\n\n\tlease_seconds = get_be32(option);\n\n\tif (lease_seconds < 10)\n\t\tlease_seconds = 10;\n\n\treturn lease_seconds;\n}",
        "output": "1",
        "idx": 2814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PERL_STATIC_INLINE IV\nS_invlist_previous_index(SV* const invlist)\n{\n    /* Returns cached index of previous search */\n\n    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;\n\n    return *get_invlist_previous_index_addr(invlist);",
        "output": "0",
        "idx": 3099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char *buf = NULL;\n\tsize_t buf_len;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tif (df->enumerated)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\trv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: read private objects info failed\");\n\n\trv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);\n\n\tif (buf)\n\t\tfree(buf);\n\n\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: private info parse error\");\n\tdf->enumerated = 1;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}",
        "output": "0",
        "idx": 1215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void prepare_grab(void)\n\n{\n\n    fprintf(stderr, \"Must supply at least one input file\\n\");\n\n    exit(1);\n\n}\n",
        "output": "1",
        "idx": 3715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}",
        "output": "1",
        "idx": 4153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string encodeBase64(const std::string& input) {\n  using namespace boost::archive::iterators;\n  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;\n\n  auto data = input.data();\n  std::string encoded(b64it(data), b64it(data + (input.length())));\n  encoded.append((3 - (input.length() % 3)) % 3, '=');\n\n  return encoded;\n}",
        "output": "1",
        "idx": 2149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n",
        "output": "0",
        "idx": 5320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n",
        "output": "1",
        "idx": 5866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,\n    int from, int to, const char *s, enum vdc vdc)\n{\n\tint r;\n\n\tswitch (vdc) {\n\tcase VDC_STD:\n\t\tset_str(bp+from, s, to - from + 1, 0x20,\n\t\t    a_characters_map);\n\t\tr = ARCHIVE_OK;\n\t\tbreak;\n\tcase VDC_LOWERCASE:\n\t\tset_str(bp+from, s, to - from + 1, 0x20,\n\t\t    a1_characters_map);\n\t\tr = ARCHIVE_OK;\n\t\tbreak;\n\tcase VDC_UCS2:\n\tcase VDC_UCS2_DIRECT:\n\t\tr = set_str_utf16be(a, bp+from, s, to - from + 1,\n\t\t    0x0020, vdc);\n\t\tbreak;\n\tdefault:\n\t\tr = ARCHIVE_FATAL;\n\t}\n\treturn (r);\n}",
        "output": "0",
        "idx": 4247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n",
        "output": "1",
        "idx": 4669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)\n{\n\tDEFiRet;\n\tISOBJ_TYPE_assert(pThis, qqueue);\n\tassert(nUpdates >= 0);\n\n\tif(nUpdates == 0)\n\t\tFINALIZE;\n\n\tpThis->iUpdsSincePersist += nUpdates;\n\tif(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {\n\t\tqqueuePersist(pThis, QUEUE_CHECKPOINT);\n\t\tpThis->iUpdsSincePersist = 0;\n\t}\n\nfinalize_it:\n\tRETiRet;\n}",
        "output": "0",
        "idx": 346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)\n{\n\tstruct list_head *l;\n\n\text4_msg(sb, KERN_ERR, \"sb orphan head is %d\",\n\t\t le32_to_cpu(sbi->s_es->s_last_orphan));\n\n\tprintk(KERN_ERR \"sb_info orphan list:\\n\");\n\tlist_for_each(l, &sbi->s_orphan) {\n\t\tstruct inode *inode = orphan_list_entry(l);\n\t\tprintk(KERN_ERR \"  \"\n\t\t       \"inode %s:%lu at %p: mode %o, nlink %d, next %d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, inode,\n\t\t       inode->i_mode, inode->i_nlink,\n\t\t       NEXT_ORPHAN(inode));\n\t}\n}",
        "output": "0",
        "idx": 1426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "e_ews_connection_create_folder_finish (EEwsConnection *cnc,\n                                       GAsyncResult *result,\n                                       EwsFolderId **fid,\n                                       GError **error)\n{\n\tGSimpleAsyncResult *simple;\n\tEwsAsyncData *async_data;\n\n\tg_return_val_if_fail (cnc != NULL, FALSE);\n\tg_return_val_if_fail (\n\t\tg_simple_async_result_is_valid (\n\t\tresult, G_OBJECT (cnc), e_ews_connection_create_folder),\n\t\tFALSE);\n\n\tsimple = G_SIMPLE_ASYNC_RESULT (result);\n\tasync_data = g_simple_async_result_get_op_res_gpointer (simple);\n\n\tif (g_simple_async_result_propagate_error (simple, error))\n\t\treturn FALSE;\n\n\t*fid = (EwsFolderId *) async_data->items_created->data;\n\tg_slist_free (async_data->items_created);\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmd_anal_rtti(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"avr\"\n\tcase 'j': // \"avrj\"\n\t\tr_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);\n\t\tbreak;\n\tcase 'a': // \"avra\"\n\t\tr_anal_rtti_print_all (core->anal, input[1]);\n\t\tbreak;\n\tcase 'D': { // \"avrD\"\n\t\tchar *dup = strdup (input + 1);\n\t\tif (!dup) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *name = r_str_trim (dup);\n\t\tchar *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);\n\t\tfree (name);\n\t\tif (demangled) {\n\t\t\tr_cons_println (demangled);\n\t\t\tfree (demangled);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}",
        "output": "0",
        "idx": 3483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n",
        "output": "1",
        "idx": 3966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}",
        "output": "1",
        "idx": 2658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n\n}",
        "output": "1",
        "idx": 4298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);\n\n    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);\n\n}\n",
        "output": "1",
        "idx": 3436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,\n\t\tstruct sigevent __user *, timer_event_spec,\n\t\ttimer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (copy_from_user(&event, timer_event_spec, sizeof (event)))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}",
        "output": "0",
        "idx": 4929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ValidateSKIPJACK()\r\n{\r\n\tstd::cout << \"\\nSKIPJACK validation suite running...\\n\\n\";\r\n\tbool pass1 = true, pass2 = true;\r\n\r\n\tSKIPJACKEncryption enc;  // 80-bits only\r\n\tpass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;\r\n\tpass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;\r\n\tpass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;\r\n\tpass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;\r\n\r\n\tSKIPJACKDecryption dec;  // 80-bits only\r\n\tpass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;\r\n\tpass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;\r\n\tpass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;\r\n\tpass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;\r\n\tstd::cout << (pass1 && pass2 ? \"passed:\" : \"FAILED:\") << \"  Algorithm key lengths\\n\";\r\n\r\n\tFileSource valdata(CRYPTOPP_DATA_DIR \"TestData/skipjack.dat\", true, new HexDecoder);\r\n\treturn BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;\r\n}\r",
        "output": "0",
        "idx": 449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qdm2_init(QDM2Context *q) {\n\n    static int inited = 0;\n\n\n\n    if (inited != 0)\n\n        return;\n\n    inited = 1;\n\n\n\n    qdm2_init_vlc();\n\n    ff_mpa_synth_init(mpa_window);\n\n    softclip_table_init();\n\n    rnd_table_init();\n\n    init_noise_samples();\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"init done\\n\");\n\n}\n",
        "output": "0",
        "idx": 3411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    template<typename t>\n    CImg<T>& operator^=(const t value) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);\n      return *this;",
        "output": "0",
        "idx": 4989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const char *type_name()\n  {\n    return type == COLUMN ? \"COLUMN\" :\n           type == CHECK_CONSTRAINT ? \"CONSTRAINT\" :\n           type == KEY ? \"INDEX\" : \"FOREIGN KEY\";\n  }",
        "output": "0",
        "idx": 6210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pcie_pci_bridge_write_config(PCIDevice *d,\n\n        uint32_t address, uint32_t val, int len)\n\n{\n\n    pci_bridge_write_config(d, address, val, len);\n\n    msi_write_config(d, address, val, len);\n\n    shpc_cap_write_config(d, address, val, len);\n\n}\n",
        "output": "1",
        "idx": 5679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n",
        "output": "1",
        "idx": 6054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)\n\n{\n\n    char *tail;\n\n    double srate = av_strtod(arg, &tail);\n\n    if (*tail || srate < 1 || (int)srate != srate) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Invalid sample rate '%s'\\n\", arg);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    *ret = srate;\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }",
        "output": "0",
        "idx": 2785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RzList *MACH0_(get_maps)(RzBinFile *bf) {\n\tRzList *ret = MACH0_(get_maps_unpatched)(bf);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tstruct MACH0_(obj_t) *obj = bf->o->bin_obj;\n\t// clang-format off\n\tMACH0_(patch_relocs)(bf, obj);\n\t// clang-format on\n\trz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,\n\t\tMACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),\n\t\tMACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "InitAliasInfo(AliasInfo *info, enum merge_mode merge,\n              xkb_atom_t alias, xkb_atom_t real)\n{\n    memset(info, 0, sizeof(*info));\n    info->merge = merge;\n    info->alias = alias;\n    info->real = real;\n}",
        "output": "0",
        "idx": 1168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int is_regular_file(struct dirent *dent, const char *dirname)\n{\n    int dir_fd = open(dirname, O_DIRECTORY);\n    if (dir_fd < 0)\n        return 0;\n    int r = is_regular_file_at(dent, dir_fd);\n    close(dir_fd);\n    return r;\n}",
        "output": "0",
        "idx": 1969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usb_device_init(USBDevice *dev)\n{\n    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);\n    if (klass->init) {\n        return klass->init(dev);\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 4130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lua_ap_exists_config_define(lua_State *L)\n{\n    int returnValue;\n    const char     *name;\n    luaL_checktype(L, 1, LUA_TSTRING);\n    name = lua_tostring(L, 1);\n    returnValue = ap_exists_config_define(name);\n    lua_pushboolean(L, returnValue);\n    return 1;\n}",
        "output": "0",
        "idx": 5697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,\n                   const char* d, const char* curveName)\n{\n    int err, x;\n\n    /* if d is NULL, only import as public key using Qx,Qy */\n    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* set curve type and index */\n    for (x = 0; ecc_sets[x].size != 0; x++) {\n        if (XSTRNCMP(ecc_sets[x].name, curveName,\n                     XSTRLEN(curveName)) == 0) {\n            break;\n        }\n    }\n\n    if (ecc_sets[x].size == 0) {\n        WOLFSSL_MSG(\"ecc_set curve name not found\");\n        err = ASN_PARSE_E;\n    } else {\n        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,\n            WC_TYPE_HEX_STR);\n    }\n\n    return err;\n}",
        "output": "0",
        "idx": 66
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)\n\n{\n\n    bool progress = false;\n\n    int64_t end_time;\n\n\n\n    assert(ctx->notify_me);\n\n    assert(ctx->walking_handlers > 0);\n\n    assert(ctx->poll_disable_cnt == 0);\n\n\n\n    trace_run_poll_handlers_begin(ctx, max_ns);\n\n\n\n    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;\n\n\n\n    do {\n\n        AioHandler *node;\n\n\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n                progress = true;\n\n            }\n\n\n\n            /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n        }\n\n    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);\n\n\n\n    trace_run_poll_handlers_end(ctx, progress);\n\n\n\n    return progress;\n\n}\n",
        "output": "1",
        "idx": 1283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sftp_dir_eof(sftp_dir dir) {\n  return dir->eof;\n}",
        "output": "0",
        "idx": 2979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_circle (void)\n{\n    RsvgNodeCircle *circle;\n    circle = g_new (RsvgNodeCircle, 1);\n    _rsvg_node_init (&circle->super, RSVG_NODE_TYPE_CIRCLE);\n    circle->super.draw = _rsvg_node_circle_draw;\n    circle->super.set_atts = _rsvg_node_circle_set_atts;\n    circle->cx = circle->cy = circle->r = _rsvg_css_parse_length (\"0\");\n    return &circle->super;\n}",
        "output": "0",
        "idx": 5363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void blosc_set_blocksize(size_t size) {\n  g_force_blocksize = (int32_t)size;\n}",
        "output": "0",
        "idx": 3945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(\n    AvahiServer *server,\n    AvahiIfIndex interface,\n    AvahiProtocol protocol,\n    const char *domain,\n    AvahiLookupFlags flags,\n    AvahiSServiceTypeBrowserCallback callback,\n    void* userdata) {\n        AvahiSServiceTypeBrowser *b;\n\n        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);\n        avahi_s_service_type_browser_start(b);\n\n        return b;\n}",
        "output": "1",
        "idx": 699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {\n    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;\n\n    if (tx->response_message != NULL) {\n        bstr_free(tx->response_message);\n    }\n\n    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);\n    if (tx->response_message == NULL) return HTP_ERROR;\n\n    return HTP_OK;\n}",
        "output": "0",
        "idx": 4290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}",
        "output": "1",
        "idx": 1318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n\n{\n\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n    static const uint8_t vlan[] = {0x81, 0x00};\n\n    uint8_t *ptr = (uint8_t *)buf;\n\n    int i;\n\n\n\n    if (n->promisc)\n\n        return 1;\n\n\n\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n\n        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n\n            return 0;\n\n    }\n\n\n\n    if ((ptr[0] & 1) && n->allmulti)\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, bcast, sizeof(bcast)))\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, n->mac, ETH_ALEN))\n\n        return 1;\n\n\n\n    for (i = 0; i < n->mac_table.in_use; i++) {\n\n        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 4483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void render_line(int x0, int y0, int x1, int y1, float *buf)\n{\n    int dy  = y1 - y0;\n    int adx = x1 - x0;\n    int ady = FFABS(dy);\n    int sy  = dy < 0 ? -1 : 1;\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n    if (ady*2 <= adx) { // optimized common case\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n    } else {\n        int base = dy / adx;\n        int x    = x0;\n        unsigned char y = y0;\n        int err  = -adx;\n        ady -= FFABS(base) * adx;\n        while (++x < x1) {\n            y += base;\n            err += ady;\n            if (err >= 0) {\n                err -= adx;\n                y   += sy;\n            }\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n        }\n    }\n}",
        "output": "1",
        "idx": 4432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n",
        "output": "1",
        "idx": 815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,\n\n                                    const int filter_p1, const int filter_q1,\n\n                                    const int alpha, const int beta,\n\n                                    const int lim_p0q0, const int lim_q1,\n\n                                    const int lim_p1)\n\n{\n\n    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,\n\n                          alpha, beta, lim_p0q0, lim_q1, lim_p1);\n\n}\n",
        "output": "1",
        "idx": 2391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    FDCharDriver *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(FDCharDriver));\n\n    s->fd_in = io_channel_from_fd(fd_in);\n\n    s->fd_out = io_channel_from_fd(fd_out);\n\n    fcntl(fd_out, F_SETFL, O_NONBLOCK);\n\n    s->chr = chr;\n\n    chr->opaque = s;\n\n    chr->chr_add_watch = fd_chr_add_watch;\n\n    chr->chr_write = fd_chr_write;\n\n    chr->chr_update_read_handler = fd_chr_update_read_handler;\n\n    chr->chr_close = fd_chr_close;\n\n\n\n    qemu_chr_be_generic_open(chr);\n\n\n\n    return chr;\n\n}\n",
        "output": "0",
        "idx": 218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void iscsi_timed_check_events(void *opaque)\n{\n    IscsiLun *iscsilun = opaque;\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\n    /* check for timed out requests */\n    iscsi_service(iscsilun->iscsi, 0);\n\n    if (iscsilun->request_timed_out) {\n        iscsilun->request_timed_out = false;\n        iscsi_reconnect(iscsilun->iscsi);\n    }\n\n    /* newer versions of libiscsi may return zero events. Ensure we are able\n     * to return to service once this situation changes. */\n    iscsi_set_events(iscsilun);\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    timer_mod(iscsilun->event_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);\n}",
        "output": "0",
        "idx": 4624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void h264_deblock_q1(register vector unsigned char p0,\n\n                                                   register vector unsigned char p1,\n\n                                                   register vector unsigned char p2,\n\n                                                   register vector unsigned char q0,\n\n                                                   register vector unsigned char tc0) {\n\n\n\n    register vector unsigned char average = vec_avg(p0, q0);\n\n    register vector unsigned char temp;\n\n    register vector unsigned char uncliped;\n\n    register vector unsigned char ones;\n\n    register vector unsigned char max;\n\n    register vector unsigned char min;\n\n\n\n    temp = vec_xor(average, p2);\n\n    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */\n\n    ones = vec_splat_u8(1);\n\n    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */\n\n    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */\n\n    max = vec_adds(p1, tc0);\n\n    min = vec_subs(p1, tc0);\n\n    p1 = vec_max(min, uncliped);\n\n    p1 = vec_min(max, p1);\n\n}\n",
        "output": "0",
        "idx": 4956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n",
        "output": "0",
        "idx": 1682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)\n\n{\n\n    if (ohci->async_td &&\n\n        ohci->usb_packet.owner != NULL &&\n\n        ohci->usb_packet.owner->dev == dev) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    **/\n    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {\n      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);",
        "output": "0",
        "idx": 3307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 8, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5587
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "leave_sysex(int dev)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             timeout = 0;\n\n\tif (!sysex_state[dev])\n\t\treturn;\n\n\tsysex_state[dev] = 0;\n\n\twhile (!midi_devs[orig_dev]->outputc(orig_dev, 0xf7) &&\n\t       timeout < 1000)\n\t\ttimeout++;\n\n\tsysex_state[dev] = 0;\n}",
        "output": "0",
        "idx": 4603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)\n{\n  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);\n  state= SHORT_DATA_VALUE;\n\n  my_decimal2decimal(dv, &value.m_decimal);\n\n  decimals= (uint8) value.m_decimal.frac;\n  collation.set_numeric();\n  unsigned_flag= unsigned_arg;\n  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,\n                                             decimals, unsigned_flag);\n  maybe_null= 0;\n  null_value= 0;\n  fix_type(Item::DECIMAL_ITEM);\n}",
        "output": "0",
        "idx": 2818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int openfile(char *name, int flags)\n\n{\n\n\tif (bs) {\n\n\t\tfprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\t\treturn 1;\n\n\t}\n\n\n\n\tbs = bdrv_new(\"hda\");\n\n\tif (!bs)\n\n\t\treturn 1;\n\n\n\n\tif (bdrv_open(bs, name, flags) == -1) {\n\n\t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name);\n\n\t\tbs = NULL;\n\n\t\treturn 1;\n\n\t}\n\n\n\n\treturn 0;\n\n}\n",
        "output": "0",
        "idx": 519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype,\n\t\t\t\t\tbool opt_stats)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));\n\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tserr->opt_stats = opt_stats;\n\tserr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\n\terr = sock_queue_err_skb(sk, skb);\n\n\tif (err)\n\t\tkfree_skb(skb);",
        "output": "0",
        "idx": 4589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "output": "1",
        "idx": 4763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void migrate_fd_completed(MigrationState *s)\n\n{\n\n    DPRINTF(\"setting completed state\\n\");\n\n    migrate_fd_cleanup(s);\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_COMPLETED;\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    }\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n",
        "output": "0",
        "idx": 1175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n",
        "output": "0",
        "idx": 2968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {\n  _param_1 = beginAddr;\n  _param_2 = data;\n  _param_3 = align;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_PGM_BLK) : \"memory\");\n  return !!_param_1;\n}",
        "output": "0",
        "idx": 5323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int drm_modeset_ctl(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file_priv)\n{\n\tstruct drm_modeset_ctl *modeset = data;\n\tint crtc, ret = 0;\n\n\t/* If drm_vblank_init() hasn't been called yet, just no-op */\n\tif (!dev->num_crtcs)\n\t\tgoto out;\n\n\tcrtc = modeset->crtc;\n\tif (crtc >= dev->num_crtcs) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (modeset->cmd) {\n\tcase _DRM_PRE_MODESET:\n\t\tdrm_vblank_pre_modeset(dev, crtc);\n\t\tbreak;\n\tcase _DRM_POST_MODESET:\n\t\tdrm_vblank_post_modeset(dev, crtc);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}",
        "output": "1",
        "idx": 3439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mb86a20s_get_segment_count(struct mb86a20s_state *state,\n\t\t\t\t      unsigned layer)\n{\n\tint rc, count;\n\tstatic unsigned char reg[] = {\n\t\t[0] = 0x89,\t/* Layer A */\n\t\t[1] = 0x8d,\t/* Layer B */\n\t\t[2] = 0x91,\t/* Layer C */\n\t};\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (layer >= ARRAY_SIZE(reg))\n\t\treturn -EINVAL;\n\n\trc = mb86a20s_writereg(state, 0x6d, reg[layer]);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x6e);\n\tif (rc < 0)\n\t\treturn rc;\n\tcount = (rc >> 4) & 0x0f;\n\n\tdev_dbg(&state->i2c->dev, \"%s: segments: %d.\\n\", __func__, count);\n\n\treturn count;\n}",
        "output": "0",
        "idx": 572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EXPORTED int http_allow_noauth_get(struct transaction_t *txn)\n{\n    /* Inverse logic: True means we *require* authentication */\n    switch (txn->meth) {\n    case METH_GET:\n    case METH_HEAD:\n        /* Let method processing function decide if auth is needed */\n        return 0;\n    default:\n        return 1;\n    }\n}",
        "output": "0",
        "idx": 4231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "1",
        "idx": 2442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 1902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,\n                                    const unsigned char *sig,\n                                    size_t sig_len,\n                                    const unsigned char *m,\n                                    size_t m_len, void **abstract)\n{\n    const unsigned char *r, *s, *p;\n    size_t r_len, s_len;\n    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);\n\n    (void) session;\n\n    if(sig_len < 35)\n        return -1;\n\n    /* Skip past keyname_len(4) + keyname(19){\"ecdsa-sha2-nistp256\"} + signature_len(4) */\n    p = sig;\n    p += 27;\n\n    r_len = _libssh2_ntohu32(p);\n    p += 4;\n    r = p;\n    p += r_len;\n\n    s_len = _libssh2_ntohu32(p);\n    p += 4;\n    s = p;\n\n    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);\n}",
        "output": "1",
        "idx": 4700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void insert_hash(struct audit_chunk *chunk)\n{\n\tstruct list_head *list = chunk_hash(chunk->watch.inode);\n\tlist_add_rcu(&chunk->hash, list);\n}",
        "output": "0",
        "idx": 1058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)\n\n{\n\n    if (throttle_conflicting(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (!throttle_is_valid(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (throttle_max_is_missing_limit(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n",
        "output": "0",
        "idx": 1232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}",
        "output": "1",
        "idx": 3594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RzList *relocs(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->fixups);\n}",
        "output": "1",
        "idx": 4960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int huff_build10(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[1024];\n\n    uint32_t codes[1024];\n\n    uint8_t bits[1024];\n\n    uint16_t syms[1024];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        he[i].sym = 1023 - i;\n\n        he[i].len = len[i];\n\n\n\n    }\n\n    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);\n\n\n\n    code = 1;\n\n    for (i = 1023; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}",
        "output": "1",
        "idx": 2515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        MXFTrack *track = s->streams[i]->priv_data;\n\n        /* SMPTE 379M 7.3 */\n\n        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n\n            return i;\n\n    }\n\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n\n    return s->nb_streams == 1 ? 0 : -1;\n\n}\n",
        "output": "1",
        "idx": 5179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void xenvif_grant_handle_reset(struct xenvif *vif,\n\t\t\t\t\t     u16 pending_idx)\n{\n\tif (unlikely(vif->grant_tx_handle[pending_idx] ==\n\t\t     NETBACK_INVALID_HANDLE)) {\n\t\tnetdev_err(vif->dev,\n\t\t\t   \"Trying to unmap invalid handle! pending_idx: %x\\n\",\n\t\t\t   pending_idx);\n\t\tBUG();\n\t}\n\tvif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;\n}",
        "output": "0",
        "idx": 4667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n",
        "output": "1",
        "idx": 581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);",
        "output": "1",
        "idx": 776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}",
        "output": "1",
        "idx": 458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *ask_new_field(struct chfn_control *ctl, const char *question,\n\t\t\t   char *def_val)\n{\n\tint len;\n\tchar *buf;\n#ifndef HAVE_LIBREADLINE\n\tsize_t dummy = 0;\n#endif\n\n\tif (!def_val)\n\t\tdef_val = \"\";\n\twhile (true) {\n\t\tprintf(\"%s [%s]:\", question, def_val);\n\t\t__fpurge(stdin);\n#ifdef HAVE_LIBREADLINE\n\t\trl_bind_key('\\t', rl_insert);\n\t\tif ((buf = readline(\" \")) == NULL)\n#else\n\t\tputchar(' ');\n\t\tif (getline(&buf, &dummy, stdin) < 0)\n#endif\n\t\t\terrx(EXIT_FAILURE, _(\"Aborted.\"));\n\t\t/* remove white spaces from string end */\n\t\tltrim_whitespace((unsigned char *) buf);\n\t\tlen = rtrim_whitespace((unsigned char *) buf);\n\t\tif (len == 0) {\n\t\t\tfree(buf);\n\t\t\treturn xstrdup(def_val);\n\t\t}\n\t\tif (!strcasecmp(buf, \"none\")) {\n\t\t\tfree(buf);\n\t\t\tctl->changed = 1;\n\t\t\treturn xstrdup(\"\");\n\t\t}\n\t\tif (check_gecos_string(question, buf) >= 0)\n\t\t\tbreak;\n\t}\n\tctl->changed = 1;\n\treturn buf;\n}",
        "output": "1",
        "idx": 2124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n",
        "output": "1",
        "idx": 2302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct pending_op *acquire_write(struct external_chrc *chrc,\n\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\tstruct gatt_db_attribute *attrib,\n\t\t\t\t\tunsigned int id,\n\t\t\t\t\tconst uint8_t *value, size_t len,\n\t\t\t\t\tuint8_t link_type)\n{\n\tstruct pending_op *op;\n\tbool acquiring = !queue_isempty(chrc->pending_writes);\n\n\top = pending_write_new(device, chrc->pending_writes, attrib, id, value,\n\t\t\t\tlen, 0, link_type, false, false);\n\n\tif (acquiring)\n\t\treturn op;\n\n\tif (g_dbus_proxy_method_call(chrc->proxy, \"AcquireWrite\",\n\t\t\t\t\tacquire_write_setup,\n\t\t\t\t\tacquire_write_reply,\n\t\t\t\t\top, NULL))\n\t\treturn op;\n\n\tpending_op_free(op);\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 4057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n",
        "output": "1",
        "idx": 5228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool GetVal(cmsIT8* it8, char* Buffer, cmsUInt32Number max, const char* ErrorTitle)\n{\n    switch (it8->sy) {\n\n    case SIDENT:  strncpy(Buffer, it8->id, max);\n                  Buffer[max-1]=0;\n                  break;\n    case SINUM:   snprintf(Buffer, max, \"%d\", it8 -> inum); break;\n    case SDNUM:   snprintf(Buffer, max, it8->DoubleFormatter, it8 -> dnum); break;\n    case SSTRING: strncpy(Buffer, it8->str, max);\n                  Buffer[max-1] = 0;\n                  break;\n\n\n    default:\n         return SynError(it8, \"%s\", ErrorTitle);\n    }\n\n    Buffer[max] = 0;\n    return TRUE;\n}",
        "output": "0",
        "idx": 3139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PM_io_parser<PMDEC>::read_face(Face_handle f)\n{ // syntax: index { halfedge, fclist, ivlist, mark }\n  int n, ei, vi; Mark m;\n  if ( !(in >> n) || !check_sep(\"{\") ) return false;\n  if ( !(in >> ei) || !check_sep(\",\") ) return false;\n  if (ei >= 0) f->set_halfedge(Halfedge_of[ei]);\n  while (in >> ei) {\n    CGAL_assertion_msg(ei >= 0 && (std::size_t) ei < en, \"wrong index in face cycle list.\");\n    f->store_fc(Halfedge_of[ei]);\n  } in.clear();\n  if (!check_sep(\",\")) { return false; }\n  while (in >> vi) {\n    CGAL_assertion_msg(vi >= 0 && (std::size_t) vi < vn, \"wrong index in iso vertex list.\");\n    f->store_iv(Vertex_of[vi]);\n  } in.clear();\n  if (!check_sep(\",\") || !(in >> m) || !check_sep(\"}\") )\n    return false;\n  mark(f) = m;\n  return true;\n}",
        "output": "1",
        "idx": 4166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)\n{\n\tstruct cil_tree_node *curr = NULL;\n\tstruct cil_blockinherit *bi = NULL;\n\tstruct cil_block *block = NULL;\n\tint rc = SEPOL_ERR;\n\n\tbi = bi_node->data;\n\n\tfor (curr = bi_node->parent; curr != NULL; curr = curr->parent) {\n\t\tif (curr->flavor != CIL_BLOCK) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock = curr->data;\n\n\t\tif (block != bi->block) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcil_log(CIL_ERR, \"Recursive blockinherit found:\\n\");\n\t\tcil_print_recursive_blockinherit(bi_node, curr);\n\n\t\trc = SEPOL_ERR;\n\t\tgoto exit;\n\t}\n\n\trc = SEPOL_OK;\n\nexit:\n\treturn rc;\n}",
        "output": "0",
        "idx": 3045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[258], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
        "output": "0",
        "idx": 4042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_REMOVED);\n\n    }\n\n\n\n    if (s->ctx) {\n\n        blk_op_unblock_all(sd->conf.blk, s->blocker);\n\n    }\n\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n\n}\n",
        "output": "0",
        "idx": 1974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,\n\t\t\t\t      const struct dom_sid *alias,\n\t\t\t\t      TALLOC_CTX *mem_ctx,\n\t\t\t\t      struct dom_sid **pmembers,\n\t\t\t\t      size_t *pnum_members)\n{\n\tstruct pdb_samba_dsdb_state *state = talloc_get_type_abort(\n\t\tm->private_data, struct pdb_samba_dsdb_state);\n\tstruct ldb_dn *dn;\n\tunsigned int num_members;\n\tNTSTATUS status;\n\tstruct dom_sid_buf buf;\n\tTALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);\n\tNT_STATUS_HAVE_NO_MEMORY(tmp_ctx);\n\n\tdn = ldb_dn_new_fmt(\n\t\ttmp_ctx,\n\t\tstate->ldb,\n\t\t\"<SID=%s>\",\n\t\tdom_sid_str_buf(alias, &buf));\n\tif (!dn || !ldb_dn_validate(dn)) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\n\tstatus = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);\n\tif (NT_STATUS_IS_OK(status)) {\n\t\t*pnum_members = num_members;\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn status;\n}",
        "output": "0",
        "idx": 1010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool mpOk(const QString &mp)\n{\n    return !mp.isEmpty() && mp.startsWith(\"/home/\"); // ) && mp.contains(\"cantata\");\n}",
        "output": "1",
        "idx": 2143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sws_rgb2rgb_init(int flags)\n\n{\n\n#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX\n\n    if (flags & SWS_CPU_CAPS_SSE2)\n\n        rgb2rgb_init_SSE2();\n\n    else if (flags & SWS_CPU_CAPS_MMX2)\n\n        rgb2rgb_init_MMX2();\n\n    else if (flags & SWS_CPU_CAPS_3DNOW)\n\n        rgb2rgb_init_3DNOW();\n\n    else if (flags & SWS_CPU_CAPS_MMX)\n\n        rgb2rgb_init_MMX();\n\n    else\n\n#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */\n\n        rgb2rgb_init_C();\n\n}\n",
        "output": "0",
        "idx": 2521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_alloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t/* file system mount structure */\n{\n\tmp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,\n\t\t\t(mp->m_sb.sb_agblocks + 1) / 2);\n}",
        "output": "0",
        "idx": 5510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chkpass_ne(PG_FUNCTION_ARGS)\n{\n\tchkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);\n\ttext\t   *a2 = PG_GETARG_TEXT_PP(1);\n\tchar\t\tstr[9];\n\n\ttext_to_cstring_buffer(a2, str, sizeof(str));\n\tPG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);\n}",
        "output": "1",
        "idx": 2598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HttpIntegrationTest::waitForNextUpstreamRequest(uint64_t upstream_index) {\n  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}));\n}",
        "output": "1",
        "idx": 1725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {\n  if (!connection_.enableTrailers()) {\n    return endEncode();\n  }\n  // Trailers only matter if it is a chunk transfer encoding\n  // https://tools.ietf.org/html/rfc7230#section-4.4\n  if (chunk_encoding_) {\n    // Finalize the body\n    connection_.buffer().add(LAST_CHUNK);\n\n    trailers.iterate(\n        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(\n              header.key().getStringView(), header.value().getStringView());\n          return HeaderMap::Iterate::Continue;\n        },\n        this);\n\n    connection_.flushOutput();\n    connection_.buffer().add(CRLF);\n  }\n\n  connection_.flushOutput();\n  connection_.onEncodeComplete();\n}",
        "output": "0",
        "idx": 3120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MonCap::dump(Formatter *f) const\n{\n  f->dump_string(\"text\", text);\n}",
        "output": "0",
        "idx": 1658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_paio_init(struct qemu_paioinit *aioinit)\n\n{\n\n    int ret;\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret) die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret) die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    TAILQ_INIT(&request_list);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)\n\n{\n\n    if (!buffer->cmd) {\n\n        AVBufferRef *buf = buffer->user_data;\n\n        av_buffer_unref(&buf);\n\n    }\n\n    mmal_buffer_header_release(buffer);\n\n}\n",
        "output": "1",
        "idx": 3960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n",
        "output": "0",
        "idx": 284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n",
        "output": "1",
        "idx": 1212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_line (void)\n{\n    RsvgNodeLine *line;\n    line = g_new (RsvgNodeLine, 1);\n    _rsvg_node_init (&line->super);\n    line->super.draw = _rsvg_node_line_draw;\n    line->super.set_atts = _rsvg_node_line_set_atts;\n    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (\"0\");\n    return &line->super;\n}",
        "output": "1",
        "idx": 2313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n",
        "output": "1",
        "idx": 1110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n",
        "output": "1",
        "idx": 3844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init sched_domain_debug_setup(char *str)\n{\n\tsched_domain_debug_enabled = 1;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tcmi_box_del(GF_Box *s)\n{\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\tif (ptr->font) gf_free(ptr->font);\n\tgf_free(s);\n}",
        "output": "0",
        "idx": 2819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void apic_update_irq(APICState *s)\n\n{\n\n    int irrv, ppr;\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE))\n\n        return;\n\n    irrv = get_highest_priority_int(s->irr);\n\n    if (irrv < 0)\n\n        return;\n\n    ppr = apic_get_ppr(s);\n\n    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))\n\n        return;\n\n    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n}\n",
        "output": "0",
        "idx": 4161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n",
        "output": "1",
        "idx": 3519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void initialize() {\n    Http2SettingsFromTuple(client_http2settings_, client_settings_);\n    Http2SettingsFromTuple(server_http2settings_, server_settings_);\n    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,\n                                                         stats_store_, client_http2settings_,\n                                                         max_request_headers_kb_);\n    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,\n                                                         stats_store_, server_http2settings_,\n                                                         max_request_headers_kb_);\n\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n  }",
        "output": "0",
        "idx": 920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,\n\n                                        target_phys_addr_t start_addr,\n\n                                        target_phys_addr_t end_addr)\n\n{\n\n    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);\n\n}\n",
        "output": "1",
        "idx": 5456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)\n{\n\tif (y > SIZE_MAX - x) {\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x + y;\n\treturn true;\n}",
        "output": "1",
        "idx": 5022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n\n    return nonce->references;\n}",
        "output": "1",
        "idx": 602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n",
        "output": "1",
        "idx": 2821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SetenvFin1(buf, len, data)\nchar *buf;\nint len;\nchar *data;\t/* dummy */\n{\n  if (!len || !display)\n    return;\n  InputSetenv(buf);\n}",
        "output": "0",
        "idx": 3038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)\n\n{\n\n    *range = 8 * (1 << (f_code - 1));\n\n    /* XXX: temporary kludge to avoid overflow for msmpeg4 */\n\n    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)\n\n\t*range *= 2;\n\n\n\n    if (s->unrestricted_mv) {\n\n        *xmin = -16;\n\n        *ymin = -16;\n\n        if (s->h263_plus)\n\n            *range *= 2;\n\n        if(s->avctx->codec->id!=CODEC_ID_MPEG4){\n\n            *xmax = s->mb_width*16;\n\n            *ymax = s->mb_height*16;\n\n        }else {\n\n            *xmax = s->width;\n\n            *ymax = s->height;\n\n        }\n\n    } else {\n\n        *xmin = 0;\n\n        *ymin = 0;\n\n        *xmax = s->mb_width*16 - 16;\n\n        *ymax = s->mb_height*16 - 16;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rdp_write_client_time_zone(wStream* s, rdpSettings* settings)\n{\n\tLPTIME_ZONE_INFORMATION tz;\n\tDWORD rc;\n\n\ttz = settings->ClientTimeZone;\n\trc = GetTimeZoneInformation(tz);\n\n\t/* Bias */\n\tStream_Write_UINT32(s, tz->Bias);\n\n\t/* standardName (64 bytes) */\n\tStream_Write(s, tz->StandardName, sizeof(tz->StandardName));\n\n\t/* StandardDate */\n\trdp_write_system_time(s, &tz->StandardDate);\n\n\tDEBUG_TIMEZONE(\"bias=%d stdName='%s' dlName='%s'\", tz->Bias,\n\t\t       tz->StandardName, tz->DaylightName);\n\n\t/* Note that StandardBias is ignored if no valid standardDate is provided. */\n\t/* StandardBias */\n\tStream_Write_UINT32(s, tz->StandardBias);\n\tDEBUG_TIMEZONE(\"StandardBias=%d\", tz->StandardBias);\n\n\t/* daylightName (64 bytes) */\n\tStream_Write(s, tz->DaylightName, sizeof(tz->DaylightName));\n\n\t/* DaylightDate */\n\trdp_write_system_time(s, &tz->DaylightDate);\n\n\t/* Note that DaylightBias is ignored if no valid daylightDate is provided. */\n\t/* DaylightBias */\n\tStream_Write_UINT32(s, tz->DaylightBias);\n\tDEBUG_TIMEZONE(\"DaylightBias=%d\", tz->DaylightBias);\n}",
        "output": "0",
        "idx": 1798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string Box_pitm::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << indent << \"item_ID: \" << m_item_ID << \"\\n\";\n\n  return sstr.str();\n}",
        "output": "0",
        "idx": 2016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}",
        "output": "1",
        "idx": 4523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "control_notify_input(struct client *c, struct window_pane *wp,\n    struct evbuffer *input)\n{\n\tu_char\t\t*buf;\n\tsize_t\t\t len;\n\tstruct evbuffer *message;\n\tu_int\t\t i;\n\n\tif (c->session == NULL)\n\t    return;\n\n\tbuf = EVBUFFER_DATA(input);\n\tlen = EVBUFFER_LENGTH(input);\n\n\t/*\n\t * Only write input if the window pane is linked to a window belonging\n\t * to the client's session.\n\t */\n\tif (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {\n\t\tmessage = evbuffer_new();\n\t\tevbuffer_add_printf(message, \"%%output %%%u \", wp->id);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buf[i] < ' ' || buf[i] == '\\\\')\n\t\t\t    evbuffer_add_printf(message, \"\\\\%03o\", buf[i]);\n\t\t\telse\n\t\t\t    evbuffer_add_printf(message, \"%c\", buf[i]);\n\t\t}\n\t\tcontrol_write_buffer(c, message);\n\t\tevbuffer_free(message);\n\t}\n}",
        "output": "1",
        "idx": 4325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mk_request_premature_close(int http_status, struct client_session *cs)\n{\n    struct session_request *sr;\n    struct mk_list *sr_list = &cs->request_list;\n    struct mk_list *host_list = &config->hosts;\n\n    /*\n     * If the connection is too premature, we need to allocate a temporal session_request\n     * to do not break the plugins stages\n     */\n    if (mk_list_is_empty(sr_list) == 0) {\n        sr = &cs->sr_fixed;\n        memset(sr, 0, sizeof(struct session_request));\n        mk_request_init(sr);\n        mk_list_add(&sr->_head, &cs->request_list);\n    }\n    else {\n        sr = mk_list_entry_first(sr_list, struct session_request, _head);\n    }\n\n    /* Raise error */\n    if (http_status > 0) {\n        if (!sr->host_conf) {\n            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);\n        }\n        mk_request_error(http_status, cs, sr);\n\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,\n                            NULL, cs, sr);\n    }\n\n    /* STAGE_50, connection closed  and remove client_session*/\n    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);\n    mk_session_remove(cs->socket);\n}",
        "output": "0",
        "idx": 1952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n\n                            uint8_t *dst, int stride, int16_t *block)\n\n{\n\n    int i, num_coeff;\n\n\n\n    /* Is it a skip block? */\n\n    if (get_bits1(gb)) {\n\n        /* This is a P-frame. */\n\n        ctx->frame->key_frame = 0;\n\n        ctx->frame->pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        return 0;\n\n    }\n\n\n\n    memset(block, 0, sizeof(*block) * 64);\n\n\n\n    num_coeff = get_bits(gb, 7);\n\n    if (num_coeff > 64)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < num_coeff; i++)\n\n        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *\n\n                                     ctx->qmat[ff_zigzag_direct[i]];\n\n\n\n    fic_idct_put(dst, stride, block);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ut64 getFunctionSize(Sdb *db) {\n#if 1\n\tut64 min = sdb_num_get (db, Fmin (addr), NULL);\n\tut64 max = sdb_num_get (db, Fmax (addr), NULL);\n#else\n\tut64 min, max;\n\tchar *c, *bbs = sdb_get (db, \"bbs\", NULL);\n\tint first = 1;\n\tsdb_aforeach (c, bbs) {\n\t\tut64 addr = sdb_atoi (c);\n\t\tut64 addr_end = sdb_num_get (db, Fbb(addr), NULL);\n\t\tif (first) {\n\t\t\tmin = addr;\n\t\t\tmax = addr_end;\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tif (addr<min)\n\t\t\t\tmin = addr;\n\t\t\tif (addr_end>max)\n\t\t\t\tmax = addr_end;\n\t\t}\n\t\tsdb_aforeach_next (c);\n\t}\n\tfree (bbs);\n#endif\n\treturn max-min;\n}",
        "output": "0",
        "idx": 2421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "output": "1",
        "idx": 536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n",
        "output": "1",
        "idx": 6051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\n\troot_tmp = gf_strdup(szPath);\n\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\n\tstrcat(szPath, \"gpac_cache\");\n\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}",
        "output": "0",
        "idx": 1176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\tjson_t *proto_state, const char *error, const char *error_description) {\n\tconst char *prompt =\n\t\t\tjson_object_get(proto_state, \"prompt\") ?\n\t\t\t\t\tapr_pstrdup(r->pool,\n\t\t\t\t\t\t\tjson_string_value(\n\t\t\t\t\t\t\t\t\tjson_object_get(proto_state, \"prompt\"))) :\n\t\t\t\t\t\t\t\t\tNULL;\n\tjson_decref(proto_state);\n\tif ((prompt != NULL) && (apr_strnatcmp(prompt, \"none\") == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, DONE);\n}",
        "output": "0",
        "idx": 2438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sysbus_ahci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    dc->realize = sysbus_ahci_realize;\n    dc->vmsd = &vmstate_sysbus_ahci;\n    dc->props = sysbus_ahci_properties;\n    dc->reset = sysbus_ahci_reset;\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n}",
        "output": "0",
        "idx": 4685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Replace the image by an identity matrix \\newinstance.\n    CImg<T> get_identity_matrix() const {\n      return identity_matrix(std::max(_width,_height));",
        "output": "0",
        "idx": 4097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    int len;\n\n\n\n    for(;;) {\n\n        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);\n\n        if (len != TS_PACKET_SIZE)\n\n            return len < 0 ? len : AVERROR_EOF;\n\n        /* check packet sync byte */\n\n        if ((*data)[0] != 0x47) {\n\n            /* find a new packet start */\n\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n\n            if (mpegts_resync(s) < 0)\n\n                return AVERROR(EAGAIN);\n\n            else\n\n                continue;\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)\n{\n\t/* can't have sync rep confused by sending the same LSN several times */\n\tif (!last_write)\n\t\tlsn = InvalidXLogRecPtr;\n\n\tresetStringInfo(ctx->out);\n\n\tpq_sendbyte(ctx->out, 'w');\n\tpq_sendint64(ctx->out, lsn);\t/* dataStart */\n\tpq_sendint64(ctx->out, lsn);\t/* walEnd */\n\n\t/*\n\t * Fill out the sendtime later, just as it's done in XLogSendPhysical, but\n\t * reserve space here.\n\t */\n\tpq_sendint64(ctx->out, 0);\t/* sendtime */\n}",
        "output": "0",
        "idx": 964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)\n{\n\treturn le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +\n\t       sizeof(struct RESTART_TABLE);\n}",
        "output": "0",
        "idx": 503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n",
        "output": "1",
        "idx": 3115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)\n\n{\n\n   return pthread_equal(thread1->thread, thread2->thread);\n\n}\n",
        "output": "0",
        "idx": 5307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void maybe_unmark_and_push(struct sock *x)\n{\n\tstruct unix_sock *u = unix_sk(x);\n\n\tif (u->gc_tree != GC_ORPHAN)\n\t\treturn;\n\tsock_hold(x);\n\tu->gc_tree = gc_current;\n\tgc_current = x;\n}",
        "output": "1",
        "idx": 527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu;\n\tstruct cpuinfo_x86 *c;\n\n\tcpu = iminor(file->f_path.dentry->d_inode);\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t/* No such CPU */\n\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t/* MSR not supported */\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 84
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {\n    uint8_t buffer[5];\n    uint8_t request_dummy[4] = {0x81, 0, 0, 0}; /* a zero-length request */\n\n    (void)opt; /* squash the unused parameter warning */\n    if(phase!=PROTOCOL_MIDDLE)\n        return NULL;\n    s_write(c, c->remote_fd.fd, request_dummy, 4);\n    s_read(c, c->remote_fd.fd, buffer, 5);\n    if(buffer[0]!=0x83) { /* NB_SSN_NEGRESP */\n        s_log(LOG_ERR, \"Negative response expected\");\n        throw_exception(c, 1);\n    }\n    if(buffer[2]!=0 || buffer[3]!=1) { /* length != 1 */\n        s_log(LOG_ERR, \"Unexpected NetBIOS response size\");\n        throw_exception(c, 1);\n    }\n    if(buffer[4]!=0x8e) { /* use TLS */\n        s_log(LOG_ERR, \"Remote server does not require TLS\");\n        throw_exception(c, 1);\n    }\n    return NULL;\n}",
        "output": "0",
        "idx": 799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)\n\n{\n\n    int i;\n\n    int vlc    = get_bits1(&q->gb);\n\n    int start  = cplband[p->js_subband_start];\n\n    int end    = cplband[p->subbands - 1];\n\n    int length = end - start + 1;\n\n\n\n    if (start > end)\n\n        return;\n\n\n\n    if (vlc)\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);\n\n}\n",
        "output": "0",
        "idx": 1745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)\n\n{\n\n    /* TO FIX */\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 1513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_answer_rsa_challenge(int sock, Buffer *m)\n{\n\tKey *key = NULL;\n\tu_char *blob;\n\tu_int blen;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authctxt not valid\", __func__);\n\tblob = buffer_get_string(m, &blen);\n\tif (!monitor_allowed_key(blob, blen))\n\t\tfatal(\"%s: bad key, not previously allowed\", __func__);\n\tif (key_blobtype != MM_RSAUSERKEY && key_blobtype != MM_RSAHOSTKEY)\n\t\tfatal(\"%s: key type mismatch\", __func__);\n\tif ((key = key_from_blob(blob, blen)) == NULL)\n\t\tfatal(\"%s: received bad key\", __func__);\n\n\tif (ssh1_challenge)\n\t\tBN_clear_free(ssh1_challenge);\n\tssh1_challenge = auth_rsa_generate_challenge(key);\n\n\tbuffer_clear(m);\n\tbuffer_put_bignum2(m, ssh1_challenge);\n\n\tdebug3(\"%s sending reply\", __func__);\n\tmm_request_send(sock, MONITOR_ANS_RSACHALLENGE, m);\n\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_RSARESPONSE, 1);\n\n\txfree(blob);\n\tkey_free(key);\n\treturn (0);\n}",
        "output": "0",
        "idx": 4285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}",
        "output": "1",
        "idx": 3134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tchar *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_value, TRUE, &value_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value_name);\n\n\treturn offset;\n}",
        "output": "0",
        "idx": 2432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rtnl_talk_extack(struct rtnl_handle *rtnl, struct nlmsghdr *n,\n\t\t     struct nlmsghdr **answer,\n\t\t     nl_ext_ack_fn_t errfn)\n{\n\treturn __rtnl_talk(rtnl, n, answer, true, errfn);\n}",
        "output": "0",
        "idx": 1075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static InetSocketAddress *ssh_config(QDict *options, Error **errp)\n\n{\n\n    InetSocketAddress *inet = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"SSH server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return inet;\n\n}",
        "output": "1",
        "idx": 2168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *getusername(void)\n{\n\tchar *username = NULL;\n\tstruct passwd *password = getpwuid(getuid());\n\n\tif (password)\n\t\tusername = password->pw_name;\n\treturn username;\n}",
        "output": "1",
        "idx": 2679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DeepTiledInputFile::Data::getSampleCount(int x, int y)\n{\n    return sampleCount(sampleCountSliceBase,\n                       sampleCountXStride,\n                       sampleCountYStride,\n                       x, y);\n}",
        "output": "0",
        "idx": 2518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}",
        "output": "1",
        "idx": 600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   Returns TRUE if the mode outputs blocks of bytes */\nPHP_FUNCTION(mcrypt_module_is_block_mode)\n{\n\tMCRYPT_GET_MODE_DIR_ARGS(modes_dir)\n\t\n\tif (mcrypt_module_is_block_mode(module, dir) == 1) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}",
        "output": "1",
        "idx": 1017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)\n{\n\tNodeIDedItem *reg_node = sg->id_node;\n\twhile (reg_node) {\n\t\tif (reg_node->NodeID == nodeID) return reg_node->node;\n\t\treg_node = reg_node->next;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 5018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DEFINE_RUN_ONCE_STATIC(ossl_init_async)\n{\n#ifdef OPENSSL_INIT_DEBUG\n    fprintf(stderr, \"OPENSSL_INIT: ossl_init_async: async_init()\\n\");\n#endif\n    if (!async_init())\n        return 0;\n    async_inited = 1;\n    return 1;\n}",
        "output": "0",
        "idx": 4060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_mail_core_srv_conf_t *prev = parent;\n    ngx_mail_core_srv_conf_t *conf = child;\n\n    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n    ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,\n                              30000);\n\n\n    ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n\n    if (conf->server_name.len == 0) {\n        conf->server_name = cf->cycle->hostname;\n    }\n\n    if (conf->protocol == NULL) {\n        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                      \"unknown mail protocol for server in %s:%ui\",\n                      conf->file_name, conf->line);\n        return NGX_CONF_ERROR;\n    }\n\n    if (conf->error_log == NULL) {\n        if (prev->error_log) {\n            conf->error_log = prev->error_log;\n        } else {\n            conf->error_log = &cf->cycle->new_log;\n        }\n    }\n\n    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);\n\n    return NGX_CONF_OK;\n}",
        "output": "1",
        "idx": 498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ogmaudio_type_find (GstTypeFind * tf, gpointer private)\n{\n  const guint8 *data = gst_type_find_peek (tf, 0, 9);\n\n  if (data) {\n    if (memcmp (data, \"\\001audio\\000\\000\\000\", 9) != 0)\n      return;\n    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);\n  }\n}",
        "output": "0",
        "idx": 1899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _hostsock_getpeername(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_getpeername_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)addr,\n            addrlen_in,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}",
        "output": "1",
        "idx": 6157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QUtil::hex_decode(std::string const& input)\n{\n    std::string result;\n    size_t pos = 0;\n    for (std::string::const_iterator p = input.begin(); p != input.end(); ++p)\n    {\n        char ch = *p;\n        bool skip = false;\n        if ((*p >= 'A') && (*p <= 'F'))\n        {\n            ch -= 'A';\n            ch += 10;\n        }\n        else if ((*p >= 'a') && (*p <= 'f'))\n        {\n            ch -= 'a';\n            ch += 10;\n        }\n        else if ((*p >= '0') && (*p <= '9'))\n        {\n            ch -= '0';\n        }\n        else\n        {\n            skip = true;\n        }\n        if (! skip)\n        {\n            if (pos == 0)\n            {\n                result.push_back(ch << 4);\n                pos = 1;\n            }\n            else\n            {\n                result[result.length()-1] += ch;\n                pos = 0;\n            }\n        }\n    }\n    return result;\n}",
        "output": "1",
        "idx": 3642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)\n{\n\tif (file1 < file2) {\n\t\tmutex_unlock(&file2->mut);\n\t\tmutex_unlock(&file1->mut);\n\t} else {\n\t\tmutex_unlock(&file1->mut);\n\t\tmutex_unlock(&file2->mut);\n\t}\n}",
        "output": "1",
        "idx": 1256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n",
        "output": "1",
        "idx": 1978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int export(AVFilterContext *ctx, StreamContext *sc, int input)\n{\n    SignatureContext* sic = ctx->priv;\n    char filename[1024];\n\n    if (sic->nb_inputs > 1) {\n        /* error already handled */\n        av_assert0(av_get_frame_filename(filename, sizeof(filename), sic->filename, input) == 0);\n    } else {\n        strcpy(filename, sic->filename);\n    }\n    if (sic->format == FORMAT_XML) {\n        return xml_export(ctx, sc, filename);\n    } else {\n        return binary_export(ctx, sc, filename);\n    }\n}",
        "output": "1",
        "idx": 2384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        if (alac->sample_size == 16) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n",
        "output": "0",
        "idx": 2005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int IsSpace(int enc, int c)\n{\n  if (enc == ASCII)\n    return isspace(c);\n\n  if (c >= 0x09 && c <= 0x0d) return 1;\n  if (c == 0x20) return 1;\n\n  switch (enc) {\n  case UNICODE_ISO_8859_1:\n    if (c == 0x85) return 1;\n    /* fall */\n  case ISO_8859_1:\n  case ISO_8859_2:\n  case ISO_8859_3:\n  case ISO_8859_4:\n  case ISO_8859_5:\n  case ISO_8859_6:\n  case ISO_8859_7:\n  case ISO_8859_8:\n  case ISO_8859_9:\n  case ISO_8859_10:\n  case ISO_8859_11:\n  case ISO_8859_13:\n  case ISO_8859_14:\n  case ISO_8859_15:\n  case ISO_8859_16:\n  case KOI8:\n    if (c == 0xa0) return 1;\n    break;\n\n  case KOI8_R:\n    if (c == 0x9a) return 1;\n    break;\n\n  default:\n    exit(-1);\n  }\n\n  return 0;\n}",
        "output": "0",
        "idx": 3628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Multiupdate_prelocking_strategy::reset(THD *thd)\n{\n  done= false;\n  has_prelocking_list= thd->lex->requires_prelocking();\n}",
        "output": "0",
        "idx": 4750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    gic_cpu_write(s, id, addr, value);\n\n}\n",
        "output": "0",
        "idx": 2999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n",
        "output": "0",
        "idx": 3094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}",
        "output": "0",
        "idx": 5127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int acp_early_init(void *handle)\n{\n\treturn 0;\n}",
        "output": "0",
        "idx": 1632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {\n  // we only care about upstream protocol.\n  if (upstreamProtocol() != Http::CodecType::HTTP2) {\n    return;\n  }\n  useAccessLog(\"%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% \"\n               \"%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%\");\n  testRouterRequestAndResponseWithBody(100, 100, false);\n  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),\n                                       BytesCountExpectation(177, 173, 68, 64),\n                                       BytesCountExpectation(111, 113, 8, 8));\n}",
        "output": "0",
        "idx": 2959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n",
        "output": "0",
        "idx": 4101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);\n\n}\n",
        "output": "0",
        "idx": 2036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_cabac_mb_cbp_luma( H264Context *h) {\n\n    int cbp_b, cbp_a, ctx, cbp = 0;\n\n\n\n    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;\n\n    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;\n\n\n\n    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);\n\n    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;\n\n    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;\n\n    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;\n\n    return cbp;\n\n}\n",
        "output": "0",
        "idx": 1482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_acl_remove(qemu_acl *acl,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n        i++;\n\n        if (strcmp(entry->match, match) == 0) {\n\n            TAILQ_REMOVE(&acl->entries, entry, next);\n\n            return i;\n\n        }\n\n    }\n\n    return -1;\n\n}\n",
        "output": "0",
        "idx": 2674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PackBSDElf32x86::~PackBSDElf32x86()\n{\n}",
        "output": "0",
        "idx": 1707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void s390_machine_initfn(Object *obj)\n\n{\n\n    object_property_add_bool(obj, \"aes-key-wrap\",\n\n                             machine_get_aes_key_wrap,\n\n                             machine_set_aes_key_wrap, NULL);\n\n    object_property_set_description(obj, \"aes-key-wrap\",\n\n            \"enable/disable AES key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"aes-key-wrap\", NULL);\n\n\n\n    object_property_add_bool(obj, \"dea-key-wrap\",\n\n                             machine_get_dea_key_wrap,\n\n                             machine_set_dea_key_wrap, NULL);\n\n    object_property_set_description(obj, \"dea-key-wrap\",\n\n            \"enable/disable DEA key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"dea-key-wrap\", NULL);\n\n    object_property_add_str(obj, \"loadparm\",\n\n            machine_get_loadparm, machine_set_loadparm, NULL);\n\n    object_property_set_description(obj, \"loadparm\",\n\n            \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\"\n\n            \" to upper case) to pass to machine loader, boot manager,\"\n\n            \" and guest kernel\",\n\n\n\n\n\n\n\n\n\n}",
        "output": "1",
        "idx": 5274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx)\n{\n    SeqVideoContext *seq = avctx->priv_data;\n    seq->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    seq->frame = av_frame_alloc();\n    if (!seq->frame)\n        return AVERROR(ENOMEM);\n    return 0;\n}",
        "output": "1",
        "idx": 3753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}",
        "output": "1",
        "idx": 5452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}",
        "output": "1",
        "idx": 6314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}",
        "output": "1",
        "idx": 3578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n",
        "output": "1",
        "idx": 4435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int film_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 4)\n\n        return 0;\n\n\n\n    if (AV_RB32(&p->buf[0]) != FILM_TAG)\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n",
        "output": "0",
        "idx": 3922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tlb_flush_page(CPUState *env, target_ulong addr)\n\n{\n\n    int i;\n\n\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_flush_page: \" TARGET_FMT_lx \"\\n\", addr);\n\n#endif\n\n    /* must reset current TB so that interrupts cannot modify the\n\n       links while we are modifying them */\n\n    env->current_tb = NULL;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    tlb_flush_entry(&env->tlb_table[0][i], addr);\n\n    tlb_flush_entry(&env->tlb_table[1][i], addr);\n\n#if (NB_MMU_MODES >= 3)\n\n    tlb_flush_entry(&env->tlb_table[2][i], addr);\n\n#if (NB_MMU_MODES == 4)\n\n    tlb_flush_entry(&env->tlb_table[3][i], addr);\n\n#endif\n\n#endif\n\n\n\n    tlb_flush_jmp_cache(env, addr);\n\n\n\n#ifdef USE_KQEMU\n\n    if (env->kqemu_enabled) {\n\n        kqemu_flush_page(env, addr);\n\n    }\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 5525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "network_init ()\n{\n#ifdef HAVE_GNUTLS\n    char *ca_path, *ca_path2;\n\n    gnutls_global_init ();\n    gnutls_certificate_allocate_credentials (&gnutls_xcred);\n    \n    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));\n    if (ca_path)\n    {\n        ca_path2 = string_replace (ca_path, \"%h\", weechat_home);\n        if (ca_path2)\n        {\n            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,\n                                                    GNUTLS_X509_FMT_PEM);\n            free (ca_path2);\n        }\n        free (ca_path);\n    }\n    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n                                                     &hook_connect_gnutls_set_certificates);\n    network_init_ok = 1;\n#endif\n#ifdef HAVE_GCRYPT\n    gcry_check_version (GCRYPT_VERSION);\n    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n}",
        "output": "1",
        "idx": 5484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,\n\t\t\t\tvoid *user_data, bt_att_destroy_func_t destroy)\n{\n\tif (!att)\n\t\treturn false;\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tatt->debug_callback = callback;\n\tatt->debug_destroy = destroy;\n\tatt->debug_data = user_data;\n\n\treturn true;\n}",
        "output": "0",
        "idx": 2625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static const char* ConvertScalar(PyObject* v, tstring* out) {\n    if (PyBytes_Check(v)) {\n      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));\n      return nullptr;\n    }\n    if (PyUnicode_Check(v)) {\n#if PY_MAJOR_VERSION >= 3\n      Py_ssize_t size;\n      const char* str = PyUnicode_AsUTF8AndSize(v, &size);\n      if (str == nullptr) return ErrorConvertingUnicodeString;\n      out->assign(str, size);\n      return nullptr;\n#else\n      PyObject* py_str = PyUnicode_AsUTF8String(v);\n      if (py_str == nullptr) return ErrorConvertingUnicodeString;\n      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));\n      Py_DECREF(py_str);\n      return nullptr;\n#endif\n    }\n    return ErrorMixedTypes;\n  }",
        "output": "1",
        "idx": 4505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_lou_findOpcodeNumber(const char *toFind) {\n\t/* Used by tools such as lou_debug */\n\tstatic TranslationTableOpcode lastOpcode = 0;\n\tTranslationTableOpcode opcode = lastOpcode;\n\tint length = (int)strlen(toFind);\n\tdo {\n\t\tif (length == opcodeLengths[opcode] &&\n\t\t\t\tstrcasecmp(toFind, opcodeNames[opcode]) == 0) {\n\t\t\tlastOpcode = opcode;\n\t\t\treturn opcode;\n\t\t}\n\t\topcode++;\n\t\tif (opcode >= CTO_None) opcode = 0;\n\t} while (opcode != lastOpcode);\n\treturn CTO_None;\n}",
        "output": "0",
        "idx": 4662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n",
        "output": "1",
        "idx": 6106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);\n\n\tmemslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_RH_HIERARCHY_POLICY_Unmarshal(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n    \n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case TPM_RH_OWNER:\n\t  case TPM_RH_PLATFORM:\n\t  case TPM_RH_ENDORSEMENT:\n\t  case TPM_RH_LOCKOUT:\n\t    break;\n\t  default:\n\t      {\n\t\t  BOOL isNotHP =  (*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F);\n\t\t  if (isNotHP) {\n\t\t      rc = TPM_RC_VALUE;\n\t\t  }\n\t      }\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 1542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_int(struct kernel_vm86_regs *regs, int i,\n    unsigned char __user *ssp, unsigned short sp)\n{\n\tunsigned long __user *intr_ptr;\n\tunsigned long segoffs;\n\n\tif (regs->pt.cs == BIOSSEG)\n\t\tgoto cannot_handle;\n\tif (is_revectored(i, &KVM86->int_revectored))\n\t\tgoto cannot_handle;\n\tif (i == 0x21 && is_revectored(AH(regs), &KVM86->int21_revectored))\n\t\tgoto cannot_handle;\n\tintr_ptr = (unsigned long __user *) (i << 2);\n\tif (get_user(segoffs, intr_ptr))\n\t\tgoto cannot_handle;\n\tif ((segoffs >> 16) == BIOSSEG)\n\t\tgoto cannot_handle;\n\tpushw(ssp, sp, get_vflags(regs), cannot_handle);\n\tpushw(ssp, sp, regs->pt.cs, cannot_handle);\n\tpushw(ssp, sp, IP(regs), cannot_handle);\n\tregs->pt.cs = segoffs >> 16;\n\tSP(regs) -= 6;\n\tIP(regs) = segoffs & 0xffff;\n\tclear_TF(regs);\n\tclear_IF(regs);\n\tclear_AC(regs);\n\treturn;\n\ncannot_handle:\n\treturn_to_32bit(regs, VM86_INTx + (i << 8));\n}",
        "output": "0",
        "idx": 5581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "disp_idle_fn(ev, data)\nstruct event *ev;\nchar *data;\n{\n  struct display *olddisplay;\n  display = (struct display *)data;\n  debug(\"idle timeout\\n\");\n  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)\n    return;\n  olddisplay = display;\n  flayer = D_forecv->c_layer;\n  fore = D_fore;\n  DoAction(&idleaction, -1);\n  if (idleaction.nr == RC_BLANKER)\n    return;\n  for (display = displays; display; display = display->d_next)\n    if (olddisplay == display)\n      break;\n  if (display)\n    ResetIdle();\n}",
        "output": "0",
        "idx": 5424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool safecmp(char *a, char *b)\n{\n  if(a && b)\n    return !strcmp(a, b);\n  else if(!a && !b)\n    return TRUE; /* match */\n  return FALSE; /* no match */\n}",
        "output": "1",
        "idx": 5000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ZLIB_INTERNAL _tr_align(s)\n    deflate_state *s;\n{\n    send_bits(s, STATIC_TREES<<1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n#ifdef ZLIB_DEBUG\n    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */\n#endif\n    bi_flush(s);\n}",
        "output": "0",
        "idx": 1998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_intthrow(cstack_T *cstack)\n{\n    /*\n     * If no interrupt occurred or no try conditional is active and no exception\n     * is being thrown, do nothing (for compatibility of non-EH scripts).\n     */\n    if (!got_int || (trylevel == 0 && !did_throw))\n\treturn FALSE;\n\n#ifdef THROW_TEST\t// avoid warning for condition always true\n    if (!THROW_ON_INTERRUPT)\n    {\n\t/*\n\t * The interrupt aborts everything except for executing finally clauses.\n\t * Discard any user or error or interrupt exception currently being\n\t * thrown.\n\t */\n\tif (did_throw)\n\t    discard_current_exception();\n    }\n    else\n#endif\n    {\n\t/*\n\t * Throw an interrupt exception, so that everything will be aborted\n\t * (except for executing finally clauses), until the interrupt exception\n\t * is caught; if still uncaught at the top level, the script processing\n\t * will be terminated then.  -  If an interrupt exception is already\n\t * being thrown, do nothing.\n\t *\n\t */\n\tif (did_throw)\n\t{\n\t    if (current_exception->type == ET_INTERRUPT)\n\t\treturn FALSE;\n\n\t    // An interrupt exception replaces any user or error exception.\n\t    discard_current_exception();\n\t}\n\tif (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) != FAIL)\n\t    do_throw(cstack);\n    }\n\n    return TRUE;\n}",
        "output": "0",
        "idx": 5499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();",
        "output": "1",
        "idx": 183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFWriter::unparseObject(QPDFObjectHandle object, int level,\n\t\t\t  unsigned int flags)\n{\n    unparseObject(object, level, flags, 0, false);\n}",
        "output": "1",
        "idx": 4244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n",
        "output": "1",
        "idx": 3679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n",
        "output": "0",
        "idx": 477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n",
        "output": "1",
        "idx": 3942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fetch_result_int32(MYSQL_BIND *param,\n                               MYSQL_FIELD *field __attribute__((unused)),\n                               uchar **row)\n{\n  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);\n  uint32 data= (uint32) sint4korr(*row);\n  longstore(param->buffer, data);\n  *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;\n  *row+= 4;\n}",
        "output": "0",
        "idx": 3213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mmap_release_buffer(AVPacket *pkt)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res, fd;\n\n    struct buff_data *buf_descriptor = pkt->priv;\n\n\n\n    if (pkt->data == NULL)\n\n        return;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    buf.index = buf_descriptor->index;\n\n    fd = buf_descriptor->fd;\n\n    av_free(buf_descriptor);\n\n\n\n    res = ioctl(fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0)\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n               strerror(errno));\n\n\n\n    pkt->data = NULL;\n\n    pkt->size = 0;\n\n}\n",
        "output": "0",
        "idx": 348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}",
        "output": "1",
        "idx": 3865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
        "output": "0",
        "idx": 2614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "changed_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}",
        "output": "0",
        "idx": 2654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n\n    return njs_promise(&capability->promise);\n}",
        "output": "1",
        "idx": 1627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_attr_as4_aggregator (struct peer *peer, bgp_size_t length,\n\t\t     struct attr *attr, u_char flag, \n\t\t     as_t *as4_aggregator_as,\n\t\t     struct in_addr *as4_aggregator_addr,\n\t\t     u_char *startp)\n{\n  bgp_size_t total;\n  \n  if (length != 8)\n    {\n      zlog (peer->log, LOG_ERR, \"New Aggregator length is not 8 [%d]\", length);\n      return bgp_attr_malformed (peer, BGP_ATTR_AS4_AGGREGATOR, flag,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 NULL, 0);\n    }\n  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);\n  /* Flags check. */\n  if (bgp_attr_flag_invalid (peer, BGP_ATTR_AS4_AGGREGATOR, flag))\n    return bgp_attr_malformed (peer, BGP_ATTR_AS4_AGGREGATOR, flag,\n                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n                               startp, total);\n  \n  *as4_aggregator_as = stream_getl (peer->ibuf);\n  as4_aggregator_addr->s_addr = stream_get_ipv4 (peer->ibuf);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_AGGREGATOR);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}",
        "output": "1",
        "idx": 1617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int InstanceKlass::find_method_by_name(const Array<Method*>* methods,\n                                       const Symbol* name,\n                                       int* end_ptr) {\n  assert(end_ptr != NULL, \"just checking\");\n  int start = quick_search(methods, name);\n  int end = start + 1;\n  if (start != -1) {\n    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;\n    while (end < methods->length() && (methods->at(end))->name() == name) ++end;\n    *end_ptr = end;\n    return start;\n  }\n  return -1;\n}",
        "output": "0",
        "idx": 1210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n\n    return result;\n}",
        "output": "1",
        "idx": 4268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "session_worker_child_watch (GPid              pid,\n                            int               status,\n                            GdmSessionWorker *worker)\n{\n        g_debug (\"GdmSessionWorker: child (pid:%d) done (%s:%d)\",\n                 (int) pid,\n                 WIFEXITED (status) ? \"status\"\n                 : WIFSIGNALED (status) ? \"signal\"\n                 : \"unknown\",\n                 WIFEXITED (status) ? WEXITSTATUS (status)\n                 : WIFSIGNALED (status) ? WTERMSIG (status)\n                 : -1);\n\n\n        gdm_session_worker_uninitialize_pam (worker, PAM_SUCCESS);\n\n        gdm_dbus_worker_emit_session_exited (GDM_DBUS_WORKER (worker),\n                                             worker->priv->service,\n                                             status);\n\n        killpg (pid, SIGHUP);\n\n        worker->priv->child_pid = -1;\n        worker->priv->child_watch_id = 0;\n        run_script (worker, GDMCONFDIR \"/PostSession\");\n}",
        "output": "1",
        "idx": 4571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dense_rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ) p->nStep = 1;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}",
        "output": "0",
        "idx": 5174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->bits_per_sample = value;\n\treturn true;\n}",
        "output": "0",
        "idx": 5663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n",
        "output": "1",
        "idx": 3612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Status AuthorizationManager::getRolesDescription(OperationContext* txn,\n                                                 const std::vector<RoleName>& roleName,\n                                                 PrivilegeFormat privileges,\n                                                 BSONObj* result) {\n    return _externalState->getRolesDescription(txn, roleName, privileges, result);\n}",
        "output": "0",
        "idx": 2656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ladr_match(PCNetState *s, const uint8_t *buf, int size)\n{\n    struct qemu_ether_header *hdr = (void *)buf;\n    if ((*(hdr->ether_dhost)&0x01) &&\n        ((uint64_t *)&s->csr[8])[0] != 0LL) {\n        uint8_t ladr[8] = {\n            s->csr[8] & 0xff, s->csr[8] >> 8,\n            s->csr[9] & 0xff, s->csr[9] >> 8,\n            s->csr[10] & 0xff, s->csr[10] >> 8,\n            s->csr[11] & 0xff, s->csr[11] >> 8\n        };\n        int index = net_crc32_le(hdr->ether_dhost, ETH_ALEN) >> 26;\n        return !!(ladr[index >> 3] & (1 << (index & 7)));\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 3368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,\n                                          const uECC_word_t *left,\n                                          uECC_Curve curve) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_square(product, left, curve->num_words);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}",
        "output": "0",
        "idx": 1169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)\n{\n  if (!lseek_or_error (file, beg))\n    return false;\n\n  while (beg < end)\n    {\n      size_t bytes_read;\n      size_t rdsize = BLOCKSIZE < end - beg ? BLOCKSIZE : end - beg;\n      char diff_buffer[BLOCKSIZE];\n\n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     beg,\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      if (!zero_block_p (diff_buffer, bytes_read))\n\t{\n\t  char begbuf[INT_BUFSIZE_BOUND (off_t)];\n \t  report_difference (file->stat_info,\n\t\t\t     _(\"File fragment at %s is not a hole\"),\n\t\t\t     offtostr (beg, begbuf));\n\t  return false;\n\t}\n\n      beg += bytes_read;\n    }\n  return true;\n}",
        "output": "1",
        "idx": 2622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\n\trxent = &rx_cache[rx_cache_next];\n\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n\tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n\trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n\trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n}",
        "output": "1",
        "idx": 1962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(HeaderIntegrationTest, TestVirtualHostAppendHeaderManipulation) {\n  initializeFilter(HeaderMode::Append, false);\n  performRequest(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"GET\"},\n          {\":path\", \"/vhost-only\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"vhost-headers.com\"},\n          {\"x-vhost-request\", \"downstream\"},\n          {\"x-vhost-request-remove\", \"downstream\"},\n      },\n      Http::TestRequestHeaderMapImpl{\n          {\":authority\", \"vhost-headers.com\"},\n          {\"x-vhost-request\", \"downstream\"},\n          {\"x-vhost-request\", \"vhost\"},\n          {\":path\", \"/vhost-only\"},\n          {\":method\", \"GET\"},\n      },\n      Http::TestResponseHeaderMapImpl{\n          {\"server\", \"envoy\"},\n          {\"content-length\", \"0\"},\n          {\":status\", \"200\"},\n          {\"x-vhost-response\", \"upstream\"},\n          {\"x-vhost-response-remove\", \"upstream\"},\n      },\n      Http::TestResponseHeaderMapImpl{\n          {\"server\", \"envoy\"},\n          {\"x-vhost-response\", \"upstream\"},\n          {\"x-vhost-response\", \"vhost\"},\n          {\":status\", \"200\"},\n      });\n}",
        "output": "0",
        "idx": 406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlInitParser(void) {\n    if (xmlParserInitialized != 0)\n\treturn;\n\n#ifdef LIBXML_THREAD_ENABLED\n    __xmlGlobalInitMutexLock();\n    if (xmlParserInitialized == 0) {\n#endif\n\txmlInitThreads();\n\txmlInitGlobals();\n\tif ((xmlGenericError == xmlGenericErrorDefaultFunc) ||\n\t    (xmlGenericError == NULL))\n\t    initGenericErrorDefaultFunc(NULL);\n\txmlInitMemory();\n\txmlInitCharEncodingHandlers();\n\txmlDefaultSAXHandlerInit();\n\txmlRegisterDefaultInputCallbacks();\n#ifdef LIBXML_OUTPUT_ENABLED\n\txmlRegisterDefaultOutputCallbacks();\n#endif /* LIBXML_OUTPUT_ENABLED */\n#ifdef LIBXML_HTML_ENABLED\n\thtmlInitAutoClose();\n\thtmlDefaultSAXHandlerInit();\n#endif\n#ifdef LIBXML_XPATH_ENABLED\n\txmlXPathInit();\n#endif\n\txmlParserInitialized = 1;\n#ifdef LIBXML_THREAD_ENABLED\n    }\n    __xmlGlobalInitMutexUnlock();\n#endif\n}",
        "output": "0",
        "idx": 4660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}",
        "output": "1",
        "idx": 2255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)\r\n{\r\n  THandles OtherInstances;\r\n  FindOtherInstances(OtherInstances);\r\n\r\n  THandles::const_iterator I = OtherInstances.begin();\r\n  while (I != OtherInstances.end())\r\n  {\r\n    HWND Handle = *I;\r\n\r\n    TCopyDataMessage Message;\r\n    Message.Command = TCopyDataMessage::RefreshPanel;\r\n    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));\r\n    NULL_TERMINATE(Message.Refresh.Session);\r\n    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));\r\n    NULL_TERMINATE(Message.Refresh.Path);\r\n\r\n    SendCopyDataMessage(Handle, Message);\r\n\r\n    I++;\r\n  }\r\n}\r",
        "output": "0",
        "idx": 3004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xemaclite_disable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t/* Disable the Global Interrupt Enable */\n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n\n\t/* Disable the Tx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t/* Disable the Rx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_RSR_OFFSET);\n}",
        "output": "0",
        "idx": 6212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        work++;\n        if (!iswhite(uv))  /* upvalue already visited? */\n          markvalue(g, uv->v);  /* mark its value */\n      }\n    }\n  }\n  return work;\n}",
        "output": "1",
        "idx": 6133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_sched_in(struct preempt_notifier *pn, int cpu)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\n\tWRITE_ONCE(vcpu->preempted, false);\n\tWRITE_ONCE(vcpu->ready, false);\n\n\t__this_cpu_write(kvm_running_vcpu, vcpu);\n\tkvm_arch_sched_in(vcpu, cpu);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n}",
        "output": "0",
        "idx": 2451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ega_unpack_attr(id, attr, fg, bg, ul)\n\tvoid *id;\n\tlong attr;\n\tint *fg, *bg, *ul;\n{\n\tstruct egascreen *scr = id;\n\tstruct ega_config *vc = scr->cfg;\n\n\tif (vc->hdl.vh_mono) {\n\t\t*fg = (attr & 0x07) == 0x07 ? WSCOL_WHITE : WSCOL_BLACK;\n\t\t*bg = attr & 0x70 ? WSCOL_WHITE : WSCOL_BLACK;\n\t\tif (ul != NULL)\n\t\t\t*ul = *fg != WSCOL_WHITE && (attr & 0x01) ? 1 : 0;\n\t} else {\n\t\t*fg = pctoansi[attr & 0x07];\n\t\t*bg = pctoansi[(attr & 0x70) >> 4];\n\t\tif (*ul != NULL)\n\t\t\t*ul = 0;\n\t}\n\tif (attr & FG_INTENSE)\n\t\t*fg += 8;\n}",
        "output": "0",
        "idx": 2459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_isel(DisasContext *ctx)\n\n{\n\n    int l1, l2;\n\n    uint32_t bi = rC(ctx->opcode);\n\n    uint32_t mask;\n\n    TCGv_i32 t0;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    mask = 0x08 >> (bi & 0x03);\n\n    t0 = tcg_temp_new_i32();\n\n    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);\n\n    if (rA(ctx->opcode) == 0)\n\n        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);\n\n    else\n\n        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n",
        "output": "0",
        "idx": 5571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\tif (in)\n\t\tjas_stream_close(in);\n\treturn 0;\n}",
        "output": "1",
        "idx": 5012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "frame_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t/* don't make it negative */\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t/* Handle all the frames in the column. */\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else /* frp->fr_layout == FR_ROW */\n    {\n\t/* Only need to handle the last frame in the row. */\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}",
        "output": "0",
        "idx": 3591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tput_device(&dev->dev);\n\treturn 0;\n}",
        "output": "1",
        "idx": 3387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "http_cleanup (void)\n{\n  xfree (pconn.host);\n  if (wget_cookie_jar)\n    cookie_jar_delete (wget_cookie_jar);\n}",
        "output": "0",
        "idx": 5400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dtls1_process_buffered_records(SSL *s)\n{\n    pitem *item;\n\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item) {\n        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return (1);         /* Nothing to do. */\n\n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),\n                                    s->s3->rrec.seq_num) < 0)\n                return -1;\n        }\n    }\n\n    /*\n     * sync epoch numbers once all the unprocessed records have been\n     * processed\n     */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return (1);\n}",
        "output": "1",
        "idx": 6072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,\n\t\t\t       struct inode *inode)\n{\n\tint ret, inline_size = EXT4_MIN_INLINE_DATA_SIZE;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_dir_entry_2 *de;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_prepare_inline_data(handle, inode, inline_size);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * For inline dir, we only save the inode information for the \"..\"\n\t * and create a fake dentry to cover the left space.\n\t */\n\tde = (struct ext4_dir_entry_2 *)ext4_raw_inode(&iloc)->i_block;\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tde = (struct ext4_dir_entry_2 *)((void *)de + EXT4_INLINE_DOTDOT_SIZE);\n\tde->inode = 0;\n\tde->rec_len = ext4_rec_len_to_disk(\n\t\t\t\tinline_size - EXT4_INLINE_DOTDOT_SIZE,\n\t\t\t\tinline_size);\n\tset_nlink(inode, 2);\n\tinode->i_size = EXT4_I(inode)->i_disksize = inline_size;\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
        "output": "0",
        "idx": 5294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(openssl_error_string)\n{\n\tchar buf[256];\n\tunsigned long val;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_openssl_store_errors();\n\n\tif (OPENSSL_G(errors) == NULL || OPENSSL_G(errors)->top == OPENSSL_G(errors)->bottom) {\n\t\tRETURN_FALSE;\n\t}\n\n\tOPENSSL_G(errors)->bottom = (OPENSSL_G(errors)->bottom + 1) % ERR_NUM_ERRORS;\n\tval = OPENSSL_G(errors)->buffer[OPENSSL_G(errors)->bottom];\n\n\tif (val) {\n\t\tERR_error_string_n(val, buf, 256);\n\t\tRETURN_STRING(buf);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "0",
        "idx": 3743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double php_expm1(double x)\n{\n#if !defined(PHP_WIN32) && !defined(NETWARE)\n\treturn(expm1(x));\n#else\n\treturn(exp(x) - 1);\n#endif\n}",
        "output": "0",
        "idx": 3811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Load gif file, using ImageMagick or GraphicsMagick's external tool 'convert' \\newinstance.\n    static CImg<T> get_load_gif_external(const char *const filename,\n                                         const char axis='z', const float align=0) {\n      return CImgList<T>().load_gif_external(filename).get_append(axis,align);",
        "output": "0",
        "idx": 3145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int compat_do_execve(struct filename *filename,\n\tconst compat_uptr_t __user *__argv,\n\tconst compat_uptr_t __user *__envp)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}",
        "output": "0",
        "idx": 704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n",
        "output": "1",
        "idx": 5846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *ftab_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);\n\treturn (GF_Box *) tmp;\n}",
        "output": "0",
        "idx": 3075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {\n\tut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);\n\tif (bbaddr != UT64_MAX) {\n\t\tr_core_seek (core, bbaddr, false);\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 3060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 4281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm) \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n} /* linetoken */",
        "output": "1",
        "idx": 3931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }",
        "output": "0",
        "idx": 5206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FUNC(ff_simple_idct)(DCTELEM *block)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctRowCondDC)(block + i*8);\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctSparseCol)(block + i);\n\n}\n",
        "output": "1",
        "idx": 4741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,\n\n                       const int inc, void *y_tab)\n\n{\n\n    int i;\n\n    uint8_t *y_table = y_tab;\n\n\n\n    y_table -= elemsize * (inc >> 9);\n\n\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n\n        table[i] = y_table + elemsize * (cb >> 16);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}",
        "output": "1",
        "idx": 4561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool add_cgpu(struct cgpu_info*cgpu)\n{\n\tstatic struct _cgpu_devid_counter *devids = NULL;\n\tstruct _cgpu_devid_counter *d;\n\t\n\tHASH_FIND_STR(devids, cgpu->drv->name, d);\n\tif (d)\n\t\tcgpu->device_id = ++d->lastid;\n\telse {\n\t\td = malloc(sizeof(*d));\n\t\tmemcpy(d->name, cgpu->drv->name, sizeof(d->name));\n\t\tcgpu->device_id = d->lastid = 0;\n\t\tHASH_ADD_STR(devids, name, d);\n\t}\n\n\twr_lock(&devices_lock);\n\tdevices = realloc(devices, sizeof(struct cgpu_info *) * (total_devices + new_devices + 2));\n\twr_unlock(&devices_lock);\n\n\tif (hotplug_mode)\n\t\tdevices[total_devices + new_devices++] = cgpu;\n\telse\n\t\tdevices[total_devices++] = cgpu;\n\treturn true;\n}",
        "output": "0",
        "idx": 1342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API const char *r_str_sep(const char *base, const char *sep) {\n\tint i;\n\twhile (*base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*base == sep[i]) {\n\t\t\t\treturn base;\n\t\t\t}\n\t\t}\n\t\tbase++;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 2185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {\n\tUDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;\n\t\n\tswitch (requestedVersion) {\n\tcase JNI_VERSION_1_2:\n\tcase JNI_VERSION_1_4:\n\tcase JNI_VERSION_1_6:\n\tcase JNI_VERSION_1_8:\n\tcase JNI_VERSION_9:\n\tcase JNI_VERSION_10:\n\t\treturn JNI_OK;\n\t}\n\t\n\treturn JNI_EVERSION;\t\n}",
        "output": "0",
        "idx": 1379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n",
        "output": "1",
        "idx": 4445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n",
        "output": "1",
        "idx": 426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit inet6_exit(void)\n{\n\tif (disable_ipv6_mod)\n\t\treturn;\n\n\t/* First of all disallow new sockets creation. */\n\tsock_unregister(PF_INET6);\n\t/* Disallow any further netlink messages */\n\trtnl_unregister_all(PF_INET6);\n\n\tudpv6_exit();\n\tudplitev6_exit();\n\ttcpv6_exit();\n\n\t/* Cleanup code parts. */\n\tipv6_packet_cleanup();\n\tipv6_frag_exit();\n\tipv6_exthdrs_exit();\n\taddrconf_cleanup();\n\tip6_flowlabel_cleanup();\n\tip6_route_cleanup();\n#ifdef CONFIG_PROC_FS\n\n\t/* Cleanup code parts. */\n\tif6_proc_exit();\n\tipv6_misc_proc_exit();\n\tudplite6_proc_exit();\n\traw6_proc_exit();\n#endif\n\tipv6_netfilter_fini();\n\tigmp6_cleanup();\n\tndisc_cleanup();\n\tip6_mr_cleanup();\n\ticmpv6_cleanup();\n\trawv6_exit();\n\n\tunregister_pernet_subsys(&inet6_net_ops);\n\tproto_unregister(&rawv6_prot);\n\tproto_unregister(&udplitev6_prot);\n\tproto_unregister(&udpv6_prot);\n\tproto_unregister(&tcpv6_prot);\n\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n}",
        "output": "1",
        "idx": 4519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_co_request(BlockDriverState *bs,\n\n                          NBDRequest *request,\n\n                          QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    if (qiov) {\n\n        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);\n\n        assert(request->len == iov_size(qiov->iov, qiov->niov));\n\n    } else {\n\n        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);\n\n    }\n\n    ret = nbd_co_send_request(bs, request,\n\n                              request->type == NBD_CMD_WRITE ? qiov : NULL);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nbd_co_receive_reply(client, request->handle,\n\n                                request->type == NBD_CMD_READ ? qiov : NULL);\n\n}\n",
        "output": "1",
        "idx": 5972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ldb_kv_guid_to_key(struct ldb_module *module,\n\t\t       struct ldb_kv_private *ldb_kv,\n\t\t       const struct ldb_val *GUID_val,\n\t\t       struct ldb_val *key)\n{\n\tconst char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;\n\tconst int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;\n\n\tif (key->length != (GUID_val->length+GUID_prefix_len)) {\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tmemcpy(key->data, GUID_prefix, GUID_prefix_len);\n\tmemcpy(&key->data[GUID_prefix_len],\n\t       GUID_val->data, GUID_val->length);\n\treturn LDB_SUCCESS;\n}",
        "output": "0",
        "idx": 5466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t   unsigned long payload)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);\n}",
        "output": "0",
        "idx": 3769
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_tpm2(GArray *table_data, BIOSLinker *linker)\n\n{\n\n    Acpi20TPM2 *tpm2_ptr;\n\n\n\n    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);\n\n\n\n    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);\n\n    tpm2_ptr->control_area_address = cpu_to_le64(0);\n\n    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tpm2_ptr, \"TPM2\", sizeof(*tpm2_ptr), 4, NULL, NULL);\n\n}\n",
        "output": "1",
        "idx": 2386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)\n{\n\tint r;\n\tconst u8 *val;\n\tsize_t val_len;\n\n\tr = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);\n\tif (r < 0) {\n\t\t/* attribute not valid for this object, set boolean to false */\n\t\treturn 0;\n\t}\n\tif ((val_len == 1) && (*val == 1)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int standard_decode_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0, index;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case P_TYPE: status = decode_p_picture_secondary_header(v); break;\n\n    case B_TYPE: status = decode_b_picture_secondary_header(v); break;\n\n    case BI_TYPE:\n\n    case I_TYPE: break; //Nothing needed as it's done in the epilog\n\n    }\n\n    if (status < 0) return FRAME_SKIPED;\n\n\n\n    /* AC Syntax */\n\n    v->ac_table_level = decode012(gb);\n\n    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)\n\n    {\n\n        v->ac2_table_level = decode012(gb);\n\n    }\n\n    /* DC Syntax */\n\n    index = decode012(gb);\n\n    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];\n\n    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];\n\n   \n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void _mutt_mktemp (char *s, size_t slen, const char *src, int line)\n{\n  snprintf (s, slen, \"%s/mutt-%s-%d-%d-%d\", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);\n  dprint (3, (debugfile, \"%s:%d: mutt_mktemp returns \\\"%s\\\".\\n\", src, line, s));\n  unlink (s);\n}",
        "output": "1",
        "idx": 4922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "z2grestoreall(i_ctx_t *i_ctx_p)\n{\n    for (;;) {\n        if (!restore_page_device(igs, gs_gstate_saved(igs))) {\n            bool done = !gs_gstate_saved(gs_gstate_saved(igs));\n\n            gs_grestore(igs);\n            if (done)\n                break;\n        } else\n            return push_callout(i_ctx_p, \"%grestoreallpagedevice\");\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 5389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  client_ecdsa_cert_ = true;\n  initialize();\n  EXPECT_FALSE(\n      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  EXPECT_EQ(1U, counter->value());\n  counter->reset();\n}",
        "output": "1",
        "idx": 3344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tadd_timer(&sk->sk_timer);\n}",
        "output": "1",
        "idx": 4036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n",
        "output": "1",
        "idx": 738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(L, fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(L, fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"integral size %d is larger than limit of %d\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}",
        "output": "1",
        "idx": 4820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ftp_current_dir(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    const char *command = \"PWD\\r\\n\";\n\n    const int pwd_codes[] = {257, 0};\n\n\n\n    if (!ftp_send_command(s, command, pwd_codes, &res))\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '\"') {\n\n            if (!start) {\n\n                start = res + i + 1;\n\n                continue;\n\n            }\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!end)\n\n        goto fail;\n\n\n\n    if (end > res && end[-1] == '/') {\n\n        end[-1] = '\\0';\n\n    } else\n\n        *end = '\\0';\n\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    return AVERROR(EIO);\n\n}\n",
        "output": "0",
        "idx": 2714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fts3DoAutoincrmerge(\n  Fts3Table *p,                   /* FTS3 table handle */\n  const char *zParam              /* Nul-terminated string containing boolean */\n){\n  int rc = SQLITE_OK;\n  sqlite3_stmt *pStmt = 0;\n  p->nAutoincrmerge = fts3Getint(&zParam);\n  if( p->nAutoincrmerge==1 || p->nAutoincrmerge>FTS3_MERGE_COUNT ){\n    p->nAutoincrmerge = 8;\n  }\n  if( !p->bHasStat ){\n    assert( p->bFts4==0 );\n    sqlite3Fts3CreateStatTable(&rc, p);\n    if( rc ) return rc;\n  }\n  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);\n  if( rc ) return rc;\n  sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);\n  sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);\n  sqlite3_step(pStmt);\n  rc = sqlite3_reset(pStmt);\n  return rc;\n}",
        "output": "1",
        "idx": 1778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nfcmrvl_parse_dt(struct device_node *node,\n\t\t     struct nfcmrvl_platform_data *pdata)\n{\n\tint reset_n_io;\n\n\treset_n_io = of_get_named_gpio(node, \"reset-n-io\", 0);\n\tif (reset_n_io < 0) {\n\t\tpr_info(\"no reset-n-io config\\n\");\n\t} else if (!gpio_is_valid(reset_n_io)) {\n\t\tpr_err(\"invalid reset-n-io GPIO\\n\");\n\t\treturn reset_n_io;\n\t}\n\tpdata->reset_n_io = reset_n_io;\n\n\tif (of_find_property(node, \"hci-muxed\", NULL))\n\t\tpdata->hci_muxed = 1;\n\telse\n\t\tpdata->hci_muxed = 0;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n",
        "output": "1",
        "idx": 2694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}",
        "output": "1",
        "idx": 4111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_gain_table(COOKContext *q) {\n\n    int i;\n\n    q->gain_size_factor = q->samples_per_channel/8;\n\n    for (i=0 ; i<23 ; i++) {\n\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n\n                               (1.0/(double)q->gain_size_factor));\n\n    }\n\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n\n}\n",
        "output": "1",
        "idx": 5306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)\n{\n\tmemset(info, 0, sizeof(*info));\n\tinfo->key.tp_dst = htons(dst_port);\n}",
        "output": "0",
        "idx": 2132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n",
        "output": "1",
        "idx": 482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
        "output": "1",
        "idx": 6171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)\n\n{\n\n    pkt->data      = NULL;\n\n    pkt->side_data = NULL;\n\n    if (pkt->buf) {\n\n        AVBufferRef *ref = av_buffer_ref(src->buf);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n        pkt->buf  = ref;\n\n        pkt->data = ref->data;\n\n    } else {\n\n        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);\n\n    }\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    pkt->destruct = dummy_destruct_packet;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (pkt->side_data_elems && dup)\n\n        pkt->side_data = src->side_data;\n\n    if (pkt->side_data_elems && !dup) {\n\n        return av_copy_packet_side_data(pkt, src);\n\n    }\n\n    return 0;\n\n\n\nfailed_alloc:\n\n    av_destruct_packet(pkt);\n\n    return AVERROR(ENOMEM);\n\n}\n",
        "output": "1",
        "idx": 2557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}",
        "output": "1",
        "idx": 1753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (!res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(resp);\n\treturn res;\n\n}",
        "output": "1",
        "idx": 4811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n",
        "output": "0",
        "idx": 5669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t sector_num, int nb_sectors,\n\n                            int64_t *cluster_sector_num,\n\n                            int *cluster_nb_sectors)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_sector_num = sector_num;\n\n        *cluster_nb_sectors = nb_sectors;\n\n    } else {\n\n        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;\n\n        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);\n\n        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +\n\n                                            nb_sectors, c);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ct_list_items(struct media_player *mp, const char *name,\n\t\t\t\tuint32_t start, uint32_t end, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\tstruct avrcp *session;\n\tstruct pending_list_items *p;\n\n\tif (player->p != NULL)\n\t\treturn -EBUSY;\n\n\tsession = player->sessions->data;\n\n\tset_ct_player(session, player);\n\n\tif (g_str_has_prefix(name, \"/NowPlaying\"))\n\t\tplayer->scope = 0x03;\n\telse if (g_str_has_suffix(name, \"/search\"))\n\t\tplayer->scope = 0x02;\n\telse\n\t\tplayer->scope = 0x01;\n\n\tavrcp_list_items(session, start, end);\n\n\tp = g_new0(struct pending_list_items, 1);\n\tp->start = start;\n\tp->end = end;\n\tp->total = (uint64_t) (p->end - p->start) + 1;\n\tplayer->p = p;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 22
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {\n  setup(false, \"\");\n\n  std::string response_code;\n  std::string response_body;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));\n\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {\n          response_code = std::string(headers.Status()->value().getStringView());\n        }));\n    decoder->decodeHeaders(std::move(headers), true);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(\"431\", response_code);\n  EXPECT_EQ(\"\", response_body);\n}",
        "output": "1",
        "idx": 3985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  usage( char*  execname )\n  {\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"ftgrid: simple glyph grid viewer -- part of the FreeType project\\n\" );\n    fprintf( stderr,  \"-----------------------------------------------------------\\n\" );\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\\n\",\n             execname );\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"  -r R      use resolution R dpi (default: 72 dpi)\\n\" );\n    fprintf( stderr,  \"  -f index  specify first index to display\\n\" );\n    fprintf( stderr,  \"\\n\" );\n\n    exit( 1 );\n  }",
        "output": "0",
        "idx": 5535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }",
        "output": "0",
        "idx": 1499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long) ep->id);\n}",
        "output": "1",
        "idx": 1591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)\n{\n\tint ret;\n\tu16 tmp16;\n\n\tax88179_phy_mmd_indirect(dev, prtad, devad);\n\n\tret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t       MII_MMD_DATA, 2, &tmp16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tmp16;\n}",
        "output": "0",
        "idx": 2402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}",
        "output": "0",
        "idx": 2723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n",
        "output": "1",
        "idx": 3636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int flv_write_trailer(AVFormatContext *s)\n\n{\n\n    int64_t file_size;\n\n\n\n    AVIOContext *pb = s->pb;\n\n    FLVContext *flv = s->priv_data;\n\n    int i;\n\n\n\n    /* Add EOS tag */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        FLVStreamContext *sc = s->streams[i]->priv_data;\n\n        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            enc->codec_id == AV_CODEC_ID_H264)\n\n            put_avc_eos_tag(pb, sc->last_ts);\n\n    }\n\n\n\n    file_size = avio_tell(pb);\n\n\n\n    /* update information */\n\n    avio_seek(pb, flv->duration_offset, SEEK_SET);\n\n    put_amf_double(pb, flv->duration / (double)1000);\n\n    avio_seek(pb, flv->filesize_offset, SEEK_SET);\n\n    put_amf_double(pb, file_size);\n\n\n\n    avio_seek(pb, file_size, SEEK_SET);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_pcm(HEVCContext *s, int x, int y)\n\n{\n\n    int log2_min_pu_size = s->sps->log2_min_pu_size;\n\n    int x_pu             = x >> log2_min_pu_size;\n\n    int y_pu             = y >> log2_min_pu_size;\n\n\n\n    if (x < 0 || x_pu >= s->sps->min_pu_width ||\n\n        y < 0 || y_pu >= s->sps->min_pu_height)\n\n        return 2;\n\n    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];\n\n}\n",
        "output": "0",
        "idx": 988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    /* Check the recursion limit */\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    /* Stop recursion: The inner Arrays are written */\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n\n    /* Recurse to the next dimension */\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}",
        "output": "1",
        "idx": 608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void StringBody::Dump(std::ostream& os, const std::string& prefix) const {\n  if (!data_.empty()) {\n    utility::DumpByLine(data_, os, prefix);\n  }\n}",
        "output": "0",
        "idx": 1810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)\n\n{\n\n    AVStream *st;\n\n    OutputStream *ost;\n\n    AVCodecContext *audio_enc;\n\n\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);\n\n    st  = ost->st;\n\n\n\n    audio_enc = st->codec;\n\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n    if (!ost->stream_copy) {\n\n        char *sample_fmt = NULL;\n\n\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n\n        if (sample_fmt &&\n\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n\n            exit_program(1);\n\n        }\n\n\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n    }\n\n\n\n    return ost;\n\n}\n",
        "output": "1",
        "idx": 105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void type_initialize_interface(TypeImpl *ti, const char *parent)\n\n{\n\n    InterfaceClass *new_iface;\n\n    TypeInfo info = { };\n\n    TypeImpl *iface_impl;\n\n\n\n    info.parent = parent;\n\n    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);\n\n    info.abstract = true;\n\n\n\n    iface_impl = type_register(&info);\n\n    type_initialize(iface_impl);\n\n    g_free((char *)info.name);\n\n\n\n    new_iface = (InterfaceClass *)iface_impl->class;\n\n    new_iface->concrete_class = ti->class;\n\n\n\n    ti->class->interfaces = g_slist_append(ti->class->interfaces,\n\n                                           iface_impl->class);\n\n}\n",
        "output": "1",
        "idx": 4733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ms_response_get_basename (MsResponse *response)\n{\n  return http_path_get_basename (response->path);\n}",
        "output": "0",
        "idx": 5032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)\n\n{\n\n    int current_offset = s->pixel_ptr - dst->data[0];\n\n    int motion_offset = current_offset + delta_y * dst->linesize[0]\n\n                       + delta_x * (1 + s->is_16bpp);\n\n    if (motion_offset < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset < 0 (%d)\\n\", motion_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (motion_offset > s->upper_motion_limit_offset) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset above limit (%d >= %d)\\n\",\n\n            motion_offset, s->upper_motion_limit_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (src->data[0] == NULL) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,\n\n                                            dst->linesize[0], 8);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 3755
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(\n    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {\n    invariant(*itr == this);\n\n    if (std::next(itr) == container->end()) {\n        return container->end();\n    }\n\n    // If we are not already handling an $unwind stage internally, we can combine with the following\n    // $unwind stage.\n    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());\n    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {\n        _unwind = std::move(nextUnwind);\n        container->erase(std::next(itr));\n        return itr;\n    }\n    return std::next(itr);\n}",
        "output": "0",
        "idx": 760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_response(ESPState *s)\n{\n    uint8_t buf[2];\n\n    trace_esp_write_response(s->status);\n\n    buf[0] = s->status;\n    buf[1] = 0;\n\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque, buf, 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        fifo8_reset(&s->fifo);\n        fifo8_push_all(&s->fifo, buf, 2);\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}",
        "output": "0",
        "idx": 616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */\n\n    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&\n\n        !kvm_irqchip_is_split()) {\n\n        error_setg(errp, \"Intel Interrupt Remapping cannot work with \"\n\n                         \"kernel-irqchip=on, please use 'split|off'.\");\n\n        return false;\n\n    }\n\n    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {\n\n        error_setg(errp, \"eim=on cannot be selected without intremap=on\");\n\n        return false;\n\n    }\n\n\n\n    if (s->intr_eim == ON_OFF_AUTO_AUTO) {\n\n        s->intr_eim = x86_iommu->intr_supported ?\n\n                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    return true;\n\n}\n",
        "output": "1",
        "idx": 5091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n\n{\n\n    int i;\n\n    int32_t *dst = (int32_t *) _dst;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n\n}\n",
        "output": "1",
        "idx": 25
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)\n{\n\tuint8_t labuf[LDNS_MAX_LABELLEN+1];\n\tuint8_t lablen;\n\tint i;\n\n\t/* preserve case of query, make hash label by label */\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\t/* follow pointer */\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlabuf[0] = lablen;\n\t\ti=0;\n\t\twhile(lablen--) {\n\t\t\tlabuf[++i] = (uint8_t)tolower((unsigned char)*dname);\n\t\t\tdname++;\n\t\t}\n\t\th = hashlittle(labuf, labuf[0] + 1, h);\n\t\tlablen = *dname++;\n\t}\n\n\treturn h;\n}",
        "output": "1",
        "idx": 1039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {\n  initialize();\n\n  MockResponseDecoder response_decoder;\n  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);\n\n  std::string output;\n  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));\n\n  TestRequestHeaderMapImpl headers{{\":method\", \"GET\"}, {\":path\", \"/\"}, {\":authority\", \"host\"}};\n  request_encoder.encodeHeaders(headers, true);\n  EXPECT_EQ(\"GET / HTTP/1.1\\r\\nhost: host\\r\\ncontent-length: 0\\r\\n\\r\\n\", output);\n}",
        "output": "0",
        "idx": 5641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_state_finalize (RsvgState * state)\n{\n    g_free (state->font_family);\n    g_free (state->lang);\n    rsvg_paint_server_unref (state->fill);\n    rsvg_paint_server_unref (state->stroke);\n\n    if (state->dash.n_dash != 0)\n        g_free (state->dash.dash);\n\n    if (state->styles) {\n        g_hash_table_unref (state->styles);\n        state->styles = NULL;\n    }\n}",
        "output": "1",
        "idx": 2026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}",
        "output": "1",
        "idx": 5924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n",
        "output": "0",
        "idx": 5028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n",
        "output": "1",
        "idx": 2266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_h264_flush_change(H264Context *h)\n\n{\n\n    int i, j;\n\n\n\n    h->next_outputed_poc = INT_MIN;\n\n    h->prev_interlaced_frame = 1;\n\n    idr(h);\n\n\n\n    h->poc.prev_frame_num = -1;\n\n    if (h->cur_pic_ptr) {\n\n        h->cur_pic_ptr->reference = 0;\n\n        for (j=i=0; h->delayed_pic[i]; i++)\n\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n\n                h->delayed_pic[j++] = h->delayed_pic[i];\n\n        h->delayed_pic[j] = NULL;\n\n    }\n\n    ff_h264_unref_picture(h, &h->last_pic_for_ec);\n\n\n\n    h->first_field = 0;\n\n    ff_h264_sei_uninit(&h->sei);\n\n    h->recovery_frame = -1;\n\n    h->frame_recovered = 0;\n\n    h->current_slice = 0;\n\n    h->mmco_reset = 1;\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        h->slice_ctx[i].list_count = 0;\n\n}\n",
        "output": "1",
        "idx": 1971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}",
        "output": "1",
        "idx": 93
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_op_movq_env_0(int d_offset)\n{\n    tcg_gen_movi_i64(cpu_tmp1_i64, 0);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);\n}",
        "output": "0",
        "idx": 606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n",
        "output": "1",
        "idx": 4609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stdmac_file(const SMacro *s, Token **params, int nparams)\n{\n    (void)s;\n    (void)params;\n    (void)nparams;\n\n    return make_tok_qstr(NULL, src_get_fname());\n}",
        "output": "0",
        "idx": 4
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)\n{\n    int y;\n    unsigned char P[2];\n    /* 4-color block encoding: each 4x4 block is a different color */\n    for (y = 0; y < 8; y++) {\n        if (!(y & 3)) {\n            P[0] = bytestream2_get_byte(&s->stream_ptr);\n            P[1] = bytestream2_get_byte(&s->stream_ptr);\n        memset(s->pixel_ptr,     P[0], 4);\n        memset(s->pixel_ptr + 4, P[1], 4);\n        s->pixel_ptr += s->stride;\n    /* report success */\n    return 0;",
        "output": "1",
        "idx": 4127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n",
        "output": "0",
        "idx": 349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "state_separate_contexts (position_set const *s)\n{\n  int separate_contexts = 0;\n  unsigned int j;\n\n  for (j = 0; j < s->nelem; ++j)\n    {\n      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))\n        separate_contexts |= CTX_NEWLINE;\n      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))\n        separate_contexts |= CTX_LETTER;\n    }\n\n  return separate_contexts;\n}",
        "output": "1",
        "idx": 5185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 4526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,\n                              size_t keylen, const unsigned char *iv,\n                              size_t ivlen, const OSSL_PARAM params[])\n{\n    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))\n        return 0;\n    return rc4_hmac_md5_set_ctx_params(ctx, params);\n}",
        "output": "0",
        "idx": 3324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_tref (void)\n{\n    RsvgNodeTref *text;\n    text = g_new (RsvgNodeTref, 1);\n    _rsvg_node_init (&text->super);\n    text->super.set_atts = _rsvg_node_tref_set_atts;\n    text->link = NULL;\n    return &text->super;\n}",
        "output": "1",
        "idx": 605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_fmtp(AVFormatContext *s,\n\n                      AVStream *stream, PayloadContext *data,\n\n                      const char *attr, const char *value)\n\n{\n\n    AVCodecParameters *par = stream->codecpar;\n\n    int res, i;\n\n\n\n    if (!strcmp(attr, \"config\")) {\n\n        res = parse_fmtp_config(par, value);\n\n\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (par->codec_id == AV_CODEC_ID_AAC) {\n\n        /* Looking for a known attribute */\n\n        for (i = 0; attr_names[i].str; ++i) {\n\n            if (!av_strcasecmp(attr, attr_names[i].str)) {\n\n                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {\n\n                    *(int *)((char *)data+\n\n                        attr_names[i].offset) = atoi(value);\n\n                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)\n\n                    *(char **)((char *)data+\n\n                        attr_names[i].offset) = av_strdup(value);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 4245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void curses_setup(void)\n\n{\n\n    int i, colour_default[8] = {\n\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n\n    };\n\n\n\n    /* input as raw as possible, let everything be interpreted\n\n     * by the guest system */\n\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n\n    start_color(); raw(); scrollok(stdscr, FALSE);\n\n\n\n    for (i = 0; i < 64; i ++)\n\n        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);\n\n}\n",
        "output": "1",
        "idx": 5253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)\n\n{\n\n    DynBuffer *d = s->opaque;\n\n    int size;\n\n    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};\n\n    int padding = 0;\n\n\n\n    if (!s) {\n\n        *pbuffer = NULL;\n\n        return 0;\n\n    }\n\n\n\n    /* don't attempt to pad fixed-size packet buffers */\n\n    if (!s->max_packet_size) {\n\n        avio_write(s, padbuf, sizeof(padbuf));\n\n        padding = FF_INPUT_BUFFER_PADDING_SIZE;\n\n    }\n\n\n\n    avio_flush(s);\n\n\n\n    *pbuffer = d->buffer;\n\n    size = d->size;\n\n    av_free(d);\n\n    av_free(s);\n\n    return size - padding;\n\n}\n",
        "output": "1",
        "idx": 3017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "toomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s header sections (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 4801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *SSL_get_cipher_list(const SSL *s, int n)\n{\n    SSL_CIPHER *c;\n    STACK_OF(SSL_CIPHER) *sk;\n\n    if (s == NULL)\n        return (NULL);\n    sk = SSL_get_ciphers(s);\n    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))\n        return (NULL);\n    c = sk_SSL_CIPHER_value(sk, n);\n    if (c == NULL)\n        return (NULL);\n    return (c->name);\n}",
        "output": "0",
        "idx": 4171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)\n{\n\treturn freerdp_channel_send(rdp, channelId, data, size);\n}",
        "output": "0",
        "idx": 5069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int RuleMatchCandidateTxArrayExpand(DetectEngineThreadCtx *det_ctx, const uint32_t needed)\n{\n    const uint32_t old_size = det_ctx->tx_candidates_size;\n    uint32_t new_size = needed;\n    void *ptmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));\n    if (ptmp == NULL) {\n        FatalError(SC_ERR_MEM_ALLOC, \"failed to expand to %\"PRIu64\" bytes\",\n                (uint64_t)(new_size * sizeof(RuleMatchCandidateTx)));\n        // TODO can this be handled more gracefully?\n    }\n    det_ctx->tx_candidates = ptmp;\n    det_ctx->tx_candidates_size = new_size;\n    SCLogDebug(\"array expanded from %u to %u elements (%\"PRIu64\" bytes -> %\"PRIu64\" bytes)\",\n            old_size, new_size, (uint64_t)(old_size * sizeof(RuleMatchCandidateTx)),\n            (uint64_t)(new_size * sizeof(RuleMatchCandidateTx))); (void)old_size;\n    return 1;\n}",
        "output": "0",
        "idx": 207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}",
        "output": "1",
        "idx": 487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n",
        "output": "1",
        "idx": 5998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n\n{\n\n    int ich, i;\n\n    int order        = s->mclms_order;\n\n    int num_channels = s->num_channels;\n\n\n\n    for (ich = 0; ich < num_channels; ich++) {\n\n        pred[ich] = 0;\n\n        if (!s->is_channel_coded[ich])\n\n            continue;\n\n        for (i = 0; i < order * num_channels; i++)\n\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n\n                         s->mclms_coeffs[i + order * num_channels * ich];\n\n        for (i = 0; i < ich; i++)\n\n            pred[ich] += s->channel_residues[i][icoef] *\n\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n\n        pred[ich] += 1 << s->mclms_scaling - 1;\n\n        pred[ich] >>= s->mclms_scaling;\n\n        s->channel_residues[ich][icoef] += pred[ich];\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void x86_cpu_enable_xsave_components(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n\n\n    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n        return;\n\n    }\n\n\n\n    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n        const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n        if (env->features[esa->feature] & esa->bits) {\n\n            env->xsave_components |= (1ULL << i);\n\n        }\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        KVMState *s = kvm_state;\n\n        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n        kvm_mask <<= 32;\n\n        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        env->xsave_components &= kvm_mask;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n",
        "output": "0",
        "idx": 439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {\n  ASSERT(!local_end_stream_);\n  local_end_stream_ = true;\n  if (pending_send_data_.length() > 0) {\n    // In this case we want trailers to come after we release all pending body data that is\n    // waiting on window updates. We need to save the trailers so that we can emit them later.\n    ASSERT(!pending_trailers_to_encode_);\n    pending_trailers_to_encode_ = cloneTrailers(trailers);\n  } else {\n    submitTrailers(trailers);\n    parent_.sendPendingFrames();\n  }\n}",
        "output": "1",
        "idx": 2445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n",
        "output": "1",
        "idx": 4492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    /* walk down the bs forest recursively */\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        bool perm;\n\n\n\n        /* try to recurse in this top level bs */\n\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n\n\n        /* candidate is the first non filter */\n\n        if (perm) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n",
        "output": "1",
        "idx": 6112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)\n{\n    int err;\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp, head_fid;\n\n    head_fid.next = s->fid_list;\n    for (fidp = s->fid_list; fidp; fidp = fidp->next) {\n        if (fidp->path.size != path->size) {\n            continue;\n        }\n        if (!memcmp(fidp->path.data, path->data, path->size)) {\n            /* Mark the fid non reclaimable. */\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n            /* reopen the file/dir if already closed */\n            err = v9fs_reopen_fid(pdu, fidp);\n            if (err < 0) {\n                return err;\n            }\n            /*\n             * Go back to head of fid list because\n             * the list could have got updated when\n             * switched to the worker thread\n             */\n            if (err == 0) {\n                fidp = &head_fid;\n            }\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 1543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,\n\n                                       const int16_t **lumSrc, int lumFilterSize,\n\n                                       const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                                       const int16_t **chrVSrc,\n\n                                       int chrFilterSize, const int16_t **alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    if (uDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n",
        "output": "1",
        "idx": 2558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void v9fs_link(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t dfid, oldfid;\n\n    V9fsFidState *dfidp, *oldfidp;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    int err = 0;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n\n\n    dfidp = get_fid(pdu, dfid);\n\n    if (dfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    oldfidp = get_fid(pdu, oldfid);\n\n    if (oldfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, dfidp);\n\nout_nofid:\n\n    v9fs_string_free(&name);\n\n    complete_pdu(s, pdu, err);\n\n}\n",
        "output": "0",
        "idx": 1825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}",
        "output": "1",
        "idx": 1458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static apr_status_t session_identity_encode(request_rec * r, session_rec * z)\n{\n\n    char *buffer = NULL;\n    int length = 0;\n    if (z->expiry) {\n        char *expiry = apr_psprintf(z->pool, \"%\" APR_INT64_T_FMT, z->expiry);\n        apr_table_setn(z->entries, SESSION_EXPIRY, expiry);\n    }\n    apr_table_do(identity_count, &length, z->entries, NULL);\n    buffer = apr_pcalloc(r->pool, length + 1);\n    apr_table_do(identity_concat, buffer, z->entries, NULL);\n    z->encoded = buffer;\n    return OK;\n\n}",
        "output": "1",
        "idx": 902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void network_init_gcrypt (void) /* {{{ */\n{\n  /* http://lists.gnupg.org/pipermail/gcrypt-devel/2003-August/000458.html\n   * Because you can't know in a library whether another library has\n   * already initialized the library */\n  if (gcry_control (GCRYCTL_ANY_INITIALIZATION_P))\n    return;\n\n /* http://www.gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html\n  * To ensure thread-safety, it's important to set GCRYCTL_SET_THREAD_CBS\n  * *before* initalizing Libgcrypt with gcry_check_version(), which itself must\n  * be called before any other gcry_* function. GCRYCTL_ANY_INITIALIZATION_P\n  * above doesn't count, as it doesn't implicitly initalize Libgcrypt.\n  *\n  * tl;dr: keep all these gry_* statements in this exact order please. */\n# if GCRYPT_VERSION_NUMBER < 0x010600\n  gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\n# endif\n  gcry_check_version (NULL);\n  gcry_control (GCRYCTL_INIT_SECMEM, 32768);\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED);\n} /* }}} void network_init_gcrypt */",
        "output": "1",
        "idx": 1440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size,\n\t\t\t      int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\treturn unix_dgram_recvmsg(iocb, sock, msg, size, flags);\n}",
        "output": "0",
        "idx": 4906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n",
        "output": "0",
        "idx": 6263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wait);\n\tspin_lock(&inode_hash_lock);\n}",
        "output": "0",
        "idx": 561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_malloc0(sizeof(QEMUBH));\n\n    bh->ctx = ctx;\n\n    bh->cb = cb;\n\n    bh->opaque = opaque;\n\n    qemu_mutex_lock(&ctx->bh_lock);\n\n    bh->next = ctx->first_bh;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_mutex_unlock(&ctx->bh_lock);\n\n    return bh;\n\n}\n",
        "output": "0",
        "idx": 4580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int qsv_decode_close(AVCodecContext *avctx)\n{\n    QSVOtherContext *s = avctx->priv_data;\n    ff_qsv_decode_close(&s->qsv);\n    qsv_clear_buffers(s);\n    av_fifo_free(s->packet_fifo);\n    return 0;\n}",
        "output": "1",
        "idx": 3574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hclge_pfc_setup_hw(struct hclge_dev *hdev)\n{\n\tu8 enable_bitmap = 0;\n\n\tif (hdev->tm_info.fc_mode == HCLGE_FC_PFC)\n\t\tenable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |\n\t\t\t\tHCLGE_RX_MAC_PAUSE_EN_MSK;\n\n\treturn hclge_pfc_pause_en_cfg(hdev, enable_bitmap,\n\t\t\t\t      hdev->tm_info.pfc_en);\n}",
        "output": "0",
        "idx": 82
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}",
        "output": "1",
        "idx": 1158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n",
        "output": "1",
        "idx": 4393
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vhost_user_start(VhostUserState *s)\n\n{\n\n    VhostNetOptions options;\n\n\n\n    if (vhost_user_running(s)) {\n\n        return 0;\n\n    }\n\n\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    options.net_backend = &s->nc;\n\n    options.opaque = s->chr;\n\n\n\n    s->vhost_net = vhost_net_init(&options);\n\n\n\n    return vhost_user_running(s) ? 0 : -1;\n\n}\n",
        "output": "0",
        "idx": 76
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int open_user_journal_directory(Server *s, DIR **ret_dir, char **ret_path) {\n        _cleanup_closedir_ DIR *dir = NULL;\n        _cleanup_free_ char *path = NULL;\n        sd_id128_t machine;\n        int r;\n\n        assert(s);\n\n        r = sd_id128_get_machine(&machine);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine machine ID, ignoring: %m\");\n\n        if (asprintf(&path, \"/var/log/journal/\" SD_ID128_FORMAT_STR \"/\", SD_ID128_FORMAT_VAL(machine)) < 0)\n                return log_oom();\n\n        dir = opendir(path);\n        if (!dir)\n                return log_error_errno(errno, \"Failed to open user journal directory '%s': %m\", path);\n\n        if (ret_dir)\n                *ret_dir = TAKE_PTR(dir);\n        if (ret_path)\n                *ret_path = TAKE_PTR(path);\n\n        return 0;\n}",
        "output": "0",
        "idx": 3362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 5684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int srt_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    AVSubtitle *sub = data;\n\n    AVBPrint buffer;\n\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\n    int size, ret;\n\n    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);\n\n    FFASSDecoderContext *s = avctx->priv_data;\n\n\n\n    if (p && size == 16) {\n\n        x1 = AV_RL32(p     );\n\n        y1 = AV_RL32(p +  4);\n\n        x2 = AV_RL32(p +  8);\n\n        y2 = AV_RL32(p + 12);\n\n    }\n\n\n\n    if (avpkt->size <= 0)\n\n        return avpkt->size;\n\n\n\n    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);\n\n    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);\n\n    av_bprint_finalize(&buffer, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    return avpkt->size;\n\n}\n",
        "output": "0",
        "idx": 3646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {\n        double *ptrd = &_mp_arg(1) + 1;\n        const double *ptr1 = &_mp_arg(2) + 1;\n        const unsigned int\n          k = (unsigned int)mp.opcode[3],\n          l = (unsigned int)mp.opcode[4];\n        const bool use_LU = (bool)_mp_arg(5);\n        CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);\n        return cimg::type<double>::nan();\n      }",
        "output": "0",
        "idx": 6046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)\n{\n  int ret = 0;\n  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);\n  return ret;\n}",
        "output": "0",
        "idx": 2159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
        "output": "1",
        "idx": 3737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proc_file_lseek(struct file *file, loff_t offset, int orig)\n{\n    lock_kernel();\n\n    switch (orig) {\n    case 0:\n\tif (offset < 0)\n\t    goto out;\n\tfile->f_pos = offset;\n\tunlock_kernel();\n\treturn(file->f_pos);\n    case 1:\n\tif (offset + file->f_pos < 0)\n\t    goto out;\n\tfile->f_pos += offset;\n\tunlock_kernel();\n\treturn(file->f_pos);\n    case 2:\n\tgoto out;\n    default:\n\tgoto out;\n    }\n\nout:\n    unlock_kernel();\n    return -EINVAL;\n}",
        "output": "1",
        "idx": 3733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\n\tif (slack_runtime <= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\n\t\t/* we are under rq->lock, defer unthrottling using a timer */\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\t/* even if it's not valid for return we don't want to try again */\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}",
        "output": "1",
        "idx": 272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)\n{\n    EC_GROUP *ret;\n\n    if (meth == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);\n        return NULL;\n    }\n    if (meth->group_init == 0) {\n        ECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return NULL;\n    }\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->meth = meth;\n    if ((ret->meth->flags & EC_FLAGS_CUSTOM_CURVE) == 0) {\n        ret->order = BN_new();\n        if (ret->order == NULL)\n            goto err;\n        ret->cofactor = BN_new();\n        if (ret->cofactor == NULL)\n            goto err;\n    }\n    ret->asn1_flag = OPENSSL_EC_NAMED_CURVE;\n    ret->asn1_form = POINT_CONVERSION_UNCOMPRESSED;\n    if (!meth->group_init(ret))\n        goto err;\n    return ret;\n\n err:\n    BN_free(ret->order);\n    BN_free(ret->cofactor);\n    OPENSSL_free(ret);\n    return NULL;\n}",
        "output": "0",
        "idx": 1012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "to_hash(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_HASH, \"Hash\", \"to_hash\");\n}",
        "output": "0",
        "idx": 479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);\n\n    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),\n\n                                  \"/e500-ccsr\"));\n\n\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);\n\n    d->config[PCI_HEADER_TYPE] =\n\n        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n\n\n    memory_region_init_alias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsr_space,\n\n                             0, int128_get64(ccsr->ccsr_space.size));\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);\n\n}\n",
        "output": "0",
        "idx": 6053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    int i, j;\n\n\n\n    if (!mov->fragment_index_complete)\n\n        return 0;\n\n\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n\n        if (mov->fragment_index_data[i]->track_id == st->id) {\n\n            MOVFragmentIndex *index = index = mov->fragment_index_data[i];\n\n            for (j = index->item_count - 1; j >= 0; j--) {\n\n                if (index->items[j].time <= timestamp) {\n\n                    if (index->items[j].headers_read)\n\n                        return 0;\n\n\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t tpm_read(struct file *file, char __user *buf,\n\t\t size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tssize_t ret_size;\n\tint rc;\n\n\tdel_singleshot_timer_sync(&chip->user_read_timer);\n\tflush_work_sync(&chip->work);\n\tret_size = atomic_read(&chip->data_pending);\n\tatomic_set(&chip->data_pending, 0);\n\tif (ret_size > 0) {\t/* relay data */\n\t\tif (size < ret_size)\n\t\t\tret_size = size;\n\n\t\tmutex_lock(&chip->buffer_mutex);\n\t\trc = copy_to_user(buf, chip->data_buffer, ret_size);\n\t\tmemset(chip->data_buffer, 0, ret_size);\n\t\tif (rc)\n\t\t\tret_size = -EFAULT;\n\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t}\n\n\treturn ret_size;\n}",
        "output": "0",
        "idx": 72
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Filter::onDownstreamEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose ||\n      event == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n  }\n\n  ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\n                 static_cast<int>(event), upstream_ == nullptr);\n\n  if (upstream_) {\n    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));\n    if (conn_data != nullptr &&\n        conn_data->connection().state() != Network::Connection::State::Closed) {\n      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),\n                                  std::move(upstream_callbacks_), std::move(idle_timer_),\n                                  read_callbacks_->upstreamHost());\n    }\n    if (event != Network::ConnectionEvent::Connected) {\n      upstream_.reset();\n      disableIdleTimer();\n    }\n  }\n  if (generic_conn_pool_) {\n    if (event == Network::ConnectionEvent::LocalClose ||\n        event == Network::ConnectionEvent::RemoteClose) {\n      // Cancel the conn pool request and close any excess pending requests.\n      generic_conn_pool_.reset();\n    }\n  }\n}",
        "output": "0",
        "idx": 3629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_index_entry(AVStream *st,\n\n                            int64_t pos, int64_t timestamp, int flags)\n\n{\n\n    AVIndexEntry *entries, *ie;\n\n    \n\n    entries = av_fast_realloc(st->index_entries,\n\n                              &st->index_entries_allocated_size,\n\n                              (st->nb_index_entries + 1) * \n\n                              sizeof(AVIndexEntry));\n\n    if (entries) {\n\n        st->index_entries = entries;\n\n        ie = &entries[st->nb_index_entries++];\n\n        ie->pos = pos;\n\n        ie->timestamp = timestamp;\n\n        ie->flags = flags;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void checkpoint_signal(int signo)\n{\n\tcheckpoint_requested = 1;\n}",
        "output": "0",
        "idx": 5134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr,\n\n                               int queues)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n    int i;\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n\n                 i, chr->label);\n\n\n\n        nc->queue_index = i;\n\n\n\n        s = DO_UPCAST(VhostUserState, nc, nc);\n\n        s->chr = chr;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,\n\n                                         uint32_t val)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    UNIN_DPRINTF(\"config_writel addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    s->config_reg = val;\n\n}\n",
        "output": "1",
        "idx": 3427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\t\tunsigned long start, unsigned long end, int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_REMOVE:\n\t\treturn madvise_remove(vma, prev, start, end);\n\tcase MADV_WILLNEED:\n\t\treturn madvise_willneed(vma, prev, start, end);\n\tcase MADV_COLD:\n\t\treturn madvise_cold(vma, prev, start, end);\n\tcase MADV_PAGEOUT:\n\t\treturn madvise_pageout(vma, prev, start, end);\n\tcase MADV_FREE:\n\tcase MADV_DONTNEED:\n\t\treturn madvise_dontneed_free(vma, prev, start, end, behavior);\n\tdefault:\n\t\treturn madvise_behavior(vma, prev, start, end, behavior);\n\t}\n}",
        "output": "0",
        "idx": 769
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool val_native(THD *thd, Native *to)\n  {\n    return m_value.to_native(to, decimals);\n  }",
        "output": "0",
        "idx": 3607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n",
        "output": "1",
        "idx": 5096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 2251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vmdk_parent_open(BlockDriverState *bs)\n\n{\n\n    char *p_name;\n\n    char desc[DESC_SIZE + 1];\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    desc[DESC_SIZE] = '\\0';\n\n    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != NULL) {\n\n        char *end_name;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == NULL)\n\n            return -1;\n\n        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n\n            return -1;\n\n\n\n        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}",
        "output": "1",
        "idx": 5916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n\n                                   size_t datalen)\n\n{\n\n    ssize_t ret = gnutls_read(*session, data, datalen);\n\n    if (ret < 0) {\n\n        if (ret == GNUTLS_E_AGAIN) {\n\n            errno = EAGAIN;\n\n        } else {\n\n            errno = EIO;\n\n        }\n\n        ret = -1;\n\n    }\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 2435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}",
        "output": "1",
        "idx": 1500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n",
        "output": "1",
        "idx": 4307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n",
        "output": "1",
        "idx": 2629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UsbHubCtrlGetSuperSpeedHubDesc (\r\n  IN  USB_DEVICE          *HubDev,\r\n  OUT VOID                *Buf\r\n  )\r\n{\r\n  EFI_STATUS              Status;\r\n  \r\n  Status = EFI_INVALID_PARAMETER;\r\n  \r\n  Status = UsbCtrlRequest (\r\n             HubDev,\r\n             EfiUsbDataIn,\r\n             USB_REQ_TYPE_CLASS,\r\n             USB_HUB_TARGET_HUB,\r\n             USB_HUB_REQ_GET_DESC,\r\n             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),\r\n             0,\r\n             Buf,\r\n             32\r\n             );\r\n\r\n  return Status;\r\n}\r",
        "output": "1",
        "idx": 1155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {\n    long pid;\n    NTSTATUS status;\n    HANDLE hProcess;\n    PyObject* suspend;\n\n    if (! PyArg_ParseTuple(args, \"lO\", &pid, &suspend))\n        return NULL;\n\n    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);\n    if (hProcess == NULL)\n        return NULL;\n\n    if (PyObject_IsTrue(suspend))\n        status = psutil_NtSuspendProcess(hProcess);\n    else\n        status = psutil_NtResumeProcess(hProcess);\n\n    if (! NT_SUCCESS(status)) {\n        CloseHandle(hProcess);\n        return psutil_SetFromNTStatusErr(status, \"NtSuspend|ResumeProcess\");\n    }\n\n    CloseHandle(hProcess);\n    Py_RETURN_NONE;\n}",
        "output": "0",
        "idx": 4406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}",
        "output": "1",
        "idx": 2961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n\n{\n\n    ssize_t ret;\n\n    guint watch;\n\n\n\n    assert(qemu_in_coroutine());\n\n    /* Negotiation are always in main loop. */\n\n    watch = qio_channel_add_watch(ioc,\n\n                                  G_IO_OUT,\n\n                                  nbd_negotiate_continue,\n\n                                  qemu_coroutine_self(),\n\n                                  NULL);\n\n    ret = write_sync(ioc, buffer, size, NULL);\n\n    g_source_remove(watch);\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 1620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fork_start(void)\n\n{\n\n    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n    pthread_mutex_lock(&exclusive_lock);\n\n    mmap_fork_start();\n\n}\n",
        "output": "0",
        "idx": 2503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n",
        "output": "0",
        "idx": 639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_net_stop_one(struct vhost_net *net,\n\n                               VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { .fd = -1 };\n\n\n\n    if (!net->dev.started) {\n\n        return;\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\n}\n",
        "output": "0",
        "idx": 2958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);\n\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(&p->data, vcpu->mmio_data, 8);\n\tp->state = STATE_IORESP_READY;\n}",
        "output": "1",
        "idx": 633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 3580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4);\n\t*p = cpu_to_be32(OP_READLINK);\n\thdr->nops++;\n\thdr->replen += decode_readlink_maxsz;\n}",
        "output": "0",
        "idx": 120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  QUInt16() {}",
        "output": "1",
        "idx": 4564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)\n{\n  assert(status != NULL);\n  *status = parser->m_parsingStatus;\n}",
        "output": "0",
        "idx": 2936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long SSL_SESSION_hash(const SSL_SESSION *a)\n\t{\n\tunsigned long l;\n\n\tl=(unsigned long)\n\t\t((unsigned int) a->session_id[0]     )|\n\t\t((unsigned int) a->session_id[1]<< 8L)|\n\t\t((unsigned long)a->session_id[2]<<16L)|\n\t\t((unsigned long)a->session_id[3]<<24L);\n\treturn(l);\n\t}",
        "output": "0",
        "idx": 632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)\n{\n  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);\n}",
        "output": "1",
        "idx": 4710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n",
        "output": "1",
        "idx": 3398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n",
        "output": "1",
        "idx": 689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )\r\n{\r\n    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n    {\r\n        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0xFF;\r\n}\r",
        "output": "0",
        "idx": 364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n\n    /* We memory copy to the pixel map so the endianness is preserved */\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}",
        "output": "1",
        "idx": 5410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n    *session_data_size = psession.size;\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n \n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}",
        "output": "1",
        "idx": 3666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool dwgReader21::parseSysPage(duint64 sizeCompressed, duint64 sizeUncompressed, duint64 correctionFactor, duint64 offset, duint8 *decompData){\n    //round to 8\n    duint64 alsize = (sizeCompressed + 7) &(-8);\n    //minimum RS chunk:\n    duint32 chunks = (((alsize * correctionFactor)+238)/239);\n    duint64 fpsize = chunks * 255;\n\n    if (! fileBuf->setPosition(offset))\n        return false;\n    std::vector<duint8> tmpDataRaw(fpsize);\n    fileBuf->getBytes(&tmpDataRaw.front(), fpsize);\n    std::vector<duint8> tmpDataRS(fpsize);\n    dwgRSCodec::decode239I(&tmpDataRaw.front(), &tmpDataRS.front(), fpsize/255);\n    dwgCompressor::decompress21(&tmpDataRS.front(), decompData, sizeCompressed, sizeUncompressed);\n    return true;\n}",
        "output": "1",
        "idx": 6127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xen_be_send_notify(struct XenDevice *xendev)\n\n{\n\n    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);\n\n}\n",
        "output": "0",
        "idx": 1588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_push_glob(VALUE str, int flags) /* '\\0' is delimiter */\n{\n    long offset = 0;\n    VALUE ary;\n\n    GlobPathValue(str, TRUE);\n    ary = rb_ary_new();\n\n    while (offset < RSTRING_LEN(str)) {\n\tchar *p, *pend;\n\tint status;\n\tp = RSTRING_PTR(str) + offset;\n\tstatus = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),\n\t\t\t   flags);\n\tif (status) GLOB_JUMP_TAG(status);\n\tif (offset >= RSTRING_LEN(str)) break;\n\tp += strlen(p) + 1;\n\tpend = RSTRING_PTR(str) + RSTRING_LEN(str);\n\twhile (p < pend && !*p)\n\t    p++;\n\toffset = p - RSTRING_PTR(str);\n    }\n\n    return ary;\n}",
        "output": "1",
        "idx": 4653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_msg_msg_alloc_security(struct msg_msg *msg)\n{\n\tstruct msg_security_struct *msec;\n\n\tmsec = selinux_msg_msg(msg);\n\tmsec->sid = SECINITSID_UNLABELED;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ews_backend_constructed (GObject *object)\n{\n\tEBackend *backend;\n\tESource *source;\n\tESourceAuthentication *auth_extension;\n\tconst gchar *extension_name;\n\tgchar *host = NULL;\n\tguint16 port = 0;\n\n\t/* Chain up to parent's constructed() method. */\n\tG_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);\n\n\tbackend = E_BACKEND (object);\n\tsource = e_backend_get_source (backend);\n\n\t/* XXX Wondering if we ought to delay this until after folders\n\t *     are initially populated, just to remove the possibility\n\t *     of weird races with clients trying to create folders. */\n\te_server_side_source_set_remote_creatable (\n\t\tE_SERVER_SIDE_SOURCE (source), TRUE);\n\n\t/* Setup the Authentication extension so\n\t * Camel can determine host reachability. */\n\textension_name = E_SOURCE_EXTENSION_AUTHENTICATION;\n\tauth_extension = e_source_get_extension (source, extension_name);\n\n\tif (e_backend_get_destination_address (backend, &host, &port)) {\n\t\te_source_authentication_set_host (auth_extension, host);\n\t\te_source_authentication_set_port (auth_extension, port);\n\t}\n\n\tg_free (host);\n\n\t/* Reset the connectable, it steals data from Authentication extension,\n\t   where is written incorrect address */\n\te_backend_set_connectable (backend, NULL);\n}",
        "output": "1",
        "idx": 6227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __idr_remove_all(struct idr *idp)\n{\n\tint n, id, max;\n\tint bt_mask;\n\tstruct idr_layer *p;\n\tstruct idr_layer *pa[MAX_IDR_LEVEL];\n\tstruct idr_layer **paa = &pa[0];\n\n\tn = idp->layers * IDR_BITS;\n\tp = idp->top;\n\trcu_assign_pointer(idp->top, NULL);\n\tmax = 1 << n;\n\n\tid = 0;\n\twhile (id < max) {\n\t\twhile (n > IDR_BITS && p) {\n\t\t\tn -= IDR_BITS;\n\t\t\t*paa++ = p;\n\t\t\tp = p->ary[(id >> n) & IDR_MASK];\n\t\t}\n\n\t\tbt_mask = id;\n\t\tid += 1 << n;\n\t\t/* Get the highest bit that the above add changed from 0->1. */\n\t\twhile (n < fls(id ^ bt_mask)) {\n\t\t\tif (p)\n\t\t\t\tfree_layer(p);\n\t\t\tn += IDR_BITS;\n\t\t\tp = *--paa;\n\t\t}\n\t}\n\tidp->layers = 0;\n}",
        "output": "1",
        "idx": 1685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtp_packetize_ac3( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 14 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0, in->i_pts );\n        /* unit count */\n        out->p_buffer[12] = 1;\n        /* unit header */\n        out->p_buffer[13] = 0x00;\n        /* data */\n        memcpy( &out->p_buffer[14], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}",
        "output": "0",
        "idx": 5152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int zpff_init(struct hid_device *hid)\n{\n\treturn 0;\n}",
        "output": "1",
        "idx": 3550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int rv40_decode_init(AVCodecContext *avctx)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n\n\n    r->rv30 = 0;\n\n    ff_rv34_decode_init(avctx);\n\n    if(!aic_top_vlc.bits)\n\n        rv40_init_tables();\n\n    r->parse_slice_header = rv40_parse_slice_header;\n\n    r->decode_intra_types = rv40_decode_intra_types;\n\n    r->decode_mb_info     = rv40_decode_mb_info;\n\n    r->loop_filter        = rv40_loop_filter;\n\n    r->luma_dc_quant_i = rv40_luma_dc_quant[0];\n\n    r->luma_dc_quant_p = rv40_luma_dc_quant[1];\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void uuid_unparse(const uuid_t uu, char *out)\n\n{\n\n    snprintf(out, 37, UUID_FMT,\n\n            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],\n\n            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);\n\n}\n",
        "output": "0",
        "idx": 358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int compare_codec_desc(const void *a, const void *b)\n\n{\n\n    const AVCodecDescriptor * const *da = a;\n\n    const AVCodecDescriptor * const *db = b;\n\n\n\n    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n\n           strcmp((*da)->name, (*db)->name);\n\n}\n",
        "output": "1",
        "idx": 1021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus PrepareMeanOrSum(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_OK(context, PrepareSimple(context, node));\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  // reduce_mean requires a buffer to store intermediate sum result.\n  OpContext op_context(context, node);\n  if (op_context.input->type == kTfLiteInt8 ||\n      op_context.input->type == kTfLiteUInt8 ||\n      op_context.input->type == kTfLiteInt16) {\n    const double real_multiplier =\n        static_cast<double>(op_context.input->params.scale) /\n        static_cast<double>(op_context.output->params.scale);\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &exponent);\n    data->shift = exponent;\n  }\n  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);\n  if (!IsConstantTensor(op_context.axis)) {\n    SetTensorToDynamic(temp_sum);\n    return kTfLiteOk;\n  }\n  temp_sum->allocation_type = kTfLiteArenaRw;\n  return ResizeTempSum(context, &op_context, temp_sum);\n}",
        "output": "1",
        "idx": 5786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ZipTest::testDecompress()\n{\n\tstd::string testFile = getTestFile(\"data\", \"test.zip\");\n\tstd::ifstream inp(testFile.c_str(), std::ios::binary);\n\tassert (inp.good());\n\tDecompress dec(inp, Poco::Path());\n\tdec.EError += Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);\n\tdec.decompressAllFiles();\n\tdec.EError -= Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);\n\tassert (_errCnt == 0);\n\tassert (!dec.mapping().empty());\n}",
        "output": "1",
        "idx": 5067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                                  QEMUIOVector *qiov, int nb_sectors,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    if (bs->dirty_tracking) {\n\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,\n\n                               cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 5235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)\n\t{\n\treturn PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());\n\t}",
        "output": "0",
        "idx": 3827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CL_SetModel_f( void ) {\n\tchar\t*arg;\n\tchar\tname[256];\n\n\targ = Cmd_Argv( 1 );\n\tif (arg[0]) {\n\t\tCvar_Set( \"model\", arg );\n\t\tCvar_Set( \"headmodel\", arg );\n\t} else {\n\t\tCvar_VariableStringBuffer( \"model\", name, sizeof(name) );\n\t\tCom_Printf(\"model is set to %s\\n\", name);\n\t}\n}",
        "output": "0",
        "idx": 3248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cap_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t const void *value, size_t size, int flags)\n{\n\treturn -EOPNOTSUPP;\n}",
        "output": "0",
        "idx": 3391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}",
        "output": "1",
        "idx": 1774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n",
        "output": "1",
        "idx": 281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,\n\t\t\t\t     struct ext4_system_blocks *system_blks,\n\t\t\t\t     ext4_fsblk_t start_blk,\n\t\t\t\t     unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es)))\n\t\treturn 0;\n\n\tif (system_blks == NULL)\n\t\treturn 1;\n\n\tn = system_blks->root.rb_node;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "output": "1",
        "idx": 725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_chr_telnet_init(QIOChannel *ioc)\n\n{\n\n    char buf[3];\n\n    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */\n\n    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n}\n",
        "output": "0",
        "idx": 4458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],\n\n            const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n            const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n            int yalpha, int uvalpha, int y)\n\n{\n\n    int hasAlpha = abuf[0] && abuf[1];\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;\n\n        int A;\n\n\n\n        Y = av_clip_uint8(Y);\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;\n\n            A = av_clip_uint8(A);\n\n        }\n\n\n\n        dest[i * 2    ] = Y;\n\n        dest[i * 2 + 1] = hasAlpha ? A : 255;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                              int nb_sectors, int *pnum)\n\n{\n\n    uint64_t cluster_offset;\n\n    int ret;\n\n\n\n    *pnum = nb_sectors;\n\n    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't\n\n     * pass them on today */\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n    }\n\n\n\n    return (cluster_offset != 0);\n\n}\n",
        "output": "0",
        "idx": 391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n",
        "output": "1",
        "idx": 2017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)\n{\n    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);\n}",
        "output": "0",
        "idx": 3492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n",
        "output": "1",
        "idx": 1414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mqueue_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tdir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);\n\tdir->i_size -= DIRENT_SIZE;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_png_palette(int idx, uint32_t pix, void *opaque)\n{\n    struct palette_cb_priv *priv = opaque;\n    VncState *vs = priv->vs;\n    png_colorp color = &priv->png_palette[idx];\n\n    if (vs->tight.pixel24)\n    {\n        color->red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;\n        color->green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;\n        color->blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;\n    }\n    else\n    {\n        int red, green, blue;\n\n        red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;\n        green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;\n        blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;\n        color->red = ((red * 255 + vs->client_pf.rmax / 2) /\n                      vs->client_pf.rmax);\n        color->green = ((green * 255 + vs->client_pf.gmax / 2) /\n                        vs->client_pf.gmax);\n        color->blue = ((blue * 255 + vs->client_pf.bmax / 2) /\n                       vs->client_pf.bmax);\n    }\n}",
        "output": "1",
        "idx": 502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ceph_bookkeeper_finalize(void)\n{\n\tstruct list_head *p;\n\tstruct alloc_data *entry;\n\n\tp=kmalloc(100, GFP_KERNEL);\n\n\tprintk(\"bookkeeper: total bytes alloc: %zu\\n\", _total_alloc);\n\tprintk(\"bookkeeper: total bytes free: %zu\\n\", _total_free);\n\n\tif (_total_alloc != _total_free) {\n\n\t\tlist_for_each(p, &_bk_allocs) {\n\t\t\tentry = list_entry(p, struct alloc_data, node);\n\t\t\tprintk(\"%s(%d): p=%p (%zu bytes)\\n\", entry->fname, entry->line, \n\t\t\t\t((void *)entry)+sizeof(struct alloc_data), \n\t\t\t\tentry->size);\n\t\t}\n\t} else {\n\t\tprintk(\"No leaks found! Yay!\\n\");\n\t}\n}",
        "output": "0",
        "idx": 497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(void)\n\n{\n\n    int nf;\n\n    Suite *s;\n\n    SRunner *sr;\n\n\n\n    s = qfloat_suite();\n\n    sr = srunner_create(s);\n\n\n\n    srunner_run_all(sr, CK_NORMAL);\n\n    nf = srunner_ntests_failed(sr);\n\n    srunner_free(sr);\n\n\n\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n\n}\n",
        "output": "0",
        "idx": 2488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 2282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\t}\n\t\n\treturn ret;\n}",
        "output": "1",
        "idx": 2220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++)\n\n        if (simple_limit(dst+i*stride, 1, flim))\n\n            filter_common(dst+i*stride, 1, 1);\n\n}\n",
        "output": "0",
        "idx": 4464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)\n{\n\tu32 ID;\n\tNodeIDedItem *reg_node;\n\tif (!sg->id_node) return 1;\n\treg_node = sg->id_node;\n\tID = reg_node->NodeID;\n\t/*nodes are sorted*/\n\twhile (reg_node->next) {\n\t\tif (ID+1<reg_node->next->NodeID) return ID+1;\n\t\tID = reg_node->next->NodeID;\n\t\treg_node = reg_node->next;\n\t}\n\treturn ID+1;\n}",
        "output": "0",
        "idx": 2310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(\n    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {\n  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();\n  Event::Dispatcher& thread_local_dispatcher =\n      parent_.connection_manager_.read_callbacks_->connection().dispatcher();\n  if (route_config.has_value() && route_config.value()->usesVhds()) {\n    ASSERT(!parent_.request_headers_->Host()->value().empty());\n    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());\n    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));\n    return;\n  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {\n    Router::ScopeKeyPtr scope_key =\n        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);\n    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.\n    if (scope_key != nullptr) {\n      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,\n                        std::move(route_config_updated_cb));\n      return;\n    }\n  }\n  // Continue the filter chain if no on demand update is requested.\n  (*route_config_updated_cb)(false);\n}",
        "output": "0",
        "idx": 2414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_del (hb_set_t       *set,\n\t    hb_codepoint_t  codepoint)\n{\n  /* Immutible-safe. */\n  set->del (codepoint);\n}",
        "output": "0",
        "idx": 6058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}",
        "output": "1",
        "idx": 3466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void indent_down() { generator_->indent_down(); }",
        "output": "0",
        "idx": 2305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bson_check_string( bson *b, const char *string,\n                       const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}",
        "output": "1",
        "idx": 2153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = &first_oformat;\n\n\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n\n\n    *p = format;\n\n    format->next = NULL;\n\n}\n",
        "output": "0",
        "idx": 1841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}",
        "output": "0",
        "idx": 1088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 3295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool tight_can_send_png_rect(VncState *vs, int w, int h)\n{\n    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {\n        return false;\n    }\n\n    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n        vs->client_pf.bytes_per_pixel == 1) {\n        return false;\n    }\n\n    return true;\n}",
        "output": "0",
        "idx": 4664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\n\tavailable = ures_openAvailableLocales(NULL, &status);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n\t\t\t\t\t\t&outResult, http_accept, available, &status);\n\tuenum_close(available);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}",
        "output": "1",
        "idx": 1355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "use_socks (struct sockaddr_storage *addr)\n{\n  int mode;\n\n  if (assuan_sock_get_flag (ASSUAN_INVALID_FD, \"tor-mode\", &mode) || !mode)\n    return 0;  /* Not in Tor mode.  */\n  else if (addr->ss_family == AF_INET6)\n    {\n      struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;\n      const unsigned char *s;\n      int i;\n\n      s = (unsigned char *)&addr_in6->sin6_addr.s6_addr;\n      if (s[15] != 1)\n        return 1;   /* Last octet is not 1 - not the loopback address.  */\n      for (i=0; i < 15; i++, s++)\n        if (*s)\n          return 1; /* Non-zero octet found - not the loopback address.  */\n\n      return 0; /* This is the loopback address.  */\n    }\n  else if (addr->ss_family == AF_INET)\n    {\n      struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;\n\n      if (*(unsigned char*)&addr_in->sin_addr.s_addr == 127)\n        return 0; /* Loopback (127.0.0.0/8) */\n\n      return 1;\n    }\n  else\n    return 0;\n}",
        "output": "0",
        "idx": 4288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n",
        "output": "1",
        "idx": 3433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
        "output": "1",
        "idx": 2354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}",
        "output": "1",
        "idx": 2186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ElectronBrowserHandlerImpl::Create(\n    content::RenderFrameHost* frame_host,\n    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {\n  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));\n}",
        "output": "1",
        "idx": 726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }",
        "output": "1",
        "idx": 504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\tint\tpkt_len;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t/* Parse the header */\n\tpkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\n\t/* Convert the ASCII hex dump to binary data */\n\treturn parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,\n\t    wth->frame_buffer, err, err_info);\n}",
        "output": "1",
        "idx": 4634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 74
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct file *__fget_files(struct files_struct *files, unsigned int fd,\n\t\t\t\t fmode_t mask, unsigned int refs)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\nloop:\n\tfile = files_lookup_fd_rcu(files, fd);\n\tif (file) {\n\t\t/* File object ref couldn't be taken.\n\t\t * dup2() atomicity guarantee is the reason\n\t\t * we loop to catch the new file (or NULL pointer)\n\t\t */\n\t\tif (file->f_mode & mask)\n\t\t\tfile = NULL;\n\t\telse if (!get_file_rcu_many(file, refs))\n\t\t\tgoto loop;\n\t}\n\trcu_read_unlock();\n\n\treturn file;\n}",
        "output": "1",
        "idx": 4579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CtcpParser::sendCtcpEvent(CtcpEvent *e) {\n  CoreNetwork *net = coreNetwork(e);\n  if(e->type() == EventManager::CtcpEvent) {\n    QByteArray quotedReply;\n    QString bufname = nickFromMask(e->prefix());\n    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {\n      if(_replies.contains(e->uuid()))\n        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),\n                                                          net->userEncode(bufname, e->reply())));\n      else\n        // reply not caused by a request processed in here, so send it off immediately\n        reply(net, bufname, e->ctcpCmd(), e->reply());\n    }\n  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {\n    CtcpReply reply = _replies.take(e->uuid());\n    if(reply.replies.count())\n      packedReply(net, reply.bufferName, reply.replies);\n  }\n}",
        "output": "0",
        "idx": 3766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "        static int on_method(http_parser* self_)\n        {\n            HTTPParser* self = static_cast<HTTPParser*>(self_);\n            self->req.method = static_cast<HTTPMethod>(self->method);\n\n            return 0;\n        }",
        "output": "0",
        "idx": 5378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)\n\n{\n\n    buf[0] = 0;\n\n    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);\n\n    AV_WB16(&buf[4], s->w);\n\n    AV_WB16(&buf[6], s->h);\n\n    AV_WB16(&buf[8], num_strips);\n\n\n\n    return CVID_HEADER_SIZE;\n\n}\n",
        "output": "1",
        "idx": 4126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint16_t net_checksum_finish(uint32_t sum)\n\n{\n\n    while (sum>>16)\n\n\tsum = (sum & 0xFFFF)+(sum >> 16);\n\n    return ~sum;\n\n}\n",
        "output": "0",
        "idx": 5319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extract_job_on_completed (AutoarExtractor *extractor,\n                          gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *output_file;\n\n    output_file = G_FILE (extract_job->output_files->data);\n\n    nautilus_file_changes_queue_file_added (output_file);\n}",
        "output": "0",
        "idx": 3640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cancel_refresh(dns_zone_t *zone) {\n\tconst char me[] = \"cancel_refresh\";\n\tisc_time_t now;\n\n\t/*\n\t * 'zone' locked by caller.\n\t */\n\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\tREQUIRE(LOCKED_ZONE(zone));\n\n\tENTER;\n\n\tDNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);\n\tTIME_NOW(&now);\n\tzone_settimer(zone, &now);\n}",
        "output": "0",
        "idx": 3536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return &d->mmio;\n\n}\n",
        "output": "0",
        "idx": 5408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AioHandler *find_aio_handler(int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    LIST_FOREACH(node, &aio_handlers, node) {\n\n        if (node->fd == fd)\n\n            return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n",
        "output": "1",
        "idx": 5631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {\n  Isolate* isolate = env()->isolate();\n  HandleScope scope(isolate);\n  Local<Context> context = env()->context();\n  Context::Scope context_scope(context);\n  Local<Value> arg;\n  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;\n  if (ack) {\n    BaseObjectPtr<Http2Ping> ping = PopPing();\n\n    if (!ping) {\n      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2\n      // spec does not require this, but there is no legitimate reason to\n      // receive an unsolicited PING ack on a connection. Either the peer\n      // is buggy or malicious, and we're not going to tolerate such\n      // nonsense.\n      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);\n      MakeCallback(env()->http2session_on_error_function(), 1, &arg);\n      return;\n    }\n\n    ping->Done(true, frame->ping.opaque_data);\n    return;\n  }\n\n  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;\n  // Notify the session that a ping occurred\n  arg = Buffer::Copy(\n      env(),\n      reinterpret_cast<const char*>(frame->ping.opaque_data),\n      8).ToLocalChecked();\n  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);\n}",
        "output": "0",
        "idx": 246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n",
        "output": "1",
        "idx": 2461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EXPORTED void simple_hdr(struct transaction_t *txn,\n                         const char *name, const char *value, ...)\n{\n    struct buf buf = BUF_INITIALIZER;\n    va_list args;\n\n    va_start(args, value);\n    buf_vprintf(&buf, value, args);\n    va_end(args);\n\n    syslog(LOG_DEBUG, \"simple_hdr(%s: %s)\", name, buf_cstring(&buf));\n\n    if (txn->flags.ver == VER_2) {\n        http2_add_header(txn, name, &buf);\n    }\n    else {\n        prot_printf(txn->conn->pout, \"%c%s: \", toupper(name[0]), name+1);\n        prot_puts(txn->conn->pout, buf_cstring(&buf));\n        prot_puts(txn->conn->pout, \"\\r\\n\");\n\n        buf_free(&buf);\n    }\n}",
        "output": "0",
        "idx": 5420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char *argv[])\n{\n    int             i;\n    struct tree    *tp;\n    netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS, 2);\n\n    netsnmp_init_mib();\n\n    if (argc == 1)\n        (void) read_all_mibs();\n    else\n        for (i = 1; i < argc; i++)\n            read_mib(argv[i]);\n\n    for (tp = tree_head; tp; tp = tp->next_peer)\n        print_subtree(stdout, tp, 0);\n    free_tree(tree_head);\n\n    return 0;\n}",
        "output": "0",
        "idx": 4455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,\n\t\t\t      size_t size, loff_t *offset)\n{\n\tstruct kvm *kvm = file->private_data;\n\n\treturn kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,\n\t\t\t\t&kvm_vm_stats_desc[0], &kvm->stat,\n\t\t\t\tsizeof(kvm->stat), user_buffer, size, offset);",
        "output": "0",
        "idx": 5570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "output": "1",
        "idx": 2001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vhost_user_send_rarp(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tuint8_t *mac = (uint8_t *)&msg->payload.u64;\n\tstruct rte_vdpa_device *vdpa_dev;\n\tint did = -1;\n\n\tRTE_LOG(DEBUG, VHOST_CONFIG,\n\t\t\":: mac: %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n\tmemcpy(dev->mac.addr_bytes, mac, 6);\n\n\t/*\n\t * Set the flag to inject a RARP broadcast packet at\n\t * rte_vhost_dequeue_burst().\n\t *\n\t * rte_smp_wmb() is for making sure the mac is copied\n\t * before the flag is set.\n\t */\n\trte_smp_wmb();\n\trte_atomic16_set(&dev->broadcast_rarp, 1);\n\tdid = dev->vdpa_dev_id;\n\tvdpa_dev = rte_vdpa_get_device(did);\n\tif (vdpa_dev && vdpa_dev->ops->migration_done)\n\t\tvdpa_dev->ops->migration_done(dev->vid);\n\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}",
        "output": "1",
        "idx": 1626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static inline UClassID getStaticClassID() {\n        return (UClassID)&fgClassID;\n    }",
        "output": "0",
        "idx": 1294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlBufferCCat(xmlBufferPtr buf, const char *str) {\n    const char *cur;\n\n    if (buf == NULL)\n        return(-1);\n    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n    if (str == NULL) {\n#ifdef DEBUG_BUFFER\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlBufferCCat: str == NULL\\n\");\n#endif\n\treturn -1;\n    }\n    for (cur = str;*cur != 0;cur++) {\n        if (buf->use  + 10 >= buf->size) {\n            if (!xmlBufferResize(buf, buf->use+10)){\n\t\txmlTreeErrMemory(\"growing buffer\");\n                return XML_ERR_NO_MEMORY;\n            }\n        }\n        buf->content[buf->use++] = *cur;\n    }\n    buf->content[buf->use] = 0;\n    return 0;\n}",
        "output": "1",
        "idx": 2848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t do_strtosz(const char *nptr, char **end,\n\n                          const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval;\n\n    char *endptr;\n\n    unsigned char c;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    c = *endptr;\n\n    mul = suffix_mul(c, unit);\n\n    if (mul >= 0) {\n\n        endptr++;\n\n    } else {\n\n        mul = suffix_mul(default_suffix, unit);\n\n        assert(mul >= 0);\n\n    }\n\n    if (mul == 1 && mul_required) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        retval = -ERANGE;\n\n        goto out;\n\n    }\n\n    retval = val * mul;\n\n\n\nout:\n\n    if (end) {\n\n        *end = endptr;\n\n    } else if (*endptr) {\n\n        retval = -EINVAL;\n\n    }\n\n\n\n    return retval;\n\n}\n",
        "output": "0",
        "idx": 1547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n\n{\n\n    unsigned int tag;\n\n    int64_t size;\n\n\n\n    for (;;) {\n\n        if (url_feof(pb))\n\n            return AVERROR_EOF;\n\n        size = next_tag(pb, &tag);\n\n        if (tag == tag1)\n\n            break;\n\n        wav_seek_tag(pb, size, SEEK_CUR);\n\n    }\n\n    return size;\n\n}\n",
        "output": "0",
        "idx": 2015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t runtime_active_time_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tu64 tmp = pm_runtime_active_time(dev);\n\tdo_div(tmp, NSEC_PER_MSEC);\n\tret = sprintf(buf, \"%llu\\n\", tmp);\n\treturn ret;\n}",
        "output": "1",
        "idx": 5027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n",
        "output": "1",
        "idx": 5133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t control_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t\t\tdev->power.runtime_auto ? ctrl_auto : ctrl_on);\n}",
        "output": "1",
        "idx": 1505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_bugs_smt_update(void)\n{\n\tmutex_lock(&spec_ctrl_mutex);\n\n\tswitch (spectre_v2_user) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\tbreak;\n\tcase SPECTRE_V2_USER_STRICT:\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\tupdate_stibp_strict();\n\t\tbreak;\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tupdate_indir_branch_cond();\n\t\tbreak;\n\t}\n\n\tswitch (mds_mitigation) {\n\tcase MDS_MITIGATION_FULL:\n\tcase MDS_MITIGATION_VMWERV:\n\t\tif (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))\n\t\t\tpr_warn_once(MDS_MSG_SMT);\n\t\tupdate_mds_branch_idle();\n\t\tbreak;\n\tcase MDS_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tswitch (taa_mitigation) {\n\tcase TAA_MITIGATION_VERW:\n\tcase TAA_MITIGATION_UCODE_NEEDED:\n\t\tif (sched_smt_active())\n\t\t\tpr_warn_once(TAA_MSG_SMT);\n\t\tbreak;\n\tcase TAA_MITIGATION_TSX_DISABLED:\n\tcase TAA_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&spec_ctrl_mutex);\n}",
        "output": "1",
        "idx": 6007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "axfr_rrstream_first(rrstream_t *rs) {\n\taxfr_rrstream_t *s = (axfr_rrstream_t *) rs;\n\tisc_result_t result;\n\tresult = dns_rriterator_first(&s->it);\n\tif (result != ISC_R_SUCCESS)\n\t\treturn (result);\n\t/* Skip SOA records. */\n\tfor (;;) {\n\t\tdns_name_t *name_dummy = NULL;\n\t\tuint32_t ttl_dummy;\n\t\tdns_rdata_t *rdata = NULL;\n\t\tdns_rriterator_current(&s->it, &name_dummy,\n\t\t\t\t       &ttl_dummy, NULL, &rdata);\n\t\tif (rdata->type != dns_rdatatype_soa)\n\t\t\tbreak;\n\t\tresult = dns_rriterator_next(&s->it);\n\t\tif (result != ISC_R_SUCCESS)\n\t\t\tbreak;\n\t}\n\treturn (result);\n}",
        "output": "0",
        "idx": 2544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void testCacheManager::setUp()\n{\n    Mem::Init();\n}",
        "output": "1",
        "idx": 3006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n",
        "output": "1",
        "idx": 3455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int find_best(struct vf_instance *vf){\n\n  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);\n\n  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))\n\n    return IMGFMT_YV12;\n\n  else\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (drv->bdrv_snapshot_delete) {\n\n        return drv->bdrv_snapshot_delete(bs, snapshot_id);\n\n    }\n\n    if (bs->file) {\n\n        return bdrv_snapshot_delete(bs->file, snapshot_id);\n\n    }\n\n    return -ENOTSUP;\n\n}\n",
        "output": "1",
        "idx": 5068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qcow2_change_backing_file(BlockDriverState *bs,\n\n    const char *backing_file, const char *backing_fmt)\n\n{\n\n    return qcow2_update_ext_header(bs, backing_file, backing_fmt);\n\n}\n",
        "output": "1",
        "idx": 1001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n        int flags)\n\n{\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"PC=%08x\\n\", env->pc);\n\n\n\n    for (i = 0; i < 16; ++i) {\n\n        cpu_fprintf(f, \"A%02d=%08x%c\", i, env->regs[i],\n\n                (i % 4) == 3 ? '\\n' : ' ');\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n",
        "output": "1",
        "idx": 438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_cpreg_to_list(gpointer key, gpointer opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    uint64_t regidx;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    regidx = *(uint32_t *)key;\n\n    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);\n\n\n\n    if (!(ri->type & ARM_CP_NO_MIGRATE)) {\n\n        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);\n\n        /* The value array need not be initialized at this point */\n\n        cpu->cpreg_array_len++;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "napi_status napi_get_value_string_utf16(napi_env env,\n                                        napi_value value,\n                                        char16_t* buf,\n                                        size_t bufsize,\n                                        size_t* result) {\n  CHECK_ENV(env);\n  CHECK_ARG(env, value);\n\n  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);\n\n  if (!buf) {\n    CHECK_ARG(env, result);\n    // V8 assumes UTF-16 length is the same as the number of characters.\n    *result = val.As<v8::String>()->Length();\n  } else {\n    int copied = val.As<v8::String>()->Write(env->isolate,\n                                             reinterpret_cast<uint16_t*>(buf),\n                                             0,\n                                             bufsize - 1,\n                                             v8::String::NO_NULL_TERMINATION);\n\n    buf[copied] = '\\0';\n    if (result != nullptr) {\n      *result = copied;\n    }\n  }\n\n  return napi_clear_last_error(env);\n}",
        "output": "1",
        "idx": 1116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rng_random_set_filename(Object *obj, const char *filename,\n\n                                 Error **errp)\n\n{\n\n    RngBackend *b = RNG_BACKEND(obj);\n\n    RndRandom *s = RNG_RANDOM(obj);\n\n\n\n    if (b->opened) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    if (s->filename) {\n\n        g_free(s->filename);\n\n    }\n\n\n\n    s->filename = g_strdup(filename);\n\n}\n",
        "output": "0",
        "idx": 4531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n\n            if (op == self) {\n                continue;\n            }\n\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 4326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Curl_http_output_auth(struct Curl_easy *data,\n                      struct connectdata *conn,\n                      const char *request,\n                      Curl_HttpReq httpreq,\n                      const char *path,\n                      bool proxytunnel)\n{\n  (void)data;\n  (void)conn;\n  (void)request;\n  (void)httpreq;\n  (void)path;\n  (void)proxytunnel;\n  return CURLE_OK;\n}",
        "output": "1",
        "idx": 691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n\n    // Test overflow of exponent\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n\n    // Test edge case overflow of exponent\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n}",
        "output": "1",
        "idx": 3280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PHP_GINIT_FUNCTION(pcntl)\n{ \n\tmemset(pcntl_globals, 0, sizeof(*pcntl_globals));\n}",
        "output": "1",
        "idx": 2288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)\n{\n  if (length < 12)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+4,\"ftyp\",4) != 0)\n  return(MagickFalse);\n  if (LocaleNCompare((const char *) magick+8,\"heic\",4) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick+8,\"heix\",4) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick+8,\"mif1\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}",
        "output": "0",
        "idx": 1919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n",
        "output": "0",
        "idx": 1160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n    frame->width  = w;\n    frame->height = h;\n\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n\n    return frame;\n}",
        "output": "1",
        "idx": 3438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n",
        "output": "1",
        "idx": 1445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= buff;\n  *((my_bool *)buff)= (my_bool) (active_mi && \n                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&\n                                 active_mi->rli.slave_running);\n  return 0;\n}",
        "output": "0",
        "idx": 6201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,\n\t\t\t\t   uint32_t user_account_control, uint32_t *account_type_p)\n{\n\tint ret;\n\tuint32_t account_type;\n\tstruct ldb_message_element *el;\n\n\taccount_type = ds_uf2atype(user_account_control);\n\tif (account_type == 0) {\n\t\tldb_set_errstring(ldb, \"dsdb: Unrecognized account type!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,\n\t\t\t\t \"sAMAccountType\",\n\t\t\t\t account_type);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tel = ldb_msg_find_element(usr_obj, \"sAMAccountType\");\n\tel->flags = LDB_FLAG_MOD_REPLACE;\n\n\tif (account_type_p) {\n\t\t*account_type_p = account_type;\n\t}\n\n\treturn LDB_SUCCESS;\n}",
        "output": "1",
        "idx": 2472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dtls1_read_failed(SSL *s, int code)\n\t{\n\tif ( code > 0)\n\t\t{\n\t\tfprintf( stderr, \"invalid state reached %s:%d\", __FILE__, __LINE__);\n\t\treturn 1;\n\t\t}\n\n\tif (!dtls1_is_timer_expired(s))\n\t\t{\n\t\t/* not a timeout, none of our business, \n\t\t   let higher layers handle this.  in fact it's probably an error */\n\t\treturn code;\n\t\t}\n\n\tif ( ! SSL_in_init(s))  /* done, no need to send a retransmit */\n\t\t{\n\t\tBIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);\n\t\treturn code;\n\t\t}\n\n#if 0 /* for now, each alert contains only one record number */\n\titem = pqueue_peek(state->rcvd_records);\n\tif ( item )\n\t\t{\n\t\t/* send an alert immediately for all the missing records */\n\t\t}\n\telse\n#endif\n\n#if 0  /* no more alert sending, just retransmit the last set of messages */\n\tif ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)\n\t\tssl3_send_alert(s,SSL3_AL_WARNING,\n\t\t\tDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\n#endif\n\n\treturn dtls1_handle_timeout(s);\n\t}",
        "output": "1",
        "idx": 4242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rdt_free_extradata (PayloadContext *rdt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_STREAMS; i++)\n\n        if (rdt->rmst[i]) {\n\n            ff_rm_free_rmstream(rdt->rmst[i]);\n\n            av_freep(&rdt->rmst[i]);\n\n        }\n\n    if (rdt->rmctx)\n\n        av_close_input_stream(rdt->rmctx);\n\n    av_freep(&rdt->mlti_data);\n\n    av_free(rdt);\n\n}\n",
        "output": "0",
        "idx": 4046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;\n}",
        "output": "0",
        "idx": 4254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long dsgetn(DviContext *dvi, size_t n)\n{\n\tlong\tval;\n\n\tif(NEEDBYTES(dvi, n) && get_bytes(dvi, n) == -1)\n\t\treturn -1;\n\tval = msgetn(dvi->buffer.data + dvi->buffer.pos, n);\n\tdvi->buffer.pos += n;\n\treturn val;\n}",
        "output": "0",
        "idx": 2059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int smapsGetSharedDirty(unsigned long addr) {\n    int ret, in_mapping = 0, val = -1;\n    unsigned long from, to;\n    char buf[64];\n    FILE *f;\n\n    f = fopen(\"/proc/self/smaps\", \"r\");\n    if (!f) return -1;\n\n    while (1) {\n        if (!fgets(buf, sizeof(buf), f))\n            break;\n\n        ret = sscanf(buf, \"%lx-%lx\", &from, &to);\n        if (ret == 2)\n            in_mapping = from <= addr && addr < to;\n\n        if (in_mapping && !memcmp(buf, \"Shared_Dirty:\", 13)) {\n            sscanf(buf, \"%*s %d\", &val);\n            /* If parsing fails, we remain with val == -1 */\n            break;\n        }\n    }\n\n    fclose(f);\n    return val;\n}",
        "output": "0",
        "idx": 566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t size_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%uK\\n\", this_leaf->size >> 10);\n}",
        "output": "1",
        "idx": 3293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtQueue *vq;\n\n\n\n    vq = vser->c_ivq;\n\n    if (!virtio_queue_ready(vq)) {\n\n        return 0;\n\n    }\n\n    if (!virtqueue_pop(vq, &elem)) {\n\n        return 0;\n\n    }\n\n\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n\n\n    virtqueue_push(vq, &elem, len);\n\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n\n    return len;\n\n}\n",
        "output": "0",
        "idx": 194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_gray_color_procs(gx_device * pdev,\n        dev_t_proc_encode_color((*encode_color), gx_device),\n        dev_t_proc_decode_color((*decode_color), gx_device))\n{\n    set_color_procs(pdev, encode_color, decode_color,\n        gx_default_DevGray_get_color_mapping_procs,\n        gx_default_DevGray_get_color_comp_index);\n}",
        "output": "1",
        "idx": 2862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HELPER(wsr_ibreakenable)(uint32_t v)\n\n{\n\n    uint32_t change = v ^ env->sregs[IBREAKENABLE];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < env->config->nibreak; ++i) {\n\n        if (change & (1 << i)) {\n\n            tb_invalidate_phys_page_range(\n\n                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);\n\n        }\n\n    }\n\n    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);\n\n}\n",
        "output": "0",
        "idx": 3553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline int Http2Session::OnFrameReceive(nghttp2_session* handle,\n                                        const nghttp2_frame* frame,\n                                        void* user_data) {\n  Http2Session* session = static_cast<Http2Session*>(user_data);\n  session->statistics_.frame_count++;\n  DEBUG_HTTP2SESSION2(session, \"complete frame received: type: %d\",\n                      frame->hd.type);\n  switch (frame->hd.type) {\n    case NGHTTP2_DATA:\n      session->HandleDataFrame(frame);\n      break;\n    case NGHTTP2_PUSH_PROMISE:\n      // Intentional fall-through, handled just like headers frames\n    case NGHTTP2_HEADERS:\n      session->HandleHeadersFrame(frame);\n      break;\n    case NGHTTP2_SETTINGS:\n      session->HandleSettingsFrame(frame);\n      break;\n    case NGHTTP2_PRIORITY:\n      session->HandlePriorityFrame(frame);\n      break;\n    case NGHTTP2_GOAWAY:\n      session->HandleGoawayFrame(frame);\n      break;\n    case NGHTTP2_PING:\n      session->HandlePingFrame(frame);\n    default:\n      break;\n  }\n  return 0;\n}",
        "output": "1",
        "idx": 1028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int wait_for_discard(void *word)\n{\n\tschedule();\n\treturn 0;\n}",
        "output": "0",
        "idx": 3875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void * realloc(void * p, size_t lb)\n    {\n      return(REDIRECT_REALLOC(p, lb));\n    }",
        "output": "0",
        "idx": 974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}",
        "output": "1",
        "idx": 4167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}",
        "output": "0",
        "idx": 1046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Vers_history_point::bad_expression_data_type_error(const char *type) const\n{\n  my_error(ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION, MYF(0),\n           type, \"FOR SYSTEM_TIME\");\n}",
        "output": "0",
        "idx": 3275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dev_new_index(struct net *net)\n{\n\tstatic int ifindex;\n\tfor (;;) {\n\t\tif (++ifindex <= 0)\n\t\t\tifindex = 1;\n\t\tif (!__dev_get_by_index(net, ifindex))\n\t\t\treturn ifindex;\n\t}\n}",
        "output": "0",
        "idx": 4976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ftp_file_size(FTPContext *s)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    char *res = NULL;\n\n    const int size_codes[] = {213, 0};\n\n\n\n    snprintf(command, sizeof(command), \"SIZE %s\\r\\n\", s->path);\n\n    if (ftp_send_command(s, command, size_codes, &res)) {\n\n        s->filesize = strtoll(&res[4], NULL, 10);\n\n    } else {\n\n        s->filesize = -1;\n\n        av_free(res);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    av_free(res);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, flags=%x\", to, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);\n\n    if (conn->driver->domainCoreDump) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute core file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainCoreDump(domain, absolute_to, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
        "output": "0",
        "idx": 2867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n",
        "output": "0",
        "idx": 5702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t uart_mode_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\treturn sprintf(buf, \"%d\\n\", edge_port->bUartMode);\n}",
        "output": "0",
        "idx": 1172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,\n\t\t\t\t\t     const pjsip_auth_clt_pref *p)\n{\n    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);\n\n    pj_memcpy(&sess->pref, p, sizeof(*p));\n    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);\n    //if (sess->pref.algorithm.slen == 0)\n    //\tsess->pref.algorithm = pj_str(\"MD5\");\n\n    return PJ_SUCCESS;\n}",
        "output": "0",
        "idx": 4330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base;\n\tstruct timespec realtime_offset;\n\tunsigned long seq;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\tdo {\n\t\tseq = read_seqbegin(&xtime_lock);\n\t\tset_normalized_timespec(&realtime_offset,\n\t\t\t\t\t-wall_to_monotonic.tv_sec,\n\t\t\t\t\t-wall_to_monotonic.tv_nsec);\n\t} while (read_seqretry(&xtime_lock, seq));\n\n\tbase = &__get_cpu_var(hrtimer_bases);\n\n\t/* Adjust CLOCK_REALTIME offset */\n\tspin_lock(&base->lock);\n\tbase->clock_base[CLOCK_REALTIME].offset =\n\t\ttimespec_to_ktime(realtime_offset);\n\n\thrtimer_force_reprogram(base);\n\tspin_unlock(&base->lock);\n}",
        "output": "0",
        "idx": 3933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cancel_subscription(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"cancel_subscription(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Subscription #%d does not exist.\"), sub_id);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                             DefaultPolicyPtr,\n                                 con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n /*\n  * Cancel the subscription...\n  */\n\n  cupsdDeleteSubscription(sub, 1);\n\n  con->response->request.status.status_code = IPP_OK;\n}",
        "output": "0",
        "idx": 2765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tfile_transfer_t *ft = data;\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpx->timeout = 0;\n\n\tif (ft->write == NULL) {\n\t\tft->write = prpl_xfer_write;\n\t\timcb_file_recv_start(px->ic, ft);\n\t}\n\n\tft->write_request(ft);\n\n\treturn FALSE;\n}",
        "output": "0",
        "idx": 413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Value ExpressionDivide::evaluate(const Document& root, Variables* variables) const {\n    Value lhs = _children[0]->evaluate(root, variables);\n    Value rhs = _children[1]->evaluate(root, variables);\n\n    auto assertNonZero = [](bool nonZero) { uassert(16608, \"can't $divide by zero\", nonZero); };\n\n    if (lhs.numeric() && rhs.numeric()) {\n        // If, and only if, either side is decimal, return decimal.\n        if (lhs.getType() == NumberDecimal || rhs.getType() == NumberDecimal) {\n            Decimal128 numer = lhs.coerceToDecimal();\n            Decimal128 denom = rhs.coerceToDecimal();\n            assertNonZero(!denom.isZero());\n            return Value(numer.divide(denom));\n        }\n\n        double numer = lhs.coerceToDouble();\n        double denom = rhs.coerceToDouble();\n        assertNonZero(denom != 0.0);\n\n        return Value(numer / denom);\n    } else if (lhs.nullish() || rhs.nullish()) {\n        return Value(BSONNULL);\n    } else {\n        uasserted(16609,\n                  str::stream() << \"$divide only supports numeric types, not \"\n                                << typeName(lhs.getType()) << \" and \" << typeName(rhs.getType()));\n    }\n}",
        "output": "0",
        "idx": 3772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}",
        "output": "0",
        "idx": 3709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_attr_local_pref(struct bgp_attr_parser_args *args)\n{\n\tstruct peer *const peer = args->peer;\n\tstruct attr *const attr = args->attr;\n\tconst bgp_size_t length = args->length;\n\n\t/* Length check. */\n\tif (length != 4) {\n\t\tflog_err(EC_BGP_ATTR_LEN,\n\t\t\t \"LOCAL_PREF attribute length isn't 4 [%u]\", length);\n\t\treturn bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t  args->total);\n\t}\n\n\t/* If it is contained in an UPDATE message that is received from an\n\t   external peer, then this attribute MUST be ignored by the\n\t   receiving speaker. */\n\tif (peer->sort == BGP_PEER_EBGP) {\n\t\tstream_forward_getp(peer->curr, length);\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\t}\n\n\tattr->local_pref = stream_getl(peer->curr);\n\n\t/* Set the local-pref flag. */\n\tattr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}",
        "output": "0",
        "idx": 5797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)\n{\n\tcit_write_reg(gspca_dev, 0x0078, 0x012d);\n\tcit_write_reg(gspca_dev, v1,     0x012f);\n\tcit_write_reg(gspca_dev, 0xd141, 0x0124);\n\tcit_write_reg(gspca_dev, v2,     0x0127);\n\tcit_write_reg(gspca_dev, 0xfea8, 0x0124);\n}",
        "output": "0",
        "idx": 849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (emulate_instruction(vcpu, EMULTYPE_SKIP) !=\n\t\t\t\tEMULATE_DONE)\n\t\t\tprintk(KERN_DEBUG \"%s: NOP\\n\", __func__);\n\t\treturn;\n\t}\n\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\tprintk(KERN_ERR \"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\n\tkvm_rip_write(vcpu, svm->next_rip);\n\tsvm_set_interrupt_shadow(vcpu, 0);\n}",
        "output": "0",
        "idx": 3272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\tzval *str = &EX_T(opline->result.u.var).tmp_var;\n\n\tif (IS_TMP_VAR == IS_UNUSED) {\n\t\t/* Initialize for erealloc in add_string_to_string */\n\t\tZ_STRVAL_P(str) = NULL;\n\t\tZ_STRLEN_P(str) = 0;\n\t\tZ_TYPE_P(str) = IS_STRING;\n\n\t\tINIT_PZVAL(str);\n\t}\n\n\tadd_string_to_string(str, str, &opline->op2.u.constant);\n\n\t/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */\n\tZEND_VM_NEXT_OPCODE();\n}",
        "output": "0",
        "idx": 325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *umm_realloc( void *ptr, size_t size ) {\n  void *ret;\n\n  ptr = GET_UNPOISONED(ptr);\n\n  /* check poison of each blocks, if poisoning is enabled */\n  if (!CHECK_POISON_ALL_BLOCKS()) {\n    return NULL;\n  }\n\n  /* check full integrity of the heap, if this check is enabled */\n  if (!INTEGRITY_CHECK()) {\n    return NULL;\n  }\n\n  size += POISON_SIZE(size);\n  ret = _umm_realloc( ptr, size );\n\n  ret = GET_POISONED(ret, size);\n\n  umm_account_free_blocks_cnt();\n\n  return ret;\n}",
        "output": "1",
        "idx": 892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        /* Default advertisement. */\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}",
        "output": "1",
        "idx": 5606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {\n    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));\n}",
        "output": "0",
        "idx": 2895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n",
        "output": "0",
        "idx": 4953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool asn1_read_OctetString(struct asn1_data *data, TALLOC_CTX *mem_ctx, DATA_BLOB *blob)\n{\n\tint len;\n\tZERO_STRUCTP(blob);\n\tif (!asn1_start_tag(data, ASN1_OCTET_STRING)) return false;\n\tlen = asn1_tag_remaining(data);\n\tif (len < 0) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\t*blob = data_blob_talloc(mem_ctx, NULL, len+1);\n\tif (!blob->data || blob->length < len) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\tasn1_read(data, blob->data, len);\n\tasn1_end_tag(data);\n\tblob->length--;\n\tblob->data[len] = 0;\n\t\n\tif (data->has_error) {\n\t\tdata_blob_free(blob);\n\t\t*blob = data_blob_null;\n\t\treturn false;\n\t}\n\treturn true;\n}",
        "output": "1",
        "idx": 6186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_mask (void)\n{\n    RsvgMask *mask;\n\n    mask = g_new (RsvgMask, 1);\n    _rsvg_node_init (&mask->super, RSVG_NODE_TYPE_MASK);\n    mask->maskunits = objectBoundingBox;\n    mask->contentunits = userSpaceOnUse;\n    mask->x = _rsvg_css_parse_length (\"0\");\n    mask->y = _rsvg_css_parse_length (\"0\");\n    mask->width = _rsvg_css_parse_length (\"1\");\n    mask->height = _rsvg_css_parse_length (\"1\");\n    mask->super.set_atts = rsvg_mask_set_atts;\n    return &mask->super;\n}",
        "output": "0",
        "idx": 1438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n",
        "output": "1",
        "idx": 152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tif(s) {\n\t\tatomic_dec(&unix_sk(s)->inflight);\n\t\tatomic_dec(&unix_tot_inflight);\n\t}\n}",
        "output": "1",
        "idx": 2359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        pxa2xx_i2c_write(s->i2c[1], addr, value);\n\n        return;\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR:\n\n        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);\n\n        s->pm_regs[addr >> 2] |= value & 0x15;\n\n        break;\n\n\n\n    case PSSR:\t/* Read-clean registers */\n\n    case RCSR:\n\n    case PKSR:\n\n        s->pm_regs[addr >> 2] &= ~value;\n\n        break;\n\n\n\n    default:\t/* Read-write registers */\n\n        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {\n\n            s->pm_regs[addr >> 2] = value;\n\n            break;\n\n        }\n\n\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 4762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    int opcode, len;\n    int retval = 0;\n    const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_handle_dcmd(cmd->index, opcode);\n    len = megasas_map_dcmd(s, cmd);\n    if (len < 0) {\n        return MFI_STAT_MEMORY_NOT_AVAILABLE;\n    }\n    while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n        cmdptr++;\n    }\n    if (cmdptr->opcode == -1) {\n        trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n        retval = megasas_dcmd_dummy(s, cmd);\n    } else {\n        trace_megasas_dcmd_enter(cmd->index, cmdptr->desc, len);\n        retval = cmdptr->func(s, cmd);\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, len);\n    }\n    return retval;\n}",
        "output": "1",
        "idx": 5585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QString AOClient::decodeMessage(QString incoming_message)\n{\n   QString decoded_message = incoming_message.replace(\"<num>\", \"#\")\n                                             .replace(\"<percent>\", \"%\")\n                                             .replace(\"<dollar>\", \"$\")\n                                             .replace(\"<and>\", \"&\");\n    return decoded_message;\n}",
        "output": "0",
        "idx": 2857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t\t struct perf_event *event)\n{\n\tu64 sample_type = event->attr.sample_type;\n\n\tdata->type = sample_type;\n\theader->size += event->id_header_size;\n\n\tif (sample_type & PERF_SAMPLE_TID) {\n\t\t/* namespace issues */\n\t\tdata->tid_entry.pid = perf_event_pid(event, current);\n\t\tdata->tid_entry.tid = perf_event_tid(event, current);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tdata->time = perf_event_clock(event);\n\n\tif (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))\n\t\tdata->id = primary_event_id(event);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tdata->stream_id = event->id;\n\n\tif (sample_type & PERF_SAMPLE_CPU) {\n\t\tdata->cpu_entry.cpu\t = raw_smp_processor_id();\n\t\tdata->cpu_entry.reserved = 0;\n\t}\n}",
        "output": "0",
        "idx": 1062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sd_read_block_characteristics(struct scsi_disk *sdkp)\n{\n\tunsigned char *buffer;\n\tu16 rot;\n\tconst int vpd_len = 64;\n\n\tbuffer = kmalloc(vpd_len, GFP_KERNEL);\n\n\tif (!buffer ||\n\t    /* Block Device Characteristics VPD */\n\t    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))\n\t\tgoto out;\n\n\trot = get_unaligned_be16(&buffer[4]);\n\n\tif (rot == 1)\n\t\tqueue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);\n\n out:\n\tkfree(buffer);\n}",
        "output": "0",
        "idx": 4544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_queued_data(VirtIOSerialPort *port, bool discard)\n\n{\n\n    assert(port || discard);\n\n\n\n    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);\n\n}\n",
        "output": "1",
        "idx": 4714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tjas_icccurv_t *curv = &attrval->data.curv;\n\tunsigned int i;\n\n\tcurv->numents = 0;\n\tcurv->ents = 0;\n\n\tif (jas_iccgetuint32(in, &curv->numents))\n\t\tgoto error;\n\tif (!(curv->ents = jas_malloc(curv->numents * sizeof(jas_iccuint16_t))))\n\t\tgoto error;\n\tfor (i = 0; i < curv->numents; ++i) {\n\t\tif (jas_iccgetuint16(in, &curv->ents[i]))\n\t\t\tgoto error;\n\t}\n\n\tif (JAS_CAST(int, 4 + 2 * curv->numents) != cnt)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tjas_icccurv_destroy(attrval);\n\treturn -1;\n}",
        "output": "1",
        "idx": 6020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QString BootDoctor::errorString()\n{\n    return m_lastErrorString;\n}",
        "output": "0",
        "idx": 1959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, qiov, offset);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n",
        "output": "1",
        "idx": 2456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_visitor_in_native_list_int32(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);\n\n}\n",
        "output": "0",
        "idx": 1826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n\n{\n\n    av_assert0(0);\n\n\n}",
        "output": "1",
        "idx": 1066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static void auditCreateOrUpdateUser(const BSONObj& userObj, bool create) {\n        UserName userName = extractUserNameFromBSON(userObj);\n        std::vector<RoleName> roles;\n        uassertStatusOK(auth::parseRoleNamesFromBSONArray(\n            BSONArray(userObj[\"roles\"].Obj()), userName.getDB(), &roles));\n        BSONObj customData;\n        if (userObj.hasField(\"customData\")) {\n            customData = userObj[\"customData\"].Obj();\n        }\n\n        if (create) {\n            audit::logCreateUser(Client::getCurrent(),\n                                 userName,\n                                 userObj[\"credentials\"].Obj().hasField(\"MONGODB-CR\"),\n                                 userObj.hasField(\"customData\") ? &customData : NULL,\n                                 roles);\n        } else {\n            audit::logUpdateUser(Client::getCurrent(),\n                                 userName,\n                                 userObj[\"credentials\"].Obj().hasField(\"MONGODB-CR\"),\n                                 userObj.hasField(\"customData\") ? &customData : NULL,\n                                 &roles);\n        }\n    }",
        "output": "0",
        "idx": 1687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n",
        "output": "1",
        "idx": 1084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {\n  max_stream_duration_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  Event::MockTimer* duration_timer = setUpTimer();\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {\n    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);\n    conn_manager_->newStream(response_encoder_);\n    return Http::okStatus();\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_CALL(*duration_timer, disableTimer());\n  duration_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());\n}",
        "output": "0",
        "idx": 1456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int raw_init_encoder(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = (AVFrame *)avctx->priv_data;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->codec_tag = findFourCC(avctx->pix_fmt);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "detect_mysql_capabilities_for_backup()\n{\n\tif (xtrabackup_incremental) {\n\t\t/* INNODB_CHANGED_PAGES are listed in\n\t\tINFORMATION_SCHEMA.PLUGINS in MariaDB, but\n\t\tFLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS\n\t\tis not supported for versions below 10.1.6\n\t\t(see MDEV-7472) */\n\t\tif (server_flavor == FLAVOR_MARIADB &&\n\t\t    mysql_server_version < 100106) {\n\t\t\thave_changed_page_bitmaps = false;\n\t\t}\n\t}\n\n\t/* do some sanity checks */\n\tif (opt_galera_info && !have_galera_enabled) {\n\t\tmsg(\"--galera-info is specified on the command \"\n\t\t \t\"line, but the server does not support Galera \"\n\t\t \t\"replication. Ignoring the option.\\n\");\n\t\topt_galera_info = false;\n\t}\n\n\tif (opt_slave_info && have_multi_threaded_slave &&\n\t    !have_gtid_slave && !opt_safe_slave_backup) {\n\t\tmsg(\"The --slave-info option requires GTID enabled or \"\n\t\t\t\"--safe-slave-backup option used for a multi-threaded \"\n\t\t\t\"slave.\\n\");\n\t\treturn(false);\n\t}\n\n\treturn(true);\n}",
        "output": "0",
        "idx": 5864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n",
        "output": "0",
        "idx": 3935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)\n{\n\treturn hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,\n\t\t\t\t    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,\n\t\t\t\t    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);\n}",
        "output": "0",
        "idx": 690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);\n\n}\n",
        "output": "0",
        "idx": 3696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nGF_Box *segr_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;",
        "output": "0",
        "idx": 5999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
        "output": "1",
        "idx": 3299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "readfile_linenr(\n    linenr_T\tlinecnt,\t/* line count before reading more bytes */\n    char_u\t*p,\t\t/* start of more bytes read */\n    char_u\t*endp)\t\t/* end of more bytes read */\n{\n    char_u\t*s;\n    linenr_T\tlnum;\n\n    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;\n    for (s = p; s < endp; ++s)\n\tif (*s == '\\n')\n\t    ++lnum;\n    return lnum;\n}",
        "output": "0",
        "idx": 5300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void CrwMap::decode0x1810(const CiffComponent& ciffComponent,\n                              const CrwMapping*    pCrwMapping,\n                                    Image&         image,\n                                    ByteOrder      byteOrder)\n    {\n        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {\n            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);\n        }\n\n        ExifKey key1(\"Exif.Photo.PixelXDimension\");\n        ULongValue value1;\n        value1.read(ciffComponent.pData(), 4, byteOrder);\n        image.exifData().add(key1, &value1);\n\n        ExifKey key2(\"Exif.Photo.PixelYDimension\");\n        ULongValue value2;\n        value2.read(ciffComponent.pData() + 4, 4, byteOrder);\n        image.exifData().add(key2, &value2);\n\n        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);\n        uint16_t o = RotationMap::orientation(r);\n        image.exifData()[\"Exif.Image.Orientation\"] = o;\n\n    } // CrwMap::decode0x1810",
        "output": "0",
        "idx": 6118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReturnCode_t DataReaderImpl::get_liveliness_changed_status(\n        LivelinessChangedStatus& status)\n{\n    if (reader_ == nullptr)\n    {\n        return ReturnCode_t::RETCODE_NOT_ENABLED;\n    }\n\n    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());\n\n    status = liveliness_changed_status_;\n    liveliness_changed_status_.alive_count_change = 0u;\n    liveliness_changed_status_.not_alive_count_change = 0u;\n\n    return ReturnCode_t::RETCODE_OK;\n}",
        "output": "0",
        "idx": 3697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void io_req_free_batch_finish(struct io_ring_ctx *ctx,\n\t\t\t\t     struct req_batch *rb)\n{\n\tif (rb->to_free)\n\t\t__io_req_free_batch_flush(ctx, rb);\n\tif (rb->task) {\n\t\tput_task_struct_many(rb->task, rb->task_refs);\n\t\trb->task = NULL;\n\t}\n}",
        "output": "1",
        "idx": 1550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}",
        "output": "1",
        "idx": 241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n",
        "output": "1",
        "idx": 5897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc(reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}",
        "output": "1",
        "idx": 3969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
        "output": "1",
        "idx": 4795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n",
        "output": "1",
        "idx": 5267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(\n    const std::vector<BSONObj>& serializedPipe) {\n    LOGV2_DEBUG(23869,\n                1,\n                \"$unionWith attaching cursor to pipeline {pipeline}\",\n                \"pipeline\"_attr = serializedPipe);\n}",
        "output": "0",
        "idx": 3394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n",
        "output": "1",
        "idx": 3510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned portnum;\n\tint rc;\n\n\tif (get_user(portnum, (unsigned __user *) arg))\n\t\treturn -EFAULT;\n\trc = usb_hub_claim_port(ps->dev, portnum, ps);\n\tif (rc == 0)\n\t\tsnoop(&ps->dev->dev, \"port %d claimed by process %d: %s\\n\",\n\t\t\tportnum, task_pid_nr(current), current->comm);\n\treturn rc;\n}",
        "output": "0",
        "idx": 3724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 old_spte;\n\tu64 *sptep = NULL;\n\n\tfor_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {\n\t\tsptep = iterator.sptep;\n\t\t*spte = old_spte;\n\t}\n\n\treturn sptep;\n}",
        "output": "0",
        "idx": 3639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n') {\n\n            qstring_append_chr(mon->outbuf, '\\r');\n\n        }\n\n        qstring_append_chr(mon->outbuf, c);\n\n        if (c == '\\n') {\n\n            monitor_flush(mon);\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,\n\n                                    int alpha, int beta, int8_t *tc)\n\n{\n\n    uint8_t bs0 = 1;\n\n    uint8_t bs1 = 1;\n\n    uint8_t bs2 = 1;\n\n    uint8_t bs3 = 1;\n\n\n\n    if (tc[0] < 0)\n\n        bs0 = 0;\n\n    if (tc[1] < 0)\n\n        bs1 = 0;\n\n    if (tc[2] < 0)\n\n        bs2 = 0;\n\n    if (tc[3] < 0)\n\n        bs3 = 0;\n\n\n\n    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,\n\n                                               bs0, bs1, bs2, bs3,\n\n                                               tc[0], tc[1], tc[2], tc[3],\n\n                                               alpha, beta,\n\n                                               img_width);\n\n}\n",
        "output": "0",
        "idx": 551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "reallocarray (void *ptr,\n\t      size_t nmemb,\n\t      size_t size)\n{\n\tassert (nmemb > 0 && size > 0);\n\tif (SIZE_MAX / nmemb < size) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\treturn realloc (ptr, nmemb * size);\n}",
        "output": "1",
        "idx": 2238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 1501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qmp_output_type_number(Visitor *v, const char *name, double *obj,\n\n                                   Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qfloat_from_double(*obj));\n\n}\n",
        "output": "0",
        "idx": 4287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  // IN: compatibility level; libtpms added\n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    /* case SEED_COMPAT_LEVEL_LAST: */\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}",
        "output": "1",
        "idx": 2509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n",
        "output": "1",
        "idx": 3764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BufferPoolEntry *get_pool(AVBufferPool *pool)\n\n{\n\n    BufferPoolEntry *cur = NULL, *last = NULL;\n\n\n\n    do {\n\n        FFSWAP(BufferPoolEntry*, cur, last);\n\n        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);\n\n        if (!cur)\n\n            return NULL;\n\n    } while (cur != last);\n\n\n\n    return cur;\n\n}\n",
        "output": "1",
        "idx": 2298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;\n\tsize_t ret;\n\t\n\tret = BZ2_bzread(self->bz_file, buf, count);\n\n\tif (ret == 0) {\n\t\tstream->eof = 1;\n\t}\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 6006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_retrieve_key(struct nlattr **attrs,\n\t\t\t\tstruct tipc_aead_key **key)\n{\n\tstruct nlattr *attr = attrs[TIPC_NLA_NODE_KEY];\n\n\tif (!attr)\n\t\treturn -ENODATA;\n\n\t*key = (struct tipc_aead_key *)nla_data(attr);\n\tif (nla_len(attr) < tipc_aead_key_size(*key))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 5878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RemoveUnknownSections(void)\r\n{\r\n    int a;\r\n    int Modified = FALSE;\r\n    for (a=0;a<SectionsRead-1;){\r\n        switch(Sections[a].Type){\r\n            case  M_SOF0:\r\n            case  M_SOF1:\r\n            case  M_SOF2:\r\n            case  M_SOF3:\r\n            case  M_SOF5:\r\n            case  M_SOF6:\r\n            case  M_SOF7:\r\n            case  M_SOF9:\r\n            case  M_SOF10:\r\n            case  M_SOF11:\r\n            case  M_SOF13:\r\n            case  M_SOF14:\r\n            case  M_SOF15:\r\n            case  M_SOI:\r\n            case  M_EOI:\r\n            case  M_SOS:\r\n            case  M_JFIF:\r\n            case  M_EXIF:\r\n            case  M_XMP:\r\n            case  M_COM:\r\n            case  M_DQT:\r\n            case  M_DHT:\r\n            case  M_DRI:\r\n            case  M_IPTC:\r\n                // keep.\r\n                a++;\r\n                break;\r\n            default:\r\n                // Unknown.  Delete.\r\n                free (Sections[a].Data);\r\n                // Move succeding sections back by one to close space in array.\r\n                memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));\r\n                SectionsRead -= 1;\r\n                Modified = TRUE;\r\n        }\r\n    }\r\n    return Modified;\r\n}\r",
        "output": "1",
        "idx": 4008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}",
        "output": "0",
        "idx": 994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dtls1_hm_fragment_free(hm_fragment *frag)\n{\n    if (!frag)\n        return;\n    if (frag->msg_header.is_ccs) {\n        EVP_CIPHER_CTX_free(frag->msg_header.\n                            saved_retransmit_state.enc_write_ctx);\n        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);\n    }\n    OPENSSL_free(frag->fragment);\n    OPENSSL_free(frag->reassembly);\n    OPENSSL_free(frag);\n}",
        "output": "0",
        "idx": 1333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "(InitializerContext* const context) try {\n    User* user = new User(UserName(\"__system\", \"local\"));\n\n    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.\n    ActionSet allActions;\n    allActions.addAllActions();\n    PrivilegeVector privileges;\n    RoleGraph::generateUniversalPrivileges(&privileges);\n    user->addPrivileges(privileges);\n\n    if (mongodGlobalParams.whitelistedClusterNetwork) {\n        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;\n\n        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);\n        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));\n        auto restrictionDocument =\n            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));\n\n        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));\n\n        user->setRestrictions(std::move(clusterWhiteList));\n    }\n\n\n    internalSecurity.user = user;\n\n    return Status::OK();\n} catch (...) {",
        "output": "0",
        "idx": 840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n",
        "output": "1",
        "idx": 187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_ascii_printable(unsigned char ch)\n{\n    return ((ch >= 32) && (ch <= 126));\n}",
        "output": "1",
        "idx": 3054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mm_decode_intra(MmContext * s, int half_horiz, int half_vert)\n{\n    int x = 0, y = 0;\n\n    while (bytestream2_get_bytes_left(&s->gb) > 0) {\n        int run_length, color;\n\n        if (y >= s->avctx->height)\n            return 0;\n\n        color = bytestream2_get_byte(&s->gb);\n        if (color & 0x80) {\n            run_length = 1;\n        }else{\n            run_length = (color & 0x7f) + 2;\n            color = bytestream2_get_byte(&s->gb);\n        }\n\n        if (half_horiz)\n            run_length *=2;\n\n        if (run_length > s->avctx->width - x)\n            return AVERROR_INVALIDDATA;\n\n        if (color) {\n            memset(s->frame->data[0] + y*s->frame->linesize[0] + x, color, run_length);\n            if (half_vert)\n                memset(s->frame->data[0] + (y+1)*s->frame->linesize[0] + x, color, run_length);\n        }\n        x+= run_length;\n\n        if (x >= s->avctx->width) {\n            x=0;\n            y += 1 + half_vert;\n        }\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 3001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ConnectionCallbacks& callbacks() override { return callbacks_; }",
        "output": "0",
        "idx": 4900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void compute_frame_duration(int *pnum, int *pden,\n\n                                   AVFormatContext *s, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        *pnum = st->codec.frame_rate_base;\n\n        *pden = st->codec.frame_rate;\n\n        if (pc && pc->repeat_pict) {\n\n            *pden *= 2;\n\n            *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vmxnet3_verify_driver_magic(hwaddr dshmem)\n\n{\n\n    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);\n\n}\n",
        "output": "1",
        "idx": 5508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n\n{\n\n    if (conf.log_to_monitor) {\n\n        if (cap) {\n\n            monitor_printf(default_mon, \"%s: \", cap);\n\n        }\n\n\n\n        monitor_vprintf(default_mon, fmt, ap);\n\n    }\n\n    else {\n\n        if (cap) {\n\n            fprintf (stderr, \"%s: \", cap);\n\n        }\n\n\n\n        vfprintf (stderr, fmt, ap);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static js_Ast *memberexp(js_State *J)\n{\n\tjs_Ast *a;\n\tINCREC();\n\ta = newexp(J);\nloop:\n\tif (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }\n\tif (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }\n\tDECREC();\n\treturn a;\n}",
        "output": "1",
        "idx": 2483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int purge_port(struct usb_serial_port *port, __u16 mask)\n{\n\tint port_number = port->port_number;\n\n\tdev_dbg(&port->dev, \"%s - port %d, mask %x\\n\", __func__, port_number, mask);\n\n\treturn send_cmd(port->serial->dev,\n\t\t\t\t\tUMPC_PURGE_PORT,\n\t\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t\tmask,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0);\n}",
        "output": "0",
        "idx": 2874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "http_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  GTlsCertificateFlags cert_flags;\n  gboolean op_res;\n  gboolean using_https;\n\n  error = NULL;\n  op_res = FALSE;\n\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  if (!data->accept_ssl_errors)\n    {\n      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);\n      if (using_https && cert_flags != 0)\n        {\n          goa_utils_set_error_ssl (&error, cert_flags);\n          goto out;\n        }\n    }\n\n  op_res = TRUE;\n\n out:\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  http_client_check_data_free (data);\n}",
        "output": "0",
        "idx": 986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PS_CREATE_SID_FUNC(mm)\n{\n\tchar *sid;\n\tint maxfail = 3;\n\tPS_MM_DATA;\n\n\tdo {\n\t\tsid = php_session_create_id((void **)&data, newlen TSRMLS_CC);\n\t\t/* Check collision */\n\t\tif (ps_mm_key_exists(data, sid TSRMLS_CC) == SUCCESS) {\n\t\t\tif (sid) {\n\t\t\t\tefree(sid);\n\t\t\t\tsid = NULL;\n\t\t\t}\n\t\t\tif (!(maxfail--)) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} while(!sid);\n\n\treturn sid;\n}",
        "output": "0",
        "idx": 5544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_public_ int sd_bus_default(sd_bus **ret) {\n        int (*bus_open)(sd_bus **) = NULL;\n        sd_bus **busp;\n\n        busp = bus_choose_default(&bus_open);\n        return bus_default(bus_open, busp, ret);\n}",
        "output": "0",
        "idx": 4858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct mm_struct *dup_mm(struct task_struct *tsk,\n\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\tif (!mm_init(mm, tsk, mm->user_ns))\n\t\tgoto fail_nomem;\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmm_init_owner(mm, NULL);\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n}",
        "output": "0",
        "idx": 842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   Move specified message to a mailbox */\nPHP_FUNCTION(imap_mail_move)\n{\n\tzval *streamind;\n\tzend_string *seq, *folder;\n\tzend_long options = 0;\n\tpils *imap_le_struct;\n\tint argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc, \"rSS|l\", &streamind, &seq, &folder, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}",
        "output": "0",
        "idx": 4524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\n\t/*\n\t * We set the bdi here to the queue backing, file systems can\n\t * overwrite this in ->fill_super()\n\t */\n\ts->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;\n\treturn 0;\n}",
        "output": "0",
        "idx": 5238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int swf_write_trailer(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int file_size, i;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = &s->streams[i]->codec;\n\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    put_swf_tag(s, TAG_END);\n\n    put_swf_end_tag(s);\n\n    \n\n    put_flush_packet(&s->pb);\n\n\n\n    /* patch file size and number of frames if not streamed */\n\n    if (!url_is_streamed(&s->pb) && video_enc) {\n\n        file_size = url_ftell(pb);\n\n        url_fseek(pb, 4, SEEK_SET);\n\n        put_le32(pb, file_size);\n\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n\n        put_le16(pb, video_enc->frame_number);\n\n    }\n\n    av_free(swf);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_urlhandle(struct Curl_URL *u)\n{\n  free(u->scheme);\n  free(u->user);\n  free(u->password);\n  free(u->options);\n  free(u->host);\n  free(u->zoneid);\n  free(u->port);\n  free(u->path);\n  free(u->query);\n  free(u->fragment);\n  free(u->scratch);\n  free(u->temppath);\n}",
        "output": "0",
        "idx": 6300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_raw_ping(struct query *q, int dns_fd, int userid)\n{\n\tif (check_user_and_ip(userid, q) != 0) {\n\t\treturn;\n\t}\n\n\t/* Update query and time info for user */\n\tusers[userid].last_pkt = time(NULL);\n\tmemcpy(&(users[userid].q), q, sizeof(struct query));\n\n\tif (debug >= 1) {\n\t\tfprintf(stderr, \"IN   ping raw, from user %d\\n\", userid);\n\t}\n\n\t/* Send ping reply */\n\tsend_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);\n}",
        "output": "1",
        "idx": 133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMA_SESSION_Unmarshal(TPMA_SESSION *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT8_Unmarshal((UINT8 *)target, buffer, size);  /* libtpms changed */\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (*target & TPMA_SESSION_reserved) {\n\t    rc = TPM_RC_RESERVED_BITS;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 3624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n",
        "output": "1",
        "idx": 891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "p2i(UINT8 *out_, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, out_ += 4) {\n        INT32 v = L(&palette[in[x] * 4]) / 1000;\n        memcpy(out_, &v, sizeof(v));\n    }\n}",
        "output": "0",
        "idx": 3631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "send_msg(\n\n    VSCMsgType type,\n\n    uint32_t reader_id,\n\n    const void *msg,\n\n    unsigned int length\n\n) {\n\n    VSCMsgHeader mhHeader;\n\n\n\n    qemu_mutex_lock(&socket_to_send_lock);\n\n\n\n    if (verbose > 10) {\n\n        printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\",\n\n               type, reader_id, length, length);\n\n    }\n\n\n\n    mhHeader.type = htonl(type);\n\n    mhHeader.reader_id = 0;\n\n    mhHeader.length = htonl(length);\n\n    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));\n\n    g_byte_array_append(socket_to_send, (guint8 *)msg, length);\n\n    g_idle_add(socket_prepare_sending, NULL);\n\n\n\n    qemu_mutex_unlock(&socket_to_send_lock);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n",
        "output": "1",
        "idx": 4279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n",
        "output": "0",
        "idx": 4616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,\n        word32 value)\n{\n    if (buffer != NULL) {\n        c32toa(value, buffer->data + buffer->idx);\n        buffer->idx += UINT32_SZ;\n    }\n}",
        "output": "0",
        "idx": 2506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int lgff_init(struct hid_device* hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff_joystick;\n\tint error;\n\tint i;\n\n\t/* Check that the report looks ok */\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(devices); i++) {\n\t\tif (dev->id.vendor == devices[i].idVendor &&\n\t\t    dev->id.product == devices[i].idProduct) {\n\t\t\tff_bits = devices[i].ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\n\terror = input_ff_create_memless(dev, NULL, hid_lgff_play);\n\tif (error)\n\t\treturn error;\n\n\tif ( test_bit(FF_AUTOCENTER, dev->ffbit) )\n\t\tdev->ff->set_autocenter = hid_lgff_set_autocenter;\n\n\tpr_info(\"Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\\n\");\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}",
        "output": "1",
        "idx": 2467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */\n  /* Always catch error here. */\n  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);\n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}",
        "output": "1",
        "idx": 4532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)\n{\n  args->ident = NULL;\n#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)\n  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))\n\treturn false;\n#else\n  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);\n  if (args->ident == NULL)\n\treturn false;\n#endif\n\n  if (pident)\n\t*pident = args->ident;\n  return true;\n}",
        "output": "0",
        "idx": 3961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (addr != 2 || size != 1) {\n\n        return ((uint64_t)1 << (size * 8)) - 1;\n\n    }\n\n    return ide_status_read(cmd646bar->bus, addr + 2);\n\n}\n",
        "output": "0",
        "idx": 583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pn533_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct pn533_usb_phy *phy = usb_get_intfdata(interface);\n\n\tif (!phy)\n\t\treturn;\n\n\tpn533_unregister_device(phy->priv);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tusb_kill_urb(phy->in_urb);\n\tusb_kill_urb(phy->out_urb);\n\tusb_kill_urb(phy->ack_urb);\n\n\tkfree(phy->in_urb->transfer_buffer);\n\tusb_free_urb(phy->in_urb);\n\tusb_free_urb(phy->out_urb);\n\tusb_free_urb(phy->ack_urb);\n\tkfree(phy->ack_buffer);\n\n\tnfc_info(&interface->dev, \"NXP PN533 NFC device disconnected\\n\");\n}",
        "output": "0",
        "idx": 6083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n",
        "output": "0",
        "idx": 3312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct list_head *get_event_list(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\treturn event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;\n}",
        "output": "0",
        "idx": 1054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void print_version(void)\n{\n  printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",my_progname,MTEST_VERSION,\n\t MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);\n}",
        "output": "0",
        "idx": 4602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */",
        "output": "1",
        "idx": 4502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&speakup_tty_mutex);\n\tif (speakup_tty) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -EBUSY;\n\t}\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data) {\n\t\tspeakup_tty = NULL;\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\tmutex_unlock(&speakup_tty_mutex);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 6320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void curl_multi_do(void *arg)\n\n{\n\n    BDRVCURLState *s = (BDRVCURLState *)arg;\n\n    int running;\n\n    int r;\n\n\n\n    if (!s->multi) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        r = curl_multi_socket_all(s->multi, &running);\n\n    } while(r == CURLM_CALL_MULTI_PERFORM);\n\n\n\n    curl_multi_read(s);\n\n}\n",
        "output": "0",
        "idx": 5162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmd_starttls_next(struct smtp_server_cmd_ctx *cmd, void *context ATTR_UNUSED)\n{\n\tstruct smtp_server_connection *conn = cmd->conn;\n\tstruct smtp_server_command *command = cmd->cmd;\n\tconst struct smtp_server_callbacks *callbacks = conn->callbacks;\n\tint ret;\n\n\tsmtp_server_connection_set_state(conn, SMTP_SERVER_STATE_STARTTLS,\n\t\t\t\t\t NULL);\n\n\tsmtp_server_command_ref(command);\n\tif (callbacks != NULL && callbacks->conn_cmd_starttls != NULL)\n\t\tret = callbacks->conn_cmd_starttls(conn->context, cmd);\n\telse\n\t\tret = 1;\n\n\tsmtp_server_command_add_hook(command, SMTP_SERVER_COMMAND_HOOK_DESTROY,\n\t\t\t\t     cmd_starttls_destroy, NULL);\n\n\tif (ret <= 0) {\n\t\ti_assert(ret == 0 || smtp_server_command_is_replied(command));\n\t\t/* command is waiting for external event or it failed */\n\t\tsmtp_server_command_unref(&command);\n\t\treturn;\n\t}\n\tif (!smtp_server_command_is_replied(command)) {\n\t\tsmtp_server_reply(cmd,\n\t\t\t220, \"2.0.0\", \"Begin TLS negotiation now.\");\n\t}\n\tsmtp_server_command_unref(&command);\n}",
        "output": "1",
        "idx": 1142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n",
        "output": "1",
        "idx": 5983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)\n{\n\tif (unlikely(len != 16))\n\t\tabort();\n\tumac128_set_key(ctx, key);\n}",
        "output": "0",
        "idx": 973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\n\tcp = (const u_char *)ext;\n\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\n\t\tif (cp == NULL) {\n\t\t\t/* Zero-length subitem */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BlockJob *find_block_job(const char *device, AioContext **aio_context,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    *aio_context = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        goto notfound;\n\n    }\n\n\n\n    *aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(*aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        goto notfound;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs->job) {\n\n        goto notfound;\n\n    }\n\n\n\n    return bs->job;\n\n\n\nnotfound:\n\n    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n\n              \"No active block job on device '%s'\", device);\n\n    if (*aio_context) {\n\n        aio_context_release(*aio_context);\n\n        *aio_context = NULL;\n\n    }\n\n    return NULL;\n\n}\n",
        "output": "0",
        "idx": 2077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info->si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
        "output": "1",
        "idx": 528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n\n        return CR_OK;\n}",
        "output": "1",
        "idx": 2595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool JOIN_TAB::hash_join_is_possible()\n{\n  if (type != JT_REF && type != JT_EQ_REF)\n    return FALSE;\n  if (!is_ref_for_hash_join())\n  {\n    KEY *keyinfo= table->key_info + ref.key;\n    return keyinfo->key_part[0].field->hash_join_is_possible();\n  }\n  return TRUE;\n}",
        "output": "0",
        "idx": 2242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    ushort getPort() const { return port; }",
        "output": "1",
        "idx": 5899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n",
        "output": "0",
        "idx": 4115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int is_inside_work_tree(void)\n{\n\tif (inside_work_tree < 0)\n\t\tinside_work_tree = is_inside_dir(get_git_work_tree());\n\treturn inside_work_tree;\n}",
        "output": "0",
        "idx": 1117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n",
        "output": "0",
        "idx": 3647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    const unsigned char *p = buf;\n    unsigned char *der = NULL;\n\n    X509 *x509 = d2i_X509(NULL, &p, len);\n    if (x509 != NULL) {\n        BIO *bio = BIO_new(BIO_s_null());\n        /* This will load and print the public key as well as extensions */\n        X509_print(bio, x509);\n        BIO_free(bio);\n\n        i2d_X509(x509, &der);\n        OPENSSL_free(der);\n\n        X509_free(x509);\n    }\n    ERR_clear_error();\n    return 0;\n}",
        "output": "1",
        "idx": 543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dp_packet_hwol_set_csum_sctp(struct dp_packet *b)\n{\n    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;\n}",
        "output": "0",
        "idx": 321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n",
        "output": "1",
        "idx": 3420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(oci_lob_load)\n{\n\tzval **tmp, *z_descriptor = getThis();\n\tphp_oci_descriptor *descriptor;\n\tchar *buffer = NULL;\n\tub4 buffer_len;\n\n\tif (!getThis()) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O\", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {\n\t\t\treturn;\n\t\t}\t\n\t}\n\t\n\tif (zend_hash_find(Z_OBJPROP_P(z_descriptor), \"descriptor\", sizeof(\"descriptor\"), (void **)&tmp) == FAILURE) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to find descriptor property\");\n\t\tRETURN_FALSE;\n\t}\n\t\n\tPHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);\n\n\tif (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (buffer_len > 0) {\n\t\tRETURN_STRINGL(buffer, buffer_len, 0);\n\t}\n\telse {\n\t\tRETURN_EMPTY_STRING();\n\t}\n}",
        "output": "1",
        "idx": 5493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)\n\n{\n\n    int i;\n\n    for(i=0; i<4 && tags[i]; i++){\n\n        enum CodecID id= codec_get_id(tags[i], tag);\n\n        if(id!=CODEC_ID_NONE) return id;\n\n    }\n\n    return CODEC_ID_NONE;\n\n}\n",
        "output": "0",
        "idx": 5758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n",
        "output": "1",
        "idx": 3681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Crypto::get_random_values(JSContext *cx, unsigned argc, JS::Value *vp) {\n  JS::CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx, \"crypto.getRandomValues\", 1))\n    return false;\n\n  if (!args[0].isObject() || !is_int_typed_array(&args[0].toObject())) {\n    JS_ReportErrorUTF8(cx, \"crypto.getRandomValues: input must be an integer-typed TypedArray\");\n    return false;\n  }\n\n  JS::RootedObject typed_array(cx, &args[0].toObject());\n  size_t byte_length = JS_GetArrayBufferViewByteLength(typed_array);\n  if (byte_length > MAX_BYTE_LENGTH) {\n    JS_ReportErrorUTF8(cx,\n                       \"crypto.getRandomValues: input byteLength must be at most %u, \"\n                       \"but is %zu\",\n                       MAX_BYTE_LENGTH, byte_length);\n    return false;\n  }\n\n  JS::AutoCheckCannotGC noGC(cx);\n  bool is_shared;\n  void *buffer = JS_GetArrayBufferViewData(typed_array, &is_shared, noGC);\n  arc4random_buf(buffer, byte_length);\n\n  args.rval().setObject(*typed_array);\n  return true;\n}",
        "output": "1",
        "idx": 3080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",
        "output": "1",
        "idx": 5647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {\n\tif(level == 0) {\n\t\tmemcpy(dest, source, len);\n\t\treturn len;\n\t} else if(level == 10) {\n#ifdef HAVE_LZO\n\t\tlzo_uint lzolen = MAXSIZE;\n\t\tlzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);\n\t\treturn lzolen;\n#else\n\t\treturn -1;\n#endif\n\t} else if(level < 10) {\n#ifdef HAVE_ZLIB\n\t\tunsigned long destlen = MAXSIZE;\n\t\tif(compress2(dest, &destlen, source, len, level) == Z_OK)\n\t\t\treturn destlen;\n\t\telse\n#endif\n\t\t\treturn -1;\n\t} else {\n#ifdef HAVE_LZO\n\t\tlzo_uint lzolen = MAXSIZE;\n\t\tlzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);\n\t\treturn lzolen;\n#else\n\t\treturn -1;\n#endif\n\t}\n\t\n\treturn -1;\n}",
        "output": "0",
        "idx": 612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)\n{\n    return s->interrupt_states[lidx].is_asserted;\n}",
        "output": "0",
        "idx": 1164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\t\t\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 2080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n",
        "output": "0",
        "idx": 1702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\n    bool _draw_fill(const int x, const int y, const int z,\n                    const CImg<T>& ref, const float tolerance2) const {\n      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;\n      const unsigned long off = _width*_height*_depth;\n      float diff = 0;\n      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }\n      return diff<=tolerance2;",
        "output": "0",
        "idx": 3477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,\n\n                                         void *logctx, int size)\n\n{\n\n    uint8_t *user_data;\n\n    int e, build, i;\n\n\n\n    if (size < 16 || size >= INT_MAX - 16)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    user_data = av_malloc(16 + size + 1);\n\n    if (!user_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < size + 16; i++)\n\n        user_data[i] = get_bits(gb, 8);\n\n\n\n    user_data[i] = 0;\n\n    e = sscanf(user_data + 16, \"x264 - core %d\", &build);\n\n    if (e == 1 && build > 0)\n\n        h->x264_build = build;\n\n    if (e == 1 && build == 1 && !strncmp(user_data+16, \"x264 - core 0000\", 16))\n\n        h->x264_build = 67;\n\n\n\n    if (strlen(user_data + 16) > 0)\n\n        av_log(logctx, AV_LOG_DEBUG, \"user data:\\\"%s\\\"\\n\", user_data + 16);\n\n\n\n    av_free(user_data);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void str_free(OPENSSL_STRING str)\n{\n    OPENSSL_free(str);\n}",
        "output": "0",
        "idx": 1314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline int cert_req_allowed(SSL *s)\n{\n    /* TLS does not like anon-DH with client cert */\n    if ((s->version > SSL3_VERSION\n         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))\n        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))\n        return 0;\n\n    return 1;\n}",
        "output": "0",
        "idx": 5553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n\n    int i;\n\n    int dc0, dc2;\n\n    pixel4 dc0splat, dc2splat;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    dc0=dc2=0;\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride];\n\n        dc2+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc0splat;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc2splat;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n",
        "output": "1",
        "idx": 1255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_af_queue_close(AudioFrameQueue *afq)\n\n{\n\n    /* remove/free any remaining frames */\n\n    while (afq->frame_queue)\n\n        delete_next_frame(afq);\n\n    memset(afq, 0, sizeof(*afq));\n\n}\n",
        "output": "0",
        "idx": 1934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}",
        "output": "1",
        "idx": 1905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dns_zone_getautomatic(dns_zone_t *zone) {\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\treturn (zone->automatic);\n}",
        "output": "0",
        "idx": 2747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n",
        "output": "1",
        "idx": 626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold void ff_wmv2_common_init(Wmv2Context * w){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);\n\n}\n",
        "output": "1",
        "idx": 5655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline void getri(int &N, float *lapA, int *IPIV, float* WORK, int &LWORK, int &INFO) {\n      sgetri_(&N,lapA,&N,IPIV,WORK,&LWORK,&INFO);\n    }",
        "output": "0",
        "idx": 1523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,\n    std::chrono::milliseconds time) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index, time);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  // Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}",
        "output": "0",
        "idx": 5530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
        "output": "1",
        "idx": 5790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n",
        "output": "1",
        "idx": 3618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n\n                                                 Error **errp)\n\n{\n\n    struct addrinfo ai, *res;\n\n    int rc;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return NULL;\n\n    }\n\n\n\n    if (saddr->host == NULL || saddr->port == NULL) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return NULL;\n\n    }\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, saddr->port, gai_strerror(rc));\n\n        return NULL;\n\n    }\n\n    return res;\n\n}\n",
        "output": "1",
        "idx": 3488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)\n\n{\n\n    InputStream        *ist = s->opaque;\n\n    DXVA2Context       *ctx = ist->hwaccel_ctx;\n\n    int                ret;\n\n\n\n    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_frame_copy_props(ctx->tmp_frame, frame);\n\n    if (ret < 0) {\n\n        av_frame_unref(ctx->tmp_frame);\n\n        return ret;\n\n    }\n\n\n\n    av_frame_unref(frame);\n\n    av_frame_move_ref(frame, ctx->tmp_frame);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  List<Item> &params()\n  {\n    return m_params;\n  }",
        "output": "0",
        "idx": 4134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,\n\t    xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED) {\n    if ((inst->children != NULL) && (comp != NULL)) {\n\txmlNodePtr text = inst->children;\n\txmlNodePtr copy;\n\n\twhile (text != NULL) {\n\t    if ((text->type != XML_TEXT_NODE) &&\n\t         (text->type != XML_CDATA_SECTION_NODE)) {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t\t\t \"xsl:text content problem\\n\");\n\t\tbreak;\n\t    }\n\t    copy = xmlNewDocText(ctxt->output, text->content);\n\t    if (text->type != XML_CDATA_SECTION_NODE) {\n#ifdef WITH_XSLT_DEBUG_PARSING\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"Disable escaping: %s\\n\", text->content);\n#endif\n\t\tcopy->name = xmlStringTextNoenc;\n\t    }\n\t    copy = xsltAddChild(ctxt->insert, copy);\n\t    text = text->next;\n\t}\n    }\n}",
        "output": "0",
        "idx": 2256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n",
        "output": "1",
        "idx": 6134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_close(struct SessionHandle *data)\n{\n  /* Loop through all open connections and kill them one by one */\n  while(-1 != ConnectionKillOne(data));\n\n#ifdef USE_SSLEAY\n  /* Close down all open info open SSL and sessions */\n  Curl_SSL_Close_All(data);\n#endif\n\n  if(data->change.proxy_alloc)\n    free(data->change.proxy);\n  if(data->change.referer_alloc)\n    free(data->change.referer);\n  if(data->change.url_alloc)\n    free(data->change.url);\n\n  if(data->state.headerbuff)\n    free(data->state.headerbuff);\n\n\n  if(data->set.cookiejar)\n    /* we have a \"destination\" for all the cookies to get dumped to */\n    Curl_cookie_output(data->cookies, data->set.cookiejar);\n    \n  Curl_cookie_cleanup(data->cookies);\n\n  /* free the connection cache */\n  free(data->state.connects);\n\n  free(data);\n  return CURLE_OK;\n}",
        "output": "0",
        "idx": 1598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n",
        "output": "0",
        "idx": 2365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "doc_var_value(gqlDoc doc, const char *key) {\n    gqlVar\tvar;\n\n    // look in doc->vars and doc->op->vars\n    if (NULL != doc->op) {\n\tfor (var = doc->op->vars; NULL != var; var = var->next) {\n\t    if (0 == strcmp(key, var->name)) {\n\t\treturn var->value;\n\t    }\n\t}\n    }\n    for (var = doc->vars; NULL != var; var = var->next) {\n\tif (0 == strcmp(key, var->name)) {\n\t    return var->value;\n\t}\n    }\n    return NULL;\n}",
        "output": "0",
        "idx": 1271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void visit(TokenBoundary &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = tok(found_ope);\n  }",
        "output": "0",
        "idx": 3522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  /* possible stack overflow? */\n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}",
        "output": "1",
        "idx": 2900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)\n\n{\n\n    if (err != CUDA_SUCCESS) {\n\n        av_log(avctx, AV_LOG_FATAL, \">> %s - failed with error code 0x%x\\n\", func, err);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n",
        "output": "0",
        "idx": 5226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MYSQL_STMT *open_cursor(const char *query)\n{\n  int rc;\n  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;\n\n  MYSQL_STMT *stmt= mysql_stmt_init(mysql);\n  rc= mysql_stmt_prepare(stmt, query, strlen(query));\n  check_execute(stmt, rc);\n\n  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);\n  return stmt;\n}",
        "output": "0",
        "idx": 139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(Http2CodecImplTest, HeaderNameWithUnderscoreAreRejectedByDefault) {\n  headers_with_underscores_action_ = envoy::config::core::v3::HttpProtocolOptions::REJECT_REQUEST;\n  initialize();\n\n  TestRequestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  request_headers.addCopy(\"bad_header\", \"something\");\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(1);\n  request_encoder_->encodeHeaders(request_headers, false);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.requests_rejected_with_underscores_in_headers\").value());\n}",
        "output": "1",
        "idx": 4014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)\n{\n\tu64 ns = 0;\n\n\tif (task_current(rq, p)) {\n\t\tupdate_rq_clock(rq);\n\t\tns = rq_clock_task(rq) - p->se.exec_start;\n\t\tif ((s64)ns < 0)\n\t\t\tns = 0;\n\t}\n\n\treturn ns;\n}",
        "output": "0",
        "idx": 4282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n\n{\n\n    if ((s->data_count & 0x3) != byte_num) {\n\n        ERRPRINT(\"Non-sequential access to Buffer Data Port register\"\n\n                \"is prohibited\\n\");\n\n        return false;\n\n    }\n\n    return true;\n\n}\n",
        "output": "1",
        "idx": 6239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return -errno;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cn_proc_mcast_ctl(struct cn_msg *msg,\n\t\t\t      struct netlink_skb_parms *nsp)\n{\n\tenum proc_cn_mcast_op *mc_op = NULL;\n\tint err = 0;\n\n\tif (msg->len != sizeof(*mc_op))\n\t\treturn;\n\n\t/* \n\t * Events are reported with respect to the initial pid\n\t * and user namespaces so ignore requestors from\n\t * other namespaces.\n\t */\n\tif ((current_user_ns() != &init_user_ns) ||\n\t    (task_active_pid_ns(current) != &init_pid_ns))\n\t\treturn;\n\n\t/* Can only change if privileged. */\n\tif (!capable(CAP_NET_ADMIN)) {\n\t\terr = EPERM;\n\t\tgoto out;\n\t}\n\n\tmc_op = (enum proc_cn_mcast_op *)msg->data;\n\tswitch (*mc_op) {\n\tcase PROC_CN_MCAST_LISTEN:\n\t\tatomic_inc(&proc_event_num_listeners);\n\t\tbreak;\n\tcase PROC_CN_MCAST_IGNORE:\n\t\tatomic_dec(&proc_event_num_listeners);\n\t\tbreak;\n\tdefault:\n\t\terr = EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tcn_proc_ack(err, msg->seq, msg->ack);\n}",
        "output": "1",
        "idx": 3904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\n\t\t/* Does the mounter have privilege over the pid namespace? */\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!proc_parse_options(options, ns)) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t\t/* User space would break if executables appear on proc */\n\t\tsb->s_iflags |= SB_I_NOEXEC;\n\t}\n\n\treturn dget(sb->s_root);\n}",
        "output": "1",
        "idx": 4512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,4);\n\n                l_src_data+=sizeof(OPJ_INT32);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}",
        "output": "0",
        "idx": 5813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hidp_process_report(struct hidp_session *session,\n\t\t\t\tint type, const u8 *data, int len, int intr)\n{\n\tif (len > HID_MAX_BUFFER_SIZE)\n\t\tlen = HID_MAX_BUFFER_SIZE;\n\n\tmemcpy(session->input_buf, data, len);\n\thid_input_report(session->hid, type, session->input_buf, len, intr);\n}",
        "output": "1",
        "idx": 3417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {\n  TestStruct s;\n  s.a_string_ref() = \"foobarbazstring\";\n\n  testPartialDataHandling<BinarySerializer>(\n      s, 7 /* field & length header */ + s.a_string_ref()->size());\n}",
        "output": "0",
        "idx": 2078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    uint8_t buf[256];\n\n    uint8_t type = value >> 8;\n\n    uint8_t index = value & 0xff;\n\n    int ret = -1;\n\n\n\n    switch(type) {\n\n    case USB_DT_DEVICE:\n\n        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n\n        trace_usb_desc_device(dev->addr, len, ret);\n\n        break;\n\n    case USB_DT_CONFIG:\n\n        if (index < desc->full->bNumConfigurations) {\n\n            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n\n        }\n\n        trace_usb_desc_config(dev->addr, index, len, ret);\n\n        break;\n\n    case USB_DT_STRING:\n\n        ret = usb_desc_string(dev, index, buf, sizeof(buf));\n\n        trace_usb_desc_string(dev->addr, index, len, ret);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,\n\n                dev->addr, type, len);\n\n        break;\n\n    }\n\n\n\n    if (ret > 0) {\n\n        if (ret > len) {\n\n            ret = len;\n\n        }\n\n        memcpy(dest, buf, ret);\n\n    }\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 4302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool isCounterMetricId(uint32_t metric_id) {\n    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;\n  }",
        "output": "0",
        "idx": 2915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)\n\n{\n\n    NetPacket *packet, *next;\n\n\n\n    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {\n\n        if (packet->sender == from) {\n\n            QTAILQ_REMOVE(&queue->packets, packet, entry);\n\n\n            g_free(packet);\n\n        }\n\n    }\n\n}",
        "output": "1",
        "idx": 1585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const string name() override { return \"options_cors\"; }",
        "output": "0",
        "idx": 4986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bdrv_throttle_write_timer_cb(void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n\n}\n",
        "output": "0",
        "idx": 3140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hmp_cont_cb(void *opaque, int err)\n\n{\n\n    if (!err) {\n\n        qmp_cont(NULL);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};",
        "output": "1",
        "idx": 4695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 2663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}",
        "output": "1",
        "idx": 5992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}",
        "output": "1",
        "idx": 2470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ulong encode_twos_comp(long n, int prec)\n{\n\tulong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tif (n < 0) {\n\t\tresult = -n;\n\t\tresult = (result ^ 0xffffffffUL) + 1;\n\t\tresult &= (1 << prec) - 1;\n\t} else {\n\t\tresult = n;\n\t}\n\treturn result;\n}",
        "output": "1",
        "idx": 2476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "new_label(codegen_scope *s)\n{\n  return s->lastlabel = s->pc;\n}",
        "output": "0",
        "idx": 6135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void MoveIndexIfNecessary(HValue* index_raw,\n                            HBoundsCheck* insert_before,\n                            HInstruction* end_of_scan_range) {\n    ASSERT(index_raw->IsAdd() || index_raw->IsSub());\n    HBinaryOperation* index =\n        HArithmeticBinaryOperation::cast(index_raw);\n    HValue* left_input = index->left();\n    HValue* right_input = index->right();\n    bool must_move_index = false;\n    bool must_move_left_input = false;\n    bool must_move_right_input = false;\n    for (HInstruction* cursor = end_of_scan_range; cursor != insert_before;) {\n      if (cursor == left_input) must_move_left_input = true;\n      if (cursor == right_input) must_move_right_input = true;\n      if (cursor == index) must_move_index = true;\n      if (cursor->previous() == NULL) {\n        cursor = cursor->block()->dominator()->end();\n      } else {\n        cursor = cursor->previous();\n      }\n    }\n\n    // The BCE algorithm only selects mergeable bounds checks that share\n    // the same \"index_base\", so we'll only ever have to move constants.\n    if (must_move_left_input) {\n      HConstant::cast(left_input)->Unlink();\n      HConstant::cast(left_input)->InsertBefore(index);\n    }\n    if (must_move_right_input) {\n      HConstant::cast(right_input)->Unlink();\n      HConstant::cast(right_input)->InsertBefore(index);\n    }\n  }",
        "output": "1",
        "idx": 1191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_flashcfg_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_FLASHCFG_CFGR0:\n\n        s->cfgr0 = value;\n\n        break;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_certs(cert_object_t **certs, int cert_count)\n{\n  int i;\n\n  for (i = 0; i < cert_count; i++) {\n    if (!certs[i]) {\n\tcontinue;\n    }\n    if (certs[i]->x509 != NULL)\n      X509_free(certs[i]->x509);\n    if (certs[i]->id != NULL)\n      free(certs[i]->id);\n    free(certs[i]);\n  }\n  free(certs);\n}",
        "output": "0",
        "idx": 2865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n",
        "output": "1",
        "idx": 6321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}",
        "output": "1",
        "idx": 3345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n",
        "output": "1",
        "idx": 5736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n",
        "output": "1",
        "idx": 541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),\n                                                       TRIO_CONST char* string, size_t max,\n                                                       TRIO_CONST char* substring)\n{\n\tsize_t count;\n\tsize_t size;\n\tchar* result = NULL;\n\n\tassert(string);\n\tassert(substring);\n\n\tsize = trio_length(substring);\n\tif (size <= max)\n\t{\n\t\tfor (count = 0; count <= max - size; count++)\n\t\t{\n\t\t\tif (trio_equal_max(substring, size, &string[count]))\n\t\t\t{\n\t\t\t\tresult = (char*)&string[count];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
        "output": "0",
        "idx": 3098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_numa_distance(NumaDistOptions *dist, Error **errp)\n\n{\n\n    uint16_t src = dist->src;\n\n    uint16_t dst = dist->dst;\n\n    uint8_t val = dist->val;\n\n\n\n    if (src >= MAX_NODES || dst >= MAX_NODES) {\n\n        error_setg(errp,\n\n                   \"Invalid node %\" PRIu16\n\n                   \", max possible could be %\" PRIu16,\n\n                   MAX(src, dst), MAX_NODES);\n\n        return;\n\n    }\n\n\n\n    if (!numa_info[src].present || !numa_info[dst].present) {\n\n        error_setg(errp, \"Source/Destination NUMA node is missing. \"\n\n                   \"Please use '-numa node' option to declare it first.\");\n\n        return;\n\n    }\n\n\n\n    if (val < NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \"\n\n                   \"it shouldn't be less than %d.\",\n\n                   val, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    if (src == dst && val != NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"Local distance of node %d should be %d.\",\n\n                   src, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    numa_info[src].distance[dst] = val;\n\n    have_numa_distance = true;\n\n}\n",
        "output": "0",
        "idx": 3219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n",
        "output": "1",
        "idx": 4985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void WillReleaseScriptContext(v8::Local<v8::Context> context,\n                                int32_t world_id) override {\n    if (weak_context_.IsEmpty() ||\n        weak_context_.Get(context->GetIsolate()) == context)\n      electron_browser_remote_.reset();\n  }",
        "output": "1",
        "idx": 827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t estimate_size(const std::vector<RE*> &res)\n{\n    std::vector<StackItem> stack;\n\n    const size_t nre = res.size();\n    DASSERT(nre > 0);\n    size_t size = nre - 1;\n\n    for (size_t i = 0; i < nre; ++i) {\n        size += estimate_re_size(res[i], stack) + 1;\n    }\n\n    return size;\n}",
        "output": "1",
        "idx": 3058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_ALG_SYM_OBJECT_Unmarshal(TPMI_ALG_SYM_OBJECT *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_AES\n\t  case TPM_ALG_AES:\n#endif\n#if ALG_SM4\n\t  case TPM_ALG_SM4:\t\t\n#endif\n#if ALG_CAMELLIA\n\t  case TPM_ALG_CAMELLIA:\t\n#endif\n#if ALG_TDES\t\t// libtpms added begin\n          case TPM_ALG_TDES:\n#endif\t\t\t// iibtpms added end\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_SYMMETRIC;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n",
        "output": "0",
        "idx": 4139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avpriv_lock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}",
        "output": "1",
        "idx": 147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SOCK_DEBUG(struct sock *sk, const char *msg, ...)\n{\n}",
        "output": "0",
        "idx": 4503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_operatorfunc_option(void)\n{\n    return option_set_callback_func(p_opfunc, &opfunc_cb);\n}",
        "output": "0",
        "idx": 4621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}",
        "output": "0",
        "idx": 5432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n",
        "output": "1",
        "idx": 260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *ad_get_entry(const struct adouble *ad, int eid)\n{\n\toff_t off = ad_getentryoff(ad, eid);\n\tsize_t len = ad_getentrylen(ad, eid);\n\n\tif (off == 0 || len == 0) {\n\t\treturn NULL;\n\t}\n\n\treturn ad->ad_data + off;\n}",
        "output": "1",
        "idx": 2460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int pam_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,\n\t\t    uint32_t page_flags)\n{\n\tstruct ttm_tt *ttm = &ttm_dma->ttm;\n\n\tttm_tt_init_fields(ttm, bo, page_flags);\n\n\tINIT_LIST_HEAD(&ttm_dma->pages_list);\n\tif (ttm_dma_tt_alloc_page_directory(ttm_dma)) {\n\t\tttm_tt_destroy(ttm);\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 4892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gem_context_register(struct i915_gem_context *ctx,\n\t\t\t\tstruct drm_i915_file_private *fpriv)\n{\n\tint ret;\n\n\tctx->file_priv = fpriv;\n\tif (ctx->ppgtt)\n\t\tctx->ppgtt->vm.file = fpriv;\n\n\tctx->pid = get_task_pid(current, PIDTYPE_PID);\n\tctx->name = kasprintf(GFP_KERNEL, \"%s[%d]\",\n\t\t\t      current->comm, pid_nr(ctx->pid));\n\tif (!ctx->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pid;\n\t}\n\n\t/* And finally expose ourselves to userspace via the idr */\n\tret = idr_alloc(&fpriv->context_idr, ctx,\n\t\t\tDEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_name;\n\n\tctx->user_handle = ret;\n\n\treturn 0;\n\nerr_name:\n\tkfree(fetch_and_zero(&ctx->name));\nerr_pid:\n\tput_pid(fetch_and_zero(&ctx->pid));\n\treturn ret;\n}",
        "output": "1",
        "idx": 5116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(16);\n        WRITE32(OP_GETATTR);\n        WRITE32(2);\n        WRITE32(bm0);\n        WRITE32(bm1);\n        return 0;\n}",
        "output": "0",
        "idx": 6194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n",
        "output": "0",
        "idx": 4168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WRITE_JSON_ELEMENT(ObjStart) {\n    /* increase depth, save: before first key-value no comma needed. */\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '{');\n}",
        "output": "1",
        "idx": 4459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}",
        "output": "1",
        "idx": 2619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_buffer_clear( HB_Buffer buffer )\n{\n  buffer->in_length = 0;\n  buffer->out_length = 0;\n  buffer->in_pos = 0;\n  buffer->out_pos = 0;\n  buffer->out_string = buffer->in_string;\n  buffer->separate_out = FALSE;\n  buffer->max_ligID = 0;\n}",
        "output": "1",
        "idx": 2697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_asf_demux_get_stream_audio (asf_stream_audio * audio, guint8 ** p_data,\n    guint64 * p_size)\n{\n  if (*p_size < (2 + 2 + 4 + 4 + 2 + 2 + 2))\n    return FALSE;\n\n  /* WAVEFORMATEX Structure */\n  audio->codec_tag = gst_asf_demux_get_uint16 (p_data, p_size);\n  audio->channels = gst_asf_demux_get_uint16 (p_data, p_size);\n  audio->sample_rate = gst_asf_demux_get_uint32 (p_data, p_size);\n  audio->byte_rate = gst_asf_demux_get_uint32 (p_data, p_size);\n  audio->block_align = gst_asf_demux_get_uint16 (p_data, p_size);\n  audio->word_size = gst_asf_demux_get_uint16 (p_data, p_size);\n  /* Codec specific data size */\n  audio->size = gst_asf_demux_get_uint16 (p_data, p_size);\n  if (audio->size > *p_size) {\n    GST_WARNING (\"Corrupted audio codec_data (should be at least %u bytes, is %\"\n        G_GUINT64_FORMAT \" long)\", audio->size, *p_size);\n    return FALSE;\n  }\n  return TRUE;\n}",
        "output": "0",
        "idx": 6132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int init(AVFilterContext *ctx, const char *args)\n\n{\n\n    GradFunContext *gf = ctx->priv;\n\n    float thresh = 1.2;\n\n    int radius = 16;\n\n\n\n    if (args)\n\n        sscanf(args, \"%f:%d\", &thresh, &radius);\n\n\n\n    thresh = av_clipf(thresh, 0.51, 255);\n\n    gf->thresh = (1 << 15) / thresh;\n\n    gf->radius = av_clip((radius + 1) & ~1, 4, 32);\n\n\n\n    gf->blur_line = ff_gradfun_blur_line_c;\n\n    gf->filter_line = ff_gradfun_filter_line_c;\n\n\n\n    if (ARCH_X86)\n\n        ff_gradfun_init_x86(gf);\n\n\n\n    av_log(ctx, AV_LOG_VERBOSE, \"threshold:%.2f radius:%d\\n\", thresh, gf->radius);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n",
        "output": "1",
        "idx": 1837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_vmx_instruction(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}",
        "output": "0",
        "idx": 2407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_re(void)\n{\n  /*\n    Filter for queries that can be run using the\n    MySQL Prepared Statements C API\n  */\n  const char *ps_re_str =\n    \"^(\"\n    \"[[:space:]]*REPLACE[[:space:]]|\"\n    \"[[:space:]]*INSERT[[:space:]]|\"\n    \"[[:space:]]*UPDATE[[:space:]]|\"\n    \"[[:space:]]*DELETE[[:space:]]|\"\n    \"[[:space:]]*SELECT[[:space:]]|\"\n    \"[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|\"\n    \"[[:space:]]*DO[[:space:]]|\"\n    \"[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|\"\n    \"[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|\"\n    \"[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|\"\n    \"[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])\";\n\n  /*\n    Filter for queries that can be run using the\n    Stored procedures\n  */\n  const char *sp_re_str =ps_re_str;\n\n  /*\n    Filter for queries that can be run as views\n  */\n  const char *view_re_str =\n    \"^(\"\n    \"[[:space:]]*SELECT[[:space:]])\";\n\n  init_re_comp(&ps_re, ps_re_str);\n  init_re_comp(&sp_re, sp_re_str);\n  init_re_comp(&view_re, view_re_str);\n}",
        "output": "0",
        "idx": 1715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n\t{\n\tif (ctx->cleanup) ctx->cleanup(ctx);\n\tif (ctx->param != NULL)\n\t\t{\n\t\tif (ctx->parent == NULL)\n\t\t\tX509_VERIFY_PARAM_free(ctx->param);\n\t\tctx->param=NULL;\n\t\t}\n\tif (ctx->tree != NULL)\n\t\t{\n\t\tX509_policy_tree_free(ctx->tree);\n\t\tctx->tree=NULL;\n\t\t}\n\tif (ctx->chain != NULL)\n\t\t{\n\t\tsk_X509_pop_free(ctx->chain,X509_free);\n\t\tctx->chain=NULL;\n\t\t}\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\n\tmemset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));\n\t}",
        "output": "0",
        "idx": 4853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline char *tok_text_buf(struct Token *t)\n{\n    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;\n}",
        "output": "0",
        "idx": 741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int is_smm_enabled(void)\n{\n\treturn CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;\n}",
        "output": "0",
        "idx": 4650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n",
        "output": "1",
        "idx": 5266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) ||\n\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n}",
        "output": "1",
        "idx": 3114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 3370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CharDriverState *qemu_chr_open_spice_port(const char *id,\n\n                                                 ChardevBackend *backend,\n\n                                                 ChardevReturn *ret,\n\n                                                 Error **errp)\n\n{\n\n    const char *name = backend->spiceport->fqdn;\n\n    CharDriverState *chr;\n\n    SpiceCharDriver *s;\n\n\n\n    if (name == NULL) {\n\n        fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = chr_open(\"port\", spice_port_set_fe_open);\n\n    s = chr->opaque;\n\n    s->sin.portname = g_strdup(name);\n\n\n\n    return chr;\n\n}\n",
        "output": "0",
        "idx": 2734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  base::WeakPtr<ElectronBrowserHandlerImpl> GetWeakPtr() {\n    return weak_factory_.GetWeakPtr();\n  }",
        "output": "1",
        "idx": 1506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,\n\t\t       const char *base, int baselen)\n{\n\tunsigned mode;\n\tconst char *path;\n\tconst unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);\n\n\tif (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {\n\t\tenum object_type type;\n\t\tint pathlen = tree_entry_len(path, sha1);\n\t\tchar *newbase = malloc_base(base, baselen, path, pathlen);\n\t\tstruct tree_desc inner;\n\t\tvoid *tree;\n\t\tunsigned long size;\n\n\t\ttree = read_sha1_file(sha1, &type, &size);\n\t\tif (!tree || type != OBJ_TREE)\n\t\t\tdie(\"corrupt tree sha %s\", sha1_to_hex(sha1));\n\n\t\tinit_tree_desc(&inner, tree, size);\n\t\tshow_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);\n\n\t\tfree(tree);\n\t\tfree(newbase);\n\t} else {\n\t\topt->add_remove(opt, prefix[0], mode, sha1, base, path);\n\t}\n}",
        "output": "1",
        "idx": 6105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n",
        "output": "1",
        "idx": 5775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n\n  PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}",
        "output": "1",
        "idx": 5744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }",
        "output": "1",
        "idx": 5350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; /* we need to treat the characters unsigned */\n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n\n    if(Curl_isunreserved(in))\n      /* just copy this */\n      ns[strindex++]=in;\n    else {\n      /* encode it */\n      newlen += 2; /* the size grows with two, since this'll become a %XX */\n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        /* Curl_convert_to_network calls failf if unsuccessful */\n        free(ns);\n        return NULL;\n      }\n\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n  return ns;\n}",
        "output": "1",
        "idx": 812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tu16 min_ifinfo_dump_size = 0;\n\tint hdrlen;\n\n\t/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */\n\thdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\n\tif (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tif (!ext_filter_mask)\n\t\treturn NLMSG_GOODSIZE;\n\t/*\n\t * traverse the list of net devices and compute the minimum\n\t * buffer size based upon the filter mask.\n\t */\n\tlist_for_each_entry(dev, &net->dev_base_head, dev_list) {\n\t\tmin_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,\n\t\t\t\t\t     if_nlmsg_size(dev,\n\t\t\t\t\t\t           ext_filter_mask));\n\t}\n\n\treturn min_ifinfo_dump_size;\n}",
        "output": "0",
        "idx": 2276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)\n\n{\n\n    int i;\n\n    int ret = av_frame_ref(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!h->sps.crop)\n\n        return 0;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n\n        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +\n\n            (h->sps.crop_top  >> vshift) * dst->linesize[i];\n\n        dst->data[i] += off;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double ipow( double n, int exp )\n{\n\tdouble r;\n\n\tif ( exp < 0 )\n\t\treturn 1.0 / ipow( n, -exp );\n\tr = 1;\n\twhile ( exp > 0 ) {\n\t\tif ( exp & 1 )\n\t\t\tr *= n;\n\t\texp >>= 1;\n\t\tn *= n;\n\t}\n\treturn r;\n}",
        "output": "1",
        "idx": 4578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)\n\n{\n\n    int i = 0;\n\n    while (ff_id3v2_extra_meta_funcs[i].tag3) {\n\n        if (!memcmp(tag,\n\n                    (isv34 ?\n\n                        ff_id3v2_extra_meta_funcs[i].tag4 :\n\n                        ff_id3v2_extra_meta_funcs[i].tag3),\n\n                    (isv34 ? 4 : 3)))\n\n            return &ff_id3v2_extra_meta_funcs[i];\n\n        i++;\n\n    }\n\n    return NULL;\n\n}\n",
        "output": "1",
        "idx": 5080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bsearchenv(char **env, const char *name, size_t size)\n{\n\tunsigned low = 0, high = size;\n\twhile (low < high) {\n\t\tunsigned mid = low + ((high - low) >> 1);\n\t\tint cmp = compareenv(&env[mid], &name);\n\t\tif (cmp < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (cmp > 0)\n\t\t\thigh = mid;\n\t\telse\n\t\t\treturn mid;\n\t}\n\treturn ~low; /* not found, return 1's complement of insert position */\n}",
        "output": "0",
        "idx": 1659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,\n\n                       int insn, int size, int sign)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_sign;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_sign = tcg_const_i32(sign);\n\n#ifdef TARGET_SPARC64\n\n    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);\n\n#else\n\n    {\n\n        TCGv_i64 t64 = tcg_temp_new_i64();\n\n        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);\n\n        tcg_gen_trunc_i64_tl(dst, t64);\n\n        tcg_temp_free_i64(t64);\n\n    }\n\n#endif\n\n    tcg_temp_free_i32(r_sign);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n",
        "output": "0",
        "idx": 4793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_main_loop_start(void)\n\n{\n\n}\n",
        "output": "1",
        "idx": 5149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)\n{\n        LoadContext* lc = context;\n\n        g_return_val_if_fail(lc != NULL, TRUE);\n\n        /* FIXME this thing needs to report errors if\n         * we have unused image data\n         */\n        \n        gdk_pixbuf_unref(lc->pixbuf);\n        \n        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);\n        g_free(lc);\n\n        return TRUE;\n}",
        "output": "1",
        "idx": 1430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 3314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    TEST(BSONValidate, Basic) {\n        BSONObj x;\n        ASSERT_TRUE( x.valid() );\n        \n        x = BSON( \"x\" << 1 );\n        ASSERT_TRUE( x.valid() );\n    }",
        "output": "1",
        "idx": 388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n",
        "output": "1",
        "idx": 2859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(OverflowArithmetic, SignedAdditionTests) {\n    using T = int64_t;\n    static constexpr auto f = polyAdd;\n    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));\n    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));\n    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));\n    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));\n    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));\n    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));\n    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));\n    ASSERT(test<T>(f, 1, 1, 2));\n    ASSERT(test<T>(f, -1, -1, -2));\n    ASSERT(testOflow<T>(f, kMax<T>, 1));\n    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));\n    ASSERT(testOflow<T>(f, kMin<T>, -1));\n    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));\n}",
        "output": "0",
        "idx": 5458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tbool s;\n\tulong tmp;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tif (sgnd) {\n\t\tval = encode_twos_comp(val, prec);\n\t}\n\tassert(val >= 0);\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 4186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)\n\n{\n\n    av_assert2(p < end);\n\n\n\n    end-=2;\n\n    p++;\n\n    for(;p<end; p+=2){\n\n        if(!*p){\n\n            if     (!p[-1] && p[1]) return p - 1;\n\n            else if(!p[ 1] && p[2]) return p;\n\n        }\n\n    }\n\n    return end+2;\n\n}\n",
        "output": "0",
        "idx": 5421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,\n\t\t\t\t\t    sa_family_t family,\n\t\t\t\t\t    __be16 dst_port)\n{\n\tstruct geneve_sock *gs;\n\n\tlist_for_each_entry(gs, &gn->sock_list, list) {\n\t\tif (inet_sk(gs->sock->sk)->inet_sport == dst_port &&\n\t\t    geneve_get_sk_family(gs) == family) {\n\t\t\treturn gs;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 5213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\t/*base + this + string length*/\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 4856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n",
        "output": "0",
        "idx": 2678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uvc_reset_resume(struct usb_interface *intf)\n{\n\treturn __uvc_resume(intf, 1);\n}",
        "output": "0",
        "idx": 4347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n   initialize_environment();\n\n   test_format_wrong_size();\n   test_blit_info_format_check();\n   test_blit_info_format_check_null_format();\n   test_format_is_plain_nullptr_deref_trigger();\n   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();\n   test_format_util_format_is_rgb_nullptr_deref_trigger();\n   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();\n   test_double_free_in_vrend_renderer_blit_int_trigger();\n   test_format_is_has_alpha_nullptr_deref_trigger_original();\n   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();\n\n   test_heap_overflow_vrend_renderer_transfer_write_iov();\n\n   virgl_renderer_context_destroy(ctx_id);\n   virgl_renderer_cleanup(&cookie);\n   virgl_egl_destroy(test_egl);\n\n   return 0;\n}",
        "output": "1",
        "idx": 3534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "libssh2_poll_channel_read(LIBSSH2_CHANNEL *channel, int extended)\n{\n    LIBSSH2_SESSION *session;\n    LIBSSH2_PACKET *packet;\n\n    if(!channel)\n        return LIBSSH2_ERROR_BAD_USE;\n\n    session = channel->session;\n    packet = _libssh2_list_first(&session->packets);\n\n    while(packet) {\n        if(channel->local.id == _libssh2_ntohu32(packet->data + 1)) {\n            if(extended == 1 &&\n                (packet->data[0] == SSH_MSG_CHANNEL_EXTENDED_DATA\n                 || packet->data[0] == SSH_MSG_CHANNEL_DATA)) {\n                return 1;\n            }\n            else if(extended == 0 &&\n                    packet->data[0] == SSH_MSG_CHANNEL_DATA) {\n                return 1;\n            }\n            /* else - no data of any type is ready to be read */\n        }\n        packet = _libssh2_list_next(&packet->node);\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 4728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2925
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n",
        "output": "1",
        "idx": 539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int dec_move_mr(DisasContext *dc)\n\n{\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tif (memsize == 4) {\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_update_cc_op(dc, CC_OP_MOVE, 4);\n\n\t\tcris_update_cc_x(dc);\n\n\t\tcris_update_result(dc, cpu_R[dc->op2]);\n\n\t}\n\n\telse {\n\n\t\tTCGv t0;\n\n\n\n\t\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, memsize, t0);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);\n\n\t\ttcg_temp_free(t0);\n\n\t}\n\n\tdo_postinc(dc, memsize);\n\n\treturn insn_len;\n\n}\n",
        "output": "0",
        "idx": 4396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void setWriteFlags(folly::WriteFlags flags) {\n    writeFlags = flags;\n  }",
        "output": "0",
        "idx": 578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_evfsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 1827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int net_slirp_init(VLANState *vlan)\n\n{\n\n    if (!slirp_inited) {\n\n        slirp_inited = 1;\n\n        slirp_init();\n\n    }\n\n    slirp_vc = qemu_new_vlan_client(vlan, \n\n                                    slirp_receive, NULL);\n\n    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), \"user redirector\");\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 6061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)\n{\n\tbool do_vunmap = false;\n\tint ret;\n\n\t/*\n\t * cap_info->capsule may have been assigned already by a quirk\n\t * handler, so only overwrite it if it is NULL\n\t */\n\tif (!cap_info->capsule) {\n\t\tcap_info->capsule = vmap(cap_info->pages, cap_info->index,\n\t\t\t\t\t VM_MAP, PAGE_KERNEL);\n\t\tif (!cap_info->capsule)\n\t\t\treturn -ENOMEM;\n\t\tdo_vunmap = true;\n\t}\n\n\tret = efi_capsule_update(cap_info->capsule, cap_info->phys);\n\tif (do_vunmap)\n\t\tvunmap(cap_info->capsule);\n\tif (ret) {\n\t\tpr_err(\"capsule update failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Indicate capsule binary uploading is done */\n\tcap_info->index = NO_FURTHER_WRITE_ACTION;\n\n\tif (cap_info->header.flags & EFI_CAPSULE_PERSIST_ACROSS_RESET) {\n\t\tpr_info(\"Successfully uploaded capsule file with reboot type '%s'\\n\",\n\t\t\t!cap_info->reset_type ? \"RESET_COLD\" :\n\t\t\tcap_info->reset_type == 1 ? \"RESET_WARM\" :\n\t\t\t\"RESET_SHUTDOWN\");\n\t} else {\n\t\tpr_info(\"Successfully processed capsule file\\n\");\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 5480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n\n\n    if (QTAILQ_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset = end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n\n\n    if (offset == RAM_ADDR_MAX) {\n\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n\n                (uint64_t)size);\n\n        abort();\n\n    }\n\n\n\n    return offset;\n\n}\n",
        "output": "0",
        "idx": 3748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Error with file handle size\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }",
        "output": "1",
        "idx": 3109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xen_platform_initfn(PCIDevice *dev)\n\n{\n\n    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = d->pci_dev.config;\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n\n\n    pci_config_set_prog_interface(pci_conf, 0);\n\n\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n\n\n    pci_register_bar(&d->pci_dev, 0, 0x100,\n\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);\n\n\n\n    /* reserve 16MB mmio address for share memory*/\n\n    pci_register_bar(&d->pci_dev, 1, 0x1000000,\n\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);\n\n\n\n    platform_fixed_ioport_init(d);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_min_unmapped_ratio(void)\n{\n\tpg_data_t *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->min_unmapped_pages = 0;\n\n\tfor_each_zone(zone)\n\t\tzone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *\n\t\t\t\tsysctl_min_unmapped_ratio) / 100;\n}",
        "output": "0",
        "idx": 357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dir_globs(long argc, const VALUE *argv, VALUE base, int flags)\n{\n    VALUE ary = rb_ary_new();\n    long i;\n\n    for (i = 0; i < argc; ++i) {\n\tint status;\n\tVALUE str = argv[i];\n\tGlobPathValue(str, TRUE);\n\tstatus = push_glob(ary, str, base, flags);\n\tif (status) GLOB_JUMP_TAG(status);\n    }\n\n    return ary;\n}",
        "output": "1",
        "idx": 1728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n",
        "output": "1",
        "idx": 638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int acpi_smbus_register_callback(struct acpi_smb_hc *hc,\n\t\t\t         smbus_alarm_callback callback, void *context)\n{\n\tmutex_lock(&hc->lock);\n\thc->callback = callback;\n\thc->context = context;\n\tmutex_unlock(&hc->lock);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    } else if (!(sregnames[sr].access & access)) {\n\n        static const char * const access_text[] = {\n\n            [SR_R] = \"rsr\",\n\n            [SR_W] = \"wsr\",\n\n            [SR_X] = \"xsr\",\n\n        };\n\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n\n                access_text[access]);\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n",
        "output": "1",
        "idx": 4983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)\n\n{\n\n    if (!s->started) {\n\n        return;\n\n    }\n\n    s->started = false;\n\n    trace_virtio_blk_data_plane_stop(s);\n\n\n\n    /* Stop thread or cancel pending thread creation BH */\n\n    if (s->start_bh) {\n\n        qemu_bh_delete(s->start_bh);\n\n        s->start_bh = NULL;\n\n    } else {\n\n        event_poll_notify(&s->event_poll);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    ioq_cleanup(&s->ioqueue);\n\n\n\n    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);\n\n\n\n    event_poll_cleanup(&s->event_poll);\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);\n\n\n\n    vring_teardown(&s->vring);\n\n}\n",
        "output": "1",
        "idx": 6237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainResume(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainResume) {\n        int ret;\n        ret = conn->driver->domainResume(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
        "output": "0",
        "idx": 36
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool match_service_by_chrc(const void *a, const void *b)\n{\n\tconst struct external_service *service = a;\n\tconst char *path = b;\n\n\treturn queue_find(service->chrcs, match_chrc, path);\n}",
        "output": "0",
        "idx": 6322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    const int16_t *samples = (const int16_t *)frame->data[0];\n\n    int nb_samples, out_size, ret;\n\n\n\n    out_size = (frame->nb_samples + 1) / 2;\n\n    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))\n\n        return ret;\n\n\n\n    nb_samples = frame->nb_samples - (frame->nb_samples & 1);\n\n\n\n    if (avctx->trellis)\n\n        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);\n\n    else\n\n        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);\n\n\n\n    /* handle last frame with odd frame_size */\n\n    if (nb_samples < frame->nb_samples) {\n\n        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };\n\n        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_header(FILE *fp)\n{\n    long start;\n\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header;\n\n    header = calloc(1, 1024);\n    \n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    \n    return header;\n}",
        "output": "1",
        "idx": 3285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void BroadcastMul(const uint8* input1_data, const Dims<4>& input1_dims,\n                         int32 input1_offset, const uint8* input2_data,\n                         const Dims<4>& input2_dims, int32 input2_offset,\n                         int32 output_offset, int32 output_multiplier,\n                         int output_shift, int32 output_activation_min,\n                         int32 output_activation_max, uint8* output_data,\n                         const Dims<4>& output_dims) {\n  BroadcastMul4DSlow(\n      input1_data, input1_dims, input1_offset, input2_data, input2_dims,\n      input2_offset, output_offset, output_multiplier,\n      //\n      kReverseShift * output_shift,\n      //\n      output_activation_min, output_activation_max, output_data, output_dims);\n}",
        "output": "0",
        "idx": 1694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void Parser::advanceToNextToken() {\n      lex < css_comments >(false);\n      // advance to position\n      pstate += pstate.offset;\n      pstate.offset.column = 0;\n      pstate.offset.line = 0;\n    }",
        "output": "0",
        "idx": 5563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gen_sample_entry_box_size(GF_Box *s)\n{\n\tGF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 1293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEE_Result tee_obj_attr_from_binary(struct tee_obj *o, const void *data,\n\t\t\t\t    size_t data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tif (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,\n\t\t\t\t\t\t\t &offs))\n\t\t\treturn TEE_ERROR_CORRUPT_OBJECT;\n\t}\n\treturn TEE_SUCCESS;\n}",
        "output": "0",
        "idx": 5721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n",
        "output": "0",
        "idx": 220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "date_s_httpdate(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg;\n\n    rb_scan_args(argc, argv, \"02\", &str, &sg);\n\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"Mon, 01 Jan -4712 00:00:00 GMT\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n\n    {\n\tVALUE hash = date_s__httpdate(klass, str);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}",
        "output": "1",
        "idx": 2754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}",
        "output": "1",
        "idx": 2246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,\n                   void* key, WC_RNG* rng)\n{\n    RsaKey*      rsaKey = NULL;\n    DsaKey*      dsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == DSA_TYPE)\n        dsaKey = (DsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,\n                       NULL, 0, ed25519Key, ed448Key);\n}",
        "output": "0",
        "idx": 3515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt i(msg, msg_len, q.bits());\n\n   while(i >= q)\n      i -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }",
        "output": "1",
        "idx": 5557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_read_ulong_buffer (p11_rpc_message *msg,\n                         CK_ULONG_PTR *buffer,\n                         CK_ULONG *n_buffer)\n{\n\tuint32_t length;\n\n\tassert (msg != NULL);\n\tassert (buffer != NULL);\n\tassert (n_buffer != NULL);\n\tassert (msg->input != NULL);\n\n\t/* Check that we're supposed to be reading this at this point */\n\tassert (!msg->signature || p11_rpc_message_verify_part (msg, \"fu\"));\n\n\t/* The number of ulongs there's room for on the other end */\n\tif (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))\n\t\treturn PARSE_ERROR;\n\n\t*n_buffer = length;\n\t*buffer = NULL;\n\n\t/* If set to zero, then they just want the length */\n\tif (length == 0)\n\t\treturn CKR_OK;\n\n\t*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));\n\tif (!*buffer)\n\t\treturn CKR_DEVICE_MEMORY;\n\n\treturn CKR_OK;\n}",
        "output": "1",
        "idx": 2882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *\nhttp_status_str (enum http_status s)\n{\n  switch (s) {\n#define XX(num, name, string) case HTTP_STATUS_##name: return #string;\n    HTTP_STATUS_MAP(XX)\n#undef XX\n    default: return \"<unknown>\";\n  }",
        "output": "0",
        "idx": 744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double filter_filter(double t)\n{\n\t/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */\n\tif(t < 0.0) t = -t;\n\tif(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);\n\treturn(0.0);\n}",
        "output": "0",
        "idx": 773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t type_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\n\tswitch (this_leaf->type) {\n\tcase CACHE_TYPE_DATA:\n\t\treturn sprintf(buf, \"Data\\n\");\n\tcase CACHE_TYPE_INST:\n\t\treturn sprintf(buf, \"Instruction\\n\");\n\tcase CACHE_TYPE_UNIFIED:\n\t\treturn sprintf(buf, \"Unified\\n\");\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "output": "1",
        "idx": 6144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  longlong val_int() { return cached_time.to_longlong(); }",
        "output": "0",
        "idx": 5932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "onig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,\n                                           int slot, OnigType type, OnigValue* val)\n{\n  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,\n                               type, val);\n}",
        "output": "0",
        "idx": 3794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src + stride - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n",
        "output": "0",
        "idx": 436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n",
        "output": "1",
        "idx": 3377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "output_buffer& HandShakeBase::get(output_buffer& out) const\n{\n    return out;\n}",
        "output": "0",
        "idx": 3548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n",
        "output": "1",
        "idx": 1195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void oss_poll_in (HWVoiceIn *hw)\n{\n    OSSVoiceIn *oss = (OSSVoiceIn *) hw;\n\n    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);\n}",
        "output": "0",
        "idx": 790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lsi53c895a_register_devices(void)\n\n{\n\n    type_register_static(&lsi_info);\n\n    type_register_static_alias(&lsi_info, \"lsi\");\n\n}\n",
        "output": "0",
        "idx": 5594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void display_mouse_define(DisplayChangeListener *dcl,\n\n                                 QEMUCursor *c)\n\n{\n\n    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);\n\n\n\n    qemu_mutex_lock(&ssd->lock);\n\n    if (c) {\n\n        cursor_get(c);\n\n    }\n\n    cursor_put(ssd->cursor);\n\n    ssd->cursor = c;\n\n    ssd->hot_x = c->hot_x;\n\n    ssd->hot_y = c->hot_y;\n\n    g_free(ssd->ptr_move);\n\n    ssd->ptr_move = NULL;\n\n    g_free(ssd->ptr_define);\n\n    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);\n\n    qemu_mutex_unlock(&ssd->lock);\n\n}\n",
        "output": "0",
        "idx": 609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n\n                           const uint8_t *sps_pps, uint32_t sps_pps_size,\n\n                           const uint8_t *in,      uint32_t in_size) {\n\n    uint32_t offset = *poutbuf_size;\n\n    uint8_t nal_header_size = offset ? 3 : 4;\n\n\n\n    *poutbuf_size += sps_pps_size+in_size+nal_header_size;\n\n    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n\n    if (sps_pps)\n\n        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n\n    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n\n    if (!offset)\n\n        AV_WB32(*poutbuf+sps_pps_size, 1);\n\n    else {\n\n        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;\n\n        (*poutbuf+offset)[2] = 1;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  // Update the connecting flag before processing the event because we may start a new connection\n  // attempt in initializeUpstreamConnection.\n  bool connecting = connecting_;\n  connecting_ = false;\n\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}",
        "output": "1",
        "idx": 3195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\n\t/* Check the IN_* constants for consistency.  */\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\n\t/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\n\tatomic_inc(&user->inotify_devs);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tatomic_dec(&user->inotify_devs);\nout_free_uid:\n\tfree_uid(user);\n\treturn ret;\n}",
        "output": "1",
        "idx": 3615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,\n\n                                           stride, dst, stride, 16, 0);\n\n}\n",
        "output": "0",
        "idx": 3927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n",
        "output": "0",
        "idx": 3035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,\n\n                             const int16_t **lumSrc, int lumFilterSize,\n\n                             const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                             const int16_t **chrVSrc,\n\n                             int chrFilterSize, const int16_t **alpSrc,\n\n                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                             uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    if (uDest) {\n\n        x86_reg uv_off = c->uv_off;\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n",
        "output": "0",
        "idx": 4698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ins_compl_next_buf(buf_T *buf, int flag)\n{\n    static win_T *wp = NULL;\n\n    if (flag == 'w')\t\t// just windows\n    {\n\tif (buf == curbuf || wp == NULL)  // first call for this flag/expansion\n\t    wp = curwin;\n\twhile ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin\n\t\t&& wp->w_buffer->b_scanned)\n\t    ;\n\tbuf = wp->w_buffer;\n    }\n    else\n\t// 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'\n\t// (unlisted buffers)\n\t// When completing whole lines skip unloaded buffers.\n\twhile ((buf = (buf->b_next != NULL ? buf->b_next : firstbuf)) != curbuf\n\t\t&& ((flag == 'U'\n\t\t\t? buf->b_p_bl\n\t\t\t: (!buf->b_p_bl\n\t\t\t    || (buf->b_ml.ml_mfp == NULL) != (flag == 'u')))\n\t\t    || buf->b_scanned))\n\t    ;\n    return buf;\n}",
        "output": "1",
        "idx": 1854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int negate_init(AVFilterContext *ctx)\n{\n    LutContext *s = ctx->priv;\n    int i;\n\n    av_log(ctx, AV_LOG_DEBUG, \"negate_alpha:%d\\n\", s->negate_alpha);\n\n    for (i = 0; i < 4; i++) {\n        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?\n                                          \"val\" : \"negval\");\n        if (!s->comp_expr_str[i]) {\n            uninit(ctx);\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 4751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_pdu_sns_delete(build_info_t *bi) {\n  nsip_ie_t ies[] = {\n    { NSIP_IE_NSEI, NSIP_IE_PRESENCE_M, NSIP_IE_FORMAT_TLV, 0, 4}, /* CR013 */\n    { 0, NSIP_IE_PRESENCE_M, NSIP_IE_FORMAT_V, 0, 1 }, /* Transaction id */\n    { NSIP_IE_IP_ADDRESS, NSIP_IE_PRESENCE_C, NSIP_IE_FORMAT_TV, 0, 0 }, \n    /* Unknown length */\n    { NSIP_IE_IP4_ELEMENTS, NSIP_IE_PRESENCE_C, NSIP_IE_FORMAT_TLV, 0, 0 },\n    { NSIP_IE_IP6_ELEMENTS, NSIP_IE_PRESENCE_C, NSIP_IE_FORMAT_TLV, 0, 0 },\n  };\n  decode_iei_transaction_id(ies, bi, bi->offset);\n  decode_pdu_general(&ies[1], 3, bi);\n}",
        "output": "0",
        "idx": 2692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_compute_eflags_o(DisasContext *s, TCGv reg)\n\n{\n\n    gen_compute_eflags(s);\n\n    tcg_gen_shri_tl(reg, cpu_cc_src, 11);\n\n    tcg_gen_andi_tl(reg, reg, 1);\n\n}\n",
        "output": "0",
        "idx": 6117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n",
        "output": "1",
        "idx": 949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_method(const char *s)\t/* I - Filename or URL */\n{\n  if (strncmp(s, \"http:\", 5) == 0)\n    return (\"http\");\n  else if (strncmp(s, \"https:\", 6) == 0)\n    return (\"https\");\n  else if (strncmp(s, \"ftp:\", 4) == 0)\n    return (\"ftp\");\n  else if (strncmp(s, \"mailto:\", 7) == 0)\n    return (\"mailto\");\n  else\n    return (NULL);\n}",
        "output": "1",
        "idx": 3699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)\n{\n\tint size = 0;\n\tint innerSize = credssp_sizeof_ts_password_creds(credssp);\n\n\tif (innerSize > Stream_GetRemainingLength(s))\n\t{\n\t\tprintf(\"\\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\\033[0m\");\n\t}\n\n\t/* TSPasswordCreds (SEQUENCE) */\n\n\tsize += ber_write_sequence_tag(s, innerSize);\n\n\t/* [0] domainName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);\n\n\t/* [1] userName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);\n\n\t/* [2] password (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);\n\n\treturn size;\n}",
        "output": "1",
        "idx": 4745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Bigint *\nBalloc(int k)\n{\n    int x;\n    Bigint *rv;\n#ifndef Omit_Private_Memory\n    size_t len;\n#endif\n\n    ACQUIRE_DTOA_LOCK(0);\n    if ((rv = freelist[k]) != 0) {\n        freelist[k] = rv->next;\n    }\n    else {\n        x = 1 << k;\n#ifdef Omit_Private_Memory\n        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));\n#else\n        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)\n                /sizeof(double);\n        if (pmem_next - private_mem + len <= PRIVATE_mem) {\n            rv = (Bigint*)pmem_next;\n            pmem_next += len;\n        }\n        else\n            rv = (Bigint*)MALLOC(len*sizeof(double));\n#endif\n        rv->k = k;\n        rv->maxwds = x;\n    }\n    FREE_DTOA_LOCK(0);\n    rv->sign = rv->wds = 0;\n    return rv;",
        "output": "1",
        "idx": 1101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\t/*\n\t *\tVerify the descriptors and increment the usage count.\n\t */\n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\treturn num;\n}",
        "output": "1",
        "idx": 4972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\tif (conn->mandatory_signing) {\n\t\tsecurity_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\t}\n\n\treturn security_mode;\n}",
        "output": "1",
        "idx": 2801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    CImg<Tfloat> get_resize_object3d() const {\n      return CImg<Tfloat>(*this,false).resize_object3d();\n    }",
        "output": "0",
        "idx": 4200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tnsc_encode_subsampling(context);\n\t}\n}",
        "output": "1",
        "idx": 4709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)\n{\n\treturn LUKS2_hdr_and_areas_size_jobj(hdr->jobj);\n}",
        "output": "0",
        "idx": 4196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    struct tm tm;\n\n\n\n    if (nret != 8) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    qemu_get_timedate(&tm, spapr->rtc_offset);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, tm.tm_year + 1900);\n\n    rtas_st(rets, 2, tm.tm_mon + 1);\n\n    rtas_st(rets, 3, tm.tm_mday);\n\n    rtas_st(rets, 4, tm.tm_hour);\n\n    rtas_st(rets, 5, tm.tm_min);\n\n    rtas_st(rets, 6, tm.tm_sec);\n\n    rtas_st(rets, 7, 0); /* we don't do nanoseconds */\n\n}\n",
        "output": "1",
        "idx": 5973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u16 btmtk_usb_get_crc(struct btmtk_usb_data *data)\n{\n\tint ret = 0;\n\tstruct usb_device *udev = data->udev;\n\tu16 crc, count = 0;\n\n\tBT_DBG(\"%s\\n\", __func__);\n\n\twhile (1) {\n\t\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t\t0x01, DEVICE_VENDOR_REQUEST_IN,\n\t\t\t\t\t0x21, 0x00, data->io_buf, 2,\n\t\t\t\t\tCONTROL_TIMEOUT_JIFFIES);\n\n\t\tif (ret < 0) {\n\t\t\tcrc = 0xFFFF;\n\t\t\tBT_ERR(\"%s error(%d)\\n\", __func__, ret);\n\t\t}\n\n\t\tmemmove(&crc, data->io_buf, 2);\n\n\t\tcrc = le16_to_cpu(crc);\n\n\t\tif (crc != 0xFFFF)\n\t\t\tbreak;\n\n\t\tmdelay(100);\n\n\t\tif (count++ > 100) {\n\t\t\tBT_ERR(\"Query CRC over %d times\\n\", count);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn crc;\n}",
        "output": "0",
        "idx": 5804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void CiffEntry::doAddComponent(UniquePtr /*component*/)\n    {\n        throw Error(kerFunctionNotSupported, \"CiffEntry::add\");\n    }",
        "output": "0",
        "idx": 2048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) /* {{{ */\n{\n\tint hash_len, ret = FAILURE;\n\tchar *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);\n\tif (!hash) {\n\t\treturn ret;\n\t}\n\tret = zend_hash_del(&intern->storage, hash, hash_len);\n\tspl_object_storage_free_hash(intern, hash);\n\t\n\treturn ret;\n} /* }}}*/",
        "output": "1",
        "idx": 2285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}",
        "output": "1",
        "idx": 855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {\n    array->append(obj);\n}",
        "output": "0",
        "idx": 1780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {\n  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};\n  cluster->max_response_headers_count_ = 200;\n  cluster->http2_options_.set_allow_connect(true);\n  cluster->http2_options_.set_allow_metadata(true);\n  cluster->http1_settings_.enable_trailers_ = true;\n  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(\n      cluster, fmt::format(\"tcp://{}:80\", Network::Test::getLoopbackAddressUrlString(version_)))};\n  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,\n                                                  downstream_protocol_);\n}",
        "output": "1",
        "idx": 6245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int visual_object_type;\n\n        skip_bits(gb, 4); /* visual_object_verid */\n        visual_object_type = get_bits(gb, 4);\n        if (visual_object_type != VOT_VIDEO_ID) {\n            avpriv_request_sample(s->avctx, \"VO type %u\", visual_object_type);\n            return AVERROR_PATCHWELCOME;\n        }\n\n        next_start_code_studio(gb);\n        extension_and_user_data(s, gb, 1);\n\n    return 0;\n}",
        "output": "0",
        "idx": 1280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n",
        "output": "0",
        "idx": 2064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Client::noteBodyProductionEnded(BodyPipe::Pointer bp)\n{\n#if USE_ADAPTATION\n    if (adaptedBodySource == bp) {\n        handleAdaptedBodyProductionEnded();\n        return;\n    }\n#endif\n    if (requestBodySource == bp)\n        handleRequestBodyProductionEnded();\n}",
        "output": "0",
        "idx": 5523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,\n                             uint elt_size, client_name_t cname)\n{\n    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;\n    obj_header_t *obj;\n\n#ifdef MEMENTO\n    if (Memento_failThisEvent())\n        return NULL;\n#endif\n\n    obj = alloc_obj(imem, (ulong) num_elements * elt_size,\n                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,\n                    cname);\n\n    if_debug6m('A', mem, \"[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\",\n               alloc_trace_space(imem), client_name_string(cname),\n               (ulong) num_elements * elt_size,\n               num_elements, elt_size, (ulong) obj);\n    return (byte *) obj;\n}",
        "output": "1",
        "idx": 1909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n",
        "output": "1",
        "idx": 5317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n",
        "output": "1",
        "idx": 2119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_lively_task_by_vpid(pid_t vpid)\n{\n\tstruct task_struct *task;\n\tint err;\n\n\trcu_read_lock();\n\tif (!vpid)\n\t\ttask = current;\n\telse\n\t\ttask = find_task_by_vpid(vpid);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\t/* Reuse ptrace permission checks for now. */\n\terr = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto errout;\n\n\treturn task;\nerrout:\n\tput_task_struct(task);\n\treturn ERR_PTR(err);\n\n}",
        "output": "1",
        "idx": 3898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool asn1_read_OID(struct asn1_data *data, TALLOC_CTX *mem_ctx, char **OID)\n{\n\tDATA_BLOB blob;\n\tint len;\n\n\tif (!asn1_start_tag(data, ASN1_OID)) return false;\n\n\tlen = asn1_tag_remaining(data);\n\tif (len < 0) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\n\tblob = data_blob(NULL, len);\n\tif (!blob.data) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\n\tasn1_read(data, blob.data, len);\n\tasn1_end_tag(data);\n\tif (data->has_error) {\n\t\tdata_blob_free(&blob);\n\t\treturn false;\n\t}\n\n\tif (!ber_read_OID_String(mem_ctx, blob, OID)) {\n\t\tdata->has_error = true;\n\t\tdata_blob_free(&blob);\n\t\treturn false;\n\t}\n\n\tdata_blob_free(&blob);\n\treturn true;\n}",
        "output": "1",
        "idx": 2623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }",
        "output": "0",
        "idx": 5675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_group_stop_pending(t);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}",
        "output": "0",
        "idx": 1712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const Plane_map& pm() const { return ptr()->pm_; }",
        "output": "0",
        "idx": 1824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; /* start at the first possible non-padded byte */\n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    /* get only the bit we want */\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
        "output": "1",
        "idx": 2553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)\n{\n    return pthread_self();\n}",
        "output": "0",
        "idx": 250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n",
        "output": "0",
        "idx": 1498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pkey_sm2_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\n{\n    SM2_PKEY_CTX *dctx, *sctx;\n\n    if (!pkey_sm2_init(dst))\n        return 0;\n    sctx = src->data;\n    dctx = dst->data;\n    if (sctx->gen_group != NULL) {\n        dctx->gen_group = EC_GROUP_dup(sctx->gen_group);\n        if (dctx->gen_group == NULL) {\n            pkey_sm2_cleanup(dst);\n            return 0;\n        }\n    }\n    if (sctx->id != NULL) {\n        dctx->id = OPENSSL_malloc(sctx->id_len);\n        if (dctx->id == NULL) {\n            SM2err(SM2_F_PKEY_SM2_COPY, ERR_R_MALLOC_FAILURE);\n            pkey_sm2_cleanup(dst);\n            return 0;\n        }\n        memcpy(dctx->id, sctx->id, sctx->id_len);\n    }\n    dctx->id_len = sctx->id_len;\n    dctx->id_set = sctx->id_set;\n    dctx->md = sctx->md;\n\n    return 1;\n}",
        "output": "0",
        "idx": 16
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_str_locktmp(str)\n    VALUE str;\n{\n    if (FL_TEST(str, STR_TMPLOCK)) {\n\trb_raise(rb_eRuntimeError, \"temporal locking already locked string\");\n    }\n    FL_SET(str, STR_TMPLOCK);\n    return str;\n}",
        "output": "0",
        "idx": 923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}",
        "output": "1",
        "idx": 2691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tb_unreliable(AVCodecContext *c)\n\n{\n\n    if (c->time_base.den >= 101L * c->time_base.num ||\n\n        c->time_base.den <    5L * c->time_base.num ||\n\n        // c->codec_tag == AV_RL32(\"DIVX\") ||\n\n        // c->codec_tag == AV_RL32(\"XVID\") ||\n\n        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n        c->codec_id == AV_CODEC_ID_H264)\n\n        return 1;\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 3637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)\n\n{\n\n    switch(mode){\n\n    case 0: //no shift\n\n        return src[0];\n\n    case 1: // 1/4 shift\n\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n\n    case 2: // 1/2 shift\n\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n\n    case 3: // 3/4 shift\n\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n\n    }\n\n    return 0; //should not occur\n\n}\n",
        "output": "1",
        "idx": 5971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool load_permissions_file(\n        AccessPermissionsHandle& ah,\n        std::string& permissions_file,\n        PermissionsData& permissions,\n        SecurityException& exception)\n{\n    bool returned_value = false;\n\n    BIO* file_mem = load_signed_file(ah->store_, permissions_file, exception);\n\n    if (file_mem != nullptr)\n    {\n        BUF_MEM* ptr = nullptr;\n        BIO_get_mem_ptr(file_mem, &ptr);\n\n        if (ptr != nullptr)\n        {\n            PermissionsParser parser;\n            if ((returned_value = parser.parse_stream(ptr->data, ptr->length)) == true)\n            {\n                parser.swap(permissions);\n            }\n            else\n            {\n                exception = _SecurityException_(std::string(\"Malformed permissions file \") + permissions_file);\n            }\n        }\n        else\n        {\n            exception = _SecurityException_(std::string(\"OpenSSL library cannot retrieve mem ptr from file \")\n                            + permissions_file);\n        }\n\n        BIO_free(file_mem);\n    }\n\n    return returned_value;\n}",
        "output": "0",
        "idx": 830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n\n        if (p->question->n_keys != 1)\n                return 0;\n\n        return dns_resource_key_equal(p->question->keys[0], key);\n}",
        "output": "1",
        "idx": 4862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool samba_private_attr_name(const char *unix_ea_name)\n{\n\tstatic const char * const prohibited_ea_names[] = {\n\t\tSAMBA_POSIX_INHERITANCE_EA_NAME,\n\t\tSAMBA_XATTR_DOS_ATTRIB,\n\t\tSAMBA_XATTR_MARKER,\n\t\tXATTR_NTACL_NAME,\n\t\tNULL\n\t};\n\n\tint i;\n\n\tfor (i = 0; prohibited_ea_names[i]; i++) {\n\t\tif (strequal( prohibited_ea_names[i], unix_ea_name))\n\t\t\treturn true;\n\t}\n\tif (strncasecmp_m(unix_ea_name, SAMBA_XATTR_DOSSTREAM_PREFIX,\n\t\t\tstrlen(SAMBA_XATTR_DOSSTREAM_PREFIX)) == 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "1",
        "idx": 2267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,\n                                              /*group_size*/ c->input(1),\n                                              /*group_key*/ c->input(2),\n                                              /*instance_key*/ c->input(3)),\n                         done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV2 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    // Allocate the output tensor, trying to reuse the input.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }",
        "output": "1",
        "idx": 1594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "S3BootScriptLabelInternal (\r\n  IN        BOOLEAN                        BeforeOrAfter,\r\n  IN OUT    VOID                         **Position OPTIONAL,\r\n  IN        UINT32                         InformationLength,\r\n  IN CONST  CHAR8                          *Information\r\n  )\r\n{\r\n  UINT8                 Length;\r\n  UINT8                 *Script;\r\n  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;\r\n\r\n  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (Length);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  //\r\n  // Build script data\r\n  //\r\n  ScriptInformation.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;\r\n  ScriptInformation.Length     = Length;\r\n\r\n\r\n  ScriptInformation.InformationLength = InformationLength;\r\n\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));\r\n  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);\r\n\r\n}\r",
        "output": "1",
        "idx": 4257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    if (has_capacity() || has_memory_limit()) {\n      // Notify all inserters. The removal of an element\n      // may make memory available for many inserters\n      // to insert new elements\n      full_.notify_all();\n    }\n  }",
        "output": "1",
        "idx": 4958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}",
        "output": "1",
        "idx": 5336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}",
        "output": "1",
        "idx": 4666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long nfs_read_attr_generation_counter(void)\n{\n\treturn atomic_long_read(&nfs_attr_generation_counter);\n}",
        "output": "0",
        "idx": 5551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}",
        "output": "1",
        "idx": 2035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gif_set_get_colormap (GifContext *context)\n{\n\tcontext->global_colormap_size = 0;\n\tcontext->state = GIF_GET_COLORMAP;\n}",
        "output": "0",
        "idx": 1684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gif_set_get_colormap2 (GifContext *context)\n{\n\tcontext->frame_colormap_size = 0;\n\tcontext->state = GIF_GET_COLORMAP2;\n}",
        "output": "0",
        "idx": 1729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tswitch (yych) {\n\t\tcase 'a': goto yy35;\n\t\tdefault: goto yy33;\n\t}",
        "output": "1",
        "idx": 2211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "/* }}} */\n\nstatic void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)\n{\n\tint type;\n\tlong conf;\n\tchar *value;\n\tint value_len;\n\tPspellConfig *config;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ls\", &conf, &value, &value_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPSPELL_FETCH_CONFIG;\n\n\tif (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_check_open_basedir(value TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tpspell_config_replace(config, option, value);\n",
        "output": "1",
        "idx": 4818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t socket_read(int sockfd, void *buff, size_t size)\n\n{\n\n    ssize_t retval, total = 0;\n\n\n\n    while (size) {\n\n        retval = read(sockfd, buff, size);\n\n        if (retval == 0) {\n\n            return -EIO;\n\n        }\n\n        if (retval < 0) {\n\n            if (errno == EINTR) {\n\n                continue;\n\n            }\n\n            return -errno;\n\n        }\n\n        size -= retval;\n\n        buff += retval;\n\n        total += retval;\n\n    }\n\n    return total;\n\n}\n",
        "output": "0",
        "idx": 5126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n",
        "output": "1",
        "idx": 4456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xa_read_packet(AVFormatContext *s,\n                          AVPacket *pkt)\n{\n    MaxisXADemuxContext *xa = s->priv_data;\n    AVStream *st = s->streams[0];\n    AVIOContext *pb = s->pb;\n    unsigned int packet_size;\n    int ret;\n\n    if(xa->sent_bytes > xa->out_size)\n        return AVERROR(EIO);\n    /* 1 byte header and 14 bytes worth of samples * number channels per block */\n    packet_size = 15*st->codec->channels;\n\n    ret = av_get_packet(pb, pkt, packet_size);\n    if(ret < 0)\n        return ret;\n\n    pkt->stream_index = st->index;\n    xa->sent_bytes += packet_size;\n    pkt->duration = 28;\n\n    return ret;\n}",
        "output": "0",
        "idx": 3231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))\n\n{\n\n    const char *p;\n\n    CharDriverState *chr;\n\n    QemuOpts *opts;\n\n    Error *err = NULL;\n\n\n\n    if (strstart(filename, \"chardev:\", &p)) {\n\n        return qemu_chr_find(p);\n\n    }\n\n\n\n    opts = qemu_chr_parse_compat(label, filename);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    chr = qemu_chr_new_from_opts(opts, init, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n    }\n\n    if (chr && qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        monitor_init(chr, MONITOR_USE_READLINE);\n\n    }\n\n    return chr;\n\n}\n",
        "output": "0",
        "idx": 3923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *check_nan_suffix(char *s)\n\n{\n\n    char *start = s;\n\n\n\n    if (*s++ != '(')\n\n        return start;\n\n\n\n    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||\n\n           (*s >= '0' && *s <= '9') ||  *s == '_')\n\n        s++;\n\n\n\n    return *s == ')' ? s + 1 : start;\n\n}\n",
        "output": "0",
        "idx": 5521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 3907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "draw (cairo_t *cr, int width, int height)\n{\n    cairo_set_source_rgb (cr, 0., 0., 0.);\n    cairo_paint (cr);\n\n    cairo_set_source_rgb (cr, 1., 1., 1.);\n    cairo_set_line_width (cr, 1.);\n\n    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);\n    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);\n    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);\n    cairo_set_source (cr, p);\n\n    cairo_move_to (cr, 0.5, -1);\n    for (int i = 0; i < width; i+=3) {\n\tcairo_rel_line_to (cr, 2, 2);\n\tcairo_rel_line_to (cr, 1, -2);\n    }\n\n    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);\n    cairo_stroke (cr);\n\n    cairo_pattern_destroy(p);\n\n    return CAIRO_TEST_SUCCESS;\n}",
        "output": "0",
        "idx": 2009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_update_var_type(regex_t* reg, enum UpdateVarType type)\n{\n  UpdateVarType t = (UpdateVarType )type;\n\n  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);\n  return 0;\n}",
        "output": "0",
        "idx": 3604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fpm_worker_pool_cleanup(int which, void *arg) /* {{{ */\n{\n\tstruct fpm_worker_pool_s *wp, *wp_next;\n\n\tfor (wp = fpm_worker_all_pools; wp; wp = wp_next) {\n\t\twp_next = wp->next;\n\t\tfpm_worker_pool_config_free(wp->config);\n\t\tfpm_children_free(wp->children);\n\t\tif ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {\n\t\t\tfpm_scoreboard_free(wp->scoreboard);\n\t\t}\n\t\tfpm_worker_pool_free(wp);\n\t}\n\tfpm_worker_all_pools = NULL;\n}",
        "output": "1",
        "idx": 2759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ahash_def_finup_finish1(struct ahash_request *req, int err)\n{\n\tif (err)\n\t\tgoto out;\n\n\treq->base.complete = ahash_def_finup_done2;\n\treq->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n\terr = crypto_ahash_reqtfm(req)->final(req);\n\nout:\n\tahash_def_finup_finish2(req, err);\n\treturn err;\n}",
        "output": "1",
        "idx": 3535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tunsigned i;\n\n\tunsigned num_pixels = src_size >> 1;\n\n\t\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n",
        "output": "1",
        "idx": 2687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int amr_nb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 8000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    avctx->frame_size  = 160;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->enc_state = Encoder_Interface_init(s->enc_dtx);\n\n    if (!s->enc_state) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Encoder_Interface_init error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->enc_bitrate = avctx->bit_rate;\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 4434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,\n                                   QEMUTimer *timer, uint32_t delay_ms)\n{\n    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);\n    bool start_timer = QTAILQ_EMPTY(queue);\n\n    item->type = QEMU_INPUT_QUEUE_DELAY;\n    item->delay_ms = delay_ms;\n    item->timer = timer;\n    QTAILQ_INSERT_TAIL(queue, item, node);\n\n    if (start_timer) {\n        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                  + item->delay_ms);\n    }\n}",
        "output": "1",
        "idx": 1410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n",
        "output": "1",
        "idx": 1636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\t\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr TSRMLS_CC);\n\n\tif (!duplicate)\n\t\tefree(header_line);\n\n\treturn r;\n}",
        "output": "1",
        "idx": 4259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(RouterTest, MissingRequiredHeaders) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))\n      .WillOnce(Invoke(\n          [&](Http::ResponseDecoder& decoder,\n              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.removeMethod();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, _))\n      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {\n        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);\n      }));\n  EXPECT_CALL(\n      callbacks_,\n      sendLocalReply(Http::Code::ServiceUnavailable,\n                     testing::Eq(\"missing required header: :method\"), _, _,\n                     \"filter_removed_required_request_headers{missing required header: :method}\"))\n      .WillOnce(testing::InvokeWithoutArgs([] {}));\n  router_.decodeHeaders(headers, true);\n  router_.onDestroy();\n}",
        "output": "1",
        "idx": 2128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "has_server_privilege_name_name(PG_FUNCTION_ARGS)\n{\n\tName\t\tusername = PG_GETARG_NAME(0);\n\ttext\t   *servername = PG_GETARG_TEXT_P(1);\n\ttext\t   *priv_type_text = PG_GETARG_TEXT_P(2);\n\tOid\t\t\troleid;\n\tOid\t\t\tserverid;\n\tAclMode\t\tmode;\n\tAclResult\taclresult;\n\n\troleid = get_role_oid_or_public(NameStr(*username));\n\tserverid = convert_server_name(servername);\n\tmode = convert_server_priv_string(priv_type_text);\n\n\taclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);\n\n\tPG_RETURN_BOOL(aclresult == ACLCHECK_OK);\n}",
        "output": "0",
        "idx": 4738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string GetTempFileName() {\n#if !defined _MSC_VER && !defined __MINGW32__\n  std::string temp_file_name_template_str =\n      std::string(std::getenv(\"TEST_TMPDIR\") ? std::getenv(\"TEST_TMPDIR\") :\n                                               \".\") +\n      \"/libwebm_temp.XXXXXX\";\n  char* temp_file_name_template =\n      new char[temp_file_name_template_str.length() + 1];\n  memset(temp_file_name_template, 0, temp_file_name_template_str.length() + 1);\n  temp_file_name_template_str.copy(temp_file_name_template,\n                                   temp_file_name_template_str.length(), 0);\n  int fd = mkstemp(temp_file_name_template);\n  std::string temp_file_name =\n      (fd != -1) ? std::string(temp_file_name_template) : std::string();\n  delete[] temp_file_name_template;\n  if (fd != -1) {\n    close(fd);\n  }\n  return temp_file_name;\n#else\n  char tmp_file_name[_MAX_PATH];\n#if defined _MSC_VER || defined MINGW_HAS_SECURE_API\n  errno_t err = tmpnam_s(tmp_file_name);\n#else\n  char* fname_pointer = tmpnam(tmp_file_name);\n  int err = (fname_pointer == &tmp_file_name[0]) ? 0 : -1;\n#endif\n  if (err == 0) {\n    return std::string(tmp_file_name);\n  }\n  return std::string();\n#endif\n}",
        "output": "1",
        "idx": 676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~Item()\n  {\n#ifdef EXTRA_DEBUG\n    name=0;\n#endif\n  }\t\t/*lint -e1509 */",
        "output": "0",
        "idx": 2695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n",
        "output": "1",
        "idx": 6145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t pipe_get_pages(struct iov_iter *i,\n\t\t   struct page **pages, size_t maxsize, unsigned maxpages,\n\t\t   size_t *start)\n{\n\tunsigned int iter_head, npages;\n\tsize_t capacity;\n\n\tif (!sanity(i))\n\t\treturn -EFAULT;\n\n\tdata_start(i, &iter_head, start);\n\t/* Amount of free space: some of this one + all after this one */\n\tnpages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);\n\tcapacity = min(npages, maxpages) * PAGE_SIZE - *start;\n\n\treturn __pipe_get_pages(i, min(maxsize, capacity), pages, iter_head, start);\n}",
        "output": "0",
        "idx": 2864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "output": "1",
        "idx": 3308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n",
        "output": "0",
        "idx": 4239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lka_report_smtp_tx_envelope(const char *direction, struct timeval *tv, uint64_t reqid, uint32_t msgid, uint64_t evpid)\n{\n\treport_smtp_broadcast(reqid, direction, tv, \"tx-envelope\",\n\t    \"%08x|%016\"PRIx64\"\\n\", msgid, evpid);\n}",
        "output": "0",
        "idx": 5333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 3020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int check_format(AVCodecContext *avctx)\n\n{\n\n    AVCodecParserContext *parser;\n\n    uint8_t *pout;\n\n    int psize;\n\n    int index;\n\n    H264Context *h;\n\n    int ret = -1;\n\n\n\n    /* init parser & parse file */\n\n    parser = av_parser_init(avctx->codec->id);\n\n    if (!parser) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 parser.\\n\");\n\n        goto final;\n\n    }\n\n    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;\n\n    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);\n\n    if (index < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to parse this file.\\n\");\n\n        goto release_parser;\n\n    }\n\n\n\n    /* check if support */\n\n    h = parser->priv_data;\n\n    switch (h->sps.bit_depth_luma) {\n\n    case 8:\n\n        if (!CHROMA444(h) && !CHROMA422(h)) {\n\n            // only this will H.264 decoder switch to hwaccel\n\n            ret = 0;\n\n            break;\n\n        }\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported file.\\n\");\n\n    }\n\n\n\nrelease_parser:\n\n    av_parser_close(parser);\n\n\n\nfinal:\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 5850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pci_bridge_reset_reg(PCIDevice *dev)\n\n{\n\n    uint8_t *conf = dev->config;\n\n\n\n    conf[PCI_PRIMARY_BUS] = 0;\n\n    conf[PCI_SECONDARY_BUS] = 0;\n\n    conf[PCI_SUBORDINATE_BUS] = 0;\n\n    conf[PCI_SEC_LATENCY_TIMER] = 0;\n\n\n\n    conf[PCI_IO_BASE] = 0;\n\n    conf[PCI_IO_LIMIT] = 0;\n\n    pci_set_word(conf + PCI_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);\n\n    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);\n\n\n\n    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);\n\n}\n",
        "output": "1",
        "idx": 5289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "krb5_error_code kdb_samba_db_delete_principal(krb5_context context,\n\t\t\t\t\t      krb5_const_principal princ)\n{\n\n\t/* NOTE: deferred, samba does not allow the KDC to delete\n\t * principals for now */\n\treturn KRB5_KDB_DB_INUSE;\n}",
        "output": "0",
        "idx": 1515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n\n\n    if (f->is_writable)\n\n        return;\n\n    if (f->is_file) {\n\n        fseek(f->outfile, f->buf_offset, SEEK_SET);\n\n        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);\n\n        if (len < 0)\n\n            len = 0;\n\n    } else {\n\n        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,\n\n                         f->buf, IO_BUF_SIZE);\n\n        if (len < 0)\n\n            len = 0;\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = len;\n\n    f->buf_offset += len;\n\n}\n",
        "output": "0",
        "idx": 2511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DEFUN (no_neighbor_nexthop_local_unchanged,\n       no_neighbor_nexthop_local_unchanged_cmd,\n       NO_NEIGHBOR_CMD2 \"nexthop-local unchanged\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"Configure treatment of outgoing link-local-nexthop attribute\\n\"\n       \"Leave link-local nexthop unchanged for this peer\\n\")\n{\n  return peer_af_flag_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t bgp_node_safi (vty),\n                                PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED );\n}",
        "output": "0",
        "idx": 2969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n",
        "output": "1",
        "idx": 5632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Smb4KGlobal::onlyForeignMountedShares()\n{\n  return p->onlyForeignShares;\n}",
        "output": "0",
        "idx": 1262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cnt_recv_prep(struct req *req, const char *ci)\n{\n\tconst char *xff;\n\n\tif (req->restarts == 0) {\n\t\t/*\n\t\t * This really should be done earlier, but we want to capture\n\t\t * it in the VSL log.\n\t\t */\n\t\thttp_CollectHdr(req->http, H_X_Forwarded_For);\n\t\tif (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {\n\t\t\thttp_Unset(req->http, H_X_Forwarded_For);\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s, %s\",\n\t\t\t    xff, ci);\n\t\t} else {\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s\", ci);\n\t\t}\n\t\thttp_CollectHdr(req->http, H_Cache_Control);\n\n\t\t/* By default we use the first backend */\n\t\treq->director_hint = VCL_DefaultDirector(req->vcl);\n\n\t\treq->d_ttl = -1;\n\t\treq->d_grace = -1;\n\t\treq->disable_esi = 0;\n\t\treq->hash_always_miss = 0;\n\t\treq->hash_ignore_busy = 0;\n\t\treq->client_identity = NULL;\n\t\treq->storage = NULL;\n\t}\n\n\treq->vdc->retval = 0;\n\treq->is_hit = 0;\n\treq->is_hitmiss = 0;\n\treq->is_hitpass = 0;\n}",
        "output": "1",
        "idx": 6050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,\n                                    void *opaque)\n{\n    const VMStateSubsection *sub = vmsd->subsections;\n\n    while (sub && sub->needed) {\n        if (sub->needed(opaque)) {\n            const VMStateDescription *vmsd = sub->vmsd;\n            uint8_t len;\n\n            qemu_put_byte(f, QEMU_VM_SUBSECTION);\n            len = strlen(vmsd->name);\n            qemu_put_byte(f, len);\n            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);\n            qemu_put_be32(f, vmsd->version_id);\n            vmstate_save_state(f, vmsd, opaque);\n        }\n        sub++;\n    }\n}",
        "output": "0",
        "idx": 3440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,\n\t\t\t int *qerr, u32 *salt)\n{\n\tstruct tcf_result res;\n\tint result;\n\n\tresult = tcf_classify(skb, fl, &res, false);\n\tif (result >= 0) {\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\t/* fall through */\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn false;\n\t\t}\n#endif\n\t\t*salt = TC_H_MIN(res.classid);\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 5436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_link_trusted (NautilusFile *file,\n\t\t gboolean is_launcher)\n{\n\tgboolean res;\n\t\n\tif (!is_launcher) {\n\t\treturn TRUE;\n\t}\n\t\n\tif (nautilus_file_can_execute (file)) {\n\t\treturn TRUE;\n\t}\n\n\tres = FALSE;\n\t\n\tif (nautilus_file_is_local (file)) {\n\t\tconst char * const * data_dirs; \n\t\tchar *uri, *path;\n\t\tint i;\n\t\t\t\n\t\tdata_dirs = g_get_system_data_dirs ();\n\t\t\n\t\tpath = NULL;\n\t\turi = nautilus_file_get_uri (file);\n\t\tif (uri) {\n\t\t\tpath = g_filename_from_uri (uri, NULL, NULL);\n\t\t\tg_free (uri);\n\t\t}\n\n\t\tfor (i = 0; path != NULL && data_dirs[i] != NULL; i++) {\n\t\t\tif (g_str_has_prefix (path, data_dirs[i])) {\n\t\t\t\tres = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tg_free (path);\n\t}\n\t\n\t\n\treturn res;\n}",
        "output": "1",
        "idx": 3234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\tencode_nops(&hdr);\n}",
        "output": "1",
        "idx": 3225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}",
        "output": "0",
        "idx": 4256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 1317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n\n  if (p >= end)\n    to->reach_end = 1;\n}",
        "output": "1",
        "idx": 4711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *qemu_find_file(int type, const char *name)\n\n{\n\n    int len;\n\n    const char *subdir;\n\n    char *buf;\n\n\n\n    /* If name contains path separators then try it as a straight path.  */\n\n    if ((strchr(name, '/') || strchr(name, '\\\\'))\n\n        && access(name, R_OK) == 0) {\n\n        return g_strdup(name);\n\n    }\n\n    switch (type) {\n\n    case QEMU_FILE_TYPE_BIOS:\n\n        subdir = \"\";\n\n        break;\n\n    case QEMU_FILE_TYPE_KEYMAP:\n\n        subdir = \"keymaps/\";\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n\n    buf = g_malloc0(len);\n\n    snprintf(buf, len, \"%s/%s%s\", data_dir, subdir, name);\n\n    if (access(buf, R_OK)) {\n\n        g_free(buf);\n\n        return NULL;\n\n    }\n\n    return buf;\n\n}\n",
        "output": "0",
        "idx": 233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,\n\n                                     AVCodecContext *avctx,\n\n                                     unsigned high_bit_depth)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_mmx;\n\n\n        c->diff_pixels = ff_diff_pixels_mmx;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_sse2;\n\n\n        c->diff_pixels = ff_diff_pixels_sse2;\n\n    }\n\n}",
        "output": "1",
        "idx": 173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "load_cache (GeglProperties *op_magick_load)\n{\n  if (!op_magick_load->user_data)\n    {\n      gchar    *filename;\n      gchar    *cmd;\n      GeglNode *graph, *sink, *loader;\n      GeglBuffer *newbuf = NULL;\n\n      /* ImageMagick backed fallback FIXME: make this robust.\n       * maybe use pipes in a manner similar to the raw loader,\n       * or at least use a properly unique filename  */\n\n      filename = g_build_filename (g_get_tmp_dir (), \"gegl-magick.png\", NULL);\n      cmd = g_strdup_printf (\"convert \\\"%s\\\"'[0]' \\\"%s\\\"\",\n                             op_magick_load->path, filename);\n      if (system (cmd) == -1)\n        g_warning (\"Error executing ImageMagick convert program\");\n\n\n      graph = gegl_node_new ();\n      sink = gegl_node_new_child (graph,\n                                 \"operation\", \"gegl:buffer-sink\",\n                                 \"buffer\", &newbuf, NULL);\n      loader = gegl_node_new_child (graph,\n                                    \"operation\", \"gegl:png-load\",\n                                    \"path\", filename, NULL);\n      gegl_node_link_many (loader, sink, NULL);\n      gegl_node_process (sink);\n      op_magick_load->user_data = (gpointer) newbuf;\n      g_object_unref (graph);\n      g_free (cmd);\n      g_free (filename);\n    }\n}",
        "output": "1",
        "idx": 4185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,\n\t\t\t\t\t    unsigned int reqsize)\n{\n\ttfm->reqsize = reqsize;\n}",
        "output": "0",
        "idx": 4817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ConvertLuvToXYZ(const double L,const double u,const double v,\n  double *X,double *Y,double *Z)\n{\n  double\n    gamma;\n\n  assert(X != (double *) NULL);\n  assert(Y != (double *) NULL);\n  assert(Z != (double *) NULL);\n  if (L > (CIEK*CIEEpsilon))\n    *Y=(double) pow((L+16.0)/116.0,3.0);\n  else\n    *Y=L/CIEK;\n  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+\n    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));\n  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+\n    5.0*(*Y));\n  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-\n    5.0*(*Y);\n}",
        "output": "1",
        "idx": 5747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tssize_t n;\n\n\tWARN_ONCE(1, \"%s is deprecated and scheduled for removal.\", __func__);\n\n\tdown_write(&tty->termios_rwsem);\n\tn = chars_in_buffer(tty);\n\tup_write(&tty->termios_rwsem);\n\treturn n;\n}",
        "output": "0",
        "idx": 6042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n",
        "output": "1",
        "idx": 5757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libschroedinger_encode_close(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    /* Close the encoder. */\n\n    schro_encoder_free(p_schro_params->encoder);\n\n\n\n    /* Free data in the output frame queue. */\n\n    ff_schro_queue_free(&p_schro_params->enc_frame_queue,\n\n                        libschroedinger_free_frame);\n\n\n\n\n\n    /* Free the encoder buffer. */\n\n    if (p_schro_params->enc_buf_size)\n\n        av_freep(&p_schro_params->enc_buf);\n\n\n\n    /* Free the video format structure. */\n\n    av_freep(&p_schro_params->format);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 6082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n",
        "output": "1",
        "idx": 3973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }",
        "output": "1",
        "idx": 6181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlRefTablePtr table;\n    unsigned int save;\n\n    if (ctxt == NULL)\n        return(0);\n    if (doc == NULL) {\n        xmlErrValid(ctxt, XML_DTD_NO_DOC,\n\t\t\"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n\treturn(0);\n    }\n\n    /* trick to get correct line id report */\n    save = ctxt->finishDtd;\n    ctxt->finishDtd = 0;\n\n    /*\n     * Check all the NOTATION/NOTATIONS attributes\n     */\n    /*\n     * Check all the ENTITY/ENTITIES attributes definition for validity\n     */\n    /*\n     * Check all the IDREF/IDREFS attributes definition for validity\n     */\n    table = (xmlRefTablePtr) doc->refs;\n    ctxt->doc = doc;\n    ctxt->valid = 1;\n    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);\n\n    ctxt->finishDtd = save;\n    return(ctxt->valid);\n}",
        "output": "0",
        "idx": 2469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    CinAudioContext *cin = avctx->priv_data;\n\n    const uint8_t *src = buf;\n\n    int16_t *samples = data;\n\n    int delta;\n\n\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n\n\n    delta = cin->delta;\n\n    if (cin->initial_decode_frame) {\n\n        cin->initial_decode_frame = 0;\n\n        delta = (int16_t)AV_RL16(src); src += 2;\n\n        *samples++ = delta;\n\n        buf_size -= 2;\n\n    }\n\n    while (buf_size > 0) {\n\n        delta += cinaudio_delta16_table[*src++];\n\n        delta = av_clip_int16(delta);\n\n        *samples++ = delta;\n\n        --buf_size;\n\n    }\n\n    cin->delta = delta;\n\n\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n\n\n    return src - buf;\n\n}\n",
        "output": "0",
        "idx": 2023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n",
        "output": "1",
        "idx": 686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* FIXME: skip headers if necessary ?! */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n\t\t*addr_len = sizeof(*saddr);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
        "output": "1",
        "idx": 777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void topicName(\n            const string_255& topicName)\n    {\n        topic_name_ = topicName;\n    }",
        "output": "0",
        "idx": 5837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int selinux_ipv4_output(unsigned int hooknum,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tconst struct net_device *in,\n\t\t\t\t\tconst struct net_device *out,\n\t\t\t\t\tint (*okfn)(struct sk_buff *))\n{\n\treturn selinux_ip_output(skb, PF_INET);\n}",
        "output": "0",
        "idx": 1879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,\n\t\t\tsize_t size, int flags)\n{\n\tif (!(sk->sk_route_caps & NETIF_F_SG))\n\t\treturn sock_no_sendpage_locked(sk, page, offset, size, flags);\n\n\ttcp_rate_check_app_limited(sk);  /* is sending application-limited? */\n\n\treturn do_tcp_sendpages(sk, page, offset, size, flags);\n}",
        "output": "0",
        "idx": 2579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    virtio_cleanup(vdev);\n\n    v9fs_device_unrealize_common(s, errp);\n\n}\n",
        "output": "0",
        "idx": 6077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "line_count_info(\n    char_u\t*line,\n    varnumber_T\t*wc,\n    varnumber_T\t*cc,\n    varnumber_T\tlimit,\n    int\t\teol_size)\n{\n    varnumber_T\ti;\n    varnumber_T\twords = 0;\n    varnumber_T\tchars = 0;\n    int\t\tis_word = 0;\n\n    for (i = 0; i < limit && line[i] != NUL; )\n    {\n\tif (is_word)\n\t{\n\t    if (vim_isspace(line[i]))\n\t    {\n\t\twords++;\n\t\tis_word = 0;\n\t    }\n\t}\n\telse if (!vim_isspace(line[i]))\n\t    is_word = 1;\n\t++chars;\n\ti += (*mb_ptr2len)(line + i);\n    }\n\n    if (is_word)\n\twords++;\n    *wc += words;\n\n    // Add eol_size if the end of line was reached before hitting limit.\n    if (i < limit && line[i] == NUL)\n    {\n\ti += eol_size;\n\tchars += eol_size;\n    }\n    *cc += chars;\n    return i;\n}",
        "output": "0",
        "idx": 4476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void shmem_free_blocks(struct inode *inode, long pages)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);\n\tif (sbinfo->max_blocks) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_blocks += pages;\n\t\tinode->i_blocks -= pages*BLOCKS_PER_PAGE;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}",
        "output": "0",
        "idx": 2083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 7; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb)\n\n            res |= 1 << i;\n\n    }\n\n    return res;\n\n}\n",
        "output": "0",
        "idx": 6078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n",
        "output": "1",
        "idx": 5155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tswitch (yych) {\n\t\tcase 'a': goto yy37;\n\t\tdefault: goto yy36;\n\t}",
        "output": "1",
        "idx": 5404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 4313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}",
        "output": "1",
        "idx": 3795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Item *Item_bool::neg_transformer(THD *thd)\n{\n  value= !value;\n  name= 0;\n  return this;\n}",
        "output": "0",
        "idx": 3620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {\n  initialize();\n\n  InSequence sequence;\n\n  MockRequestDecoder decoder;\n  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));\n\n  TestRequestHeaderMapImpl expected_headers{\n      {\":path\", \"/\"},\n      {\":method\", \"POST\"},\n      {\"transfer-encoding\", \"chunked\"},\n  };\n  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  Buffer::OwnedImpl expected_data(\"Hello World\");\n  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));\n  // Call to decodeData(\"\", true) happens after.\n  Buffer::OwnedImpl empty(\"\");\n  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));\n\n  Buffer::OwnedImpl buffer(\"POST / HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n                           \"6\\r\\nHello \\r\\n\"\n                           \"5\\r\\nWorld\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n  auto status = codec_->dispatch(buffer);\n  EXPECT_TRUE(status.ok());\n  EXPECT_EQ(0U, buffer.length());\n}",
        "output": "0",
        "idx": 2627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int still_interesting(struct commit_list *src, unsigned long date, int slop)\n{\n\t/*\n\t * No source list at all? We're definitely done..\n\t */\n\tif (!src)\n\t\treturn 0;\n\n\t/*\n\t * Does the destination list contain entries with a date\n\t * before the source list? Definitely _not_ done.\n\t */\n\tif (date < src->item->date)\n\t\treturn SLOP;\n\n\t/*\n\t * Does the source list still have interesting commits in\n\t * it? Definitely not done..\n\t */\n\tif (!everybody_uninteresting(src))\n\t\treturn SLOP;\n\n\t/* Ok, we're closing in.. */\n\treturn slop-1;\n}",
        "output": "0",
        "idx": 4265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int init_dumping(char *database, int init_func(char*))\n{\n  if (mysql_select_db(mysql, database))\n  {\n    DB_error(mysql, \"when selecting the database\");\n    return 1;                   /* If --force */\n  }\n  if (!path && !opt_xml)\n  {\n    if (opt_databases || opt_alldbs)\n    {\n      /*\n        length of table name * 2 (if name contains quotes), 2 quotes and 0\n      */\n      char quoted_database_buf[NAME_LEN*2+3];\n      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);\n\n      print_comment(md_result_file, 0,\n                    \"\\n--\\n-- Current Database: %s\\n--\\n\", qdatabase);\n\n      /* Call the view or table specific function */\n      init_func(qdatabase);\n\n      fprintf(md_result_file,\"\\nUSE %s;\\n\", qdatabase);\n      check_io(md_result_file);\n    }\n  }\n  return 0;\n} /* init_dumping */",
        "output": "1",
        "idx": 4514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_snmp_object_free_storage(void *object TSRMLS_DC)\n{\n\tphp_snmp_object *intern = (php_snmp_object *)object;\n\t\n\tif (!intern) {\n\t\treturn;\n\t}\n\n\tnetsnmp_session_free(&(intern->session));\n\n\tzend_object_std_dtor(&intern->zo TSRMLS_CC);\n\t\n\tefree(intern);\n}",
        "output": "1",
        "idx": 4497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    WriterProxyData(\n            size_t max_unicast_locators,\n            size_t max_multicast_locators,\n            const VariableLengthDataLimits& data_limits)\n        : remote_locators_(max_unicast_locators, max_multicast_locators)\n        , topic_kind_(NO_KEY)\n        , is_alive_(true)\n        , type_id_()\n        , type_()\n        , type_info_()\n        , m_typeMaxSerialized(0)\n        , m_userDefinedId(0)\n    {\n        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);\n        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);\n    }",
        "output": "0",
        "idx": 5946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stonith_action_create(const char *agent,\n        const char *_action,\n        const char *victim,\n        int timeout,\n        GHashTable * device_args,\n        GHashTable * port_map)\n{\n    stonith_action_t *action;\n    char *value = NULL;\n\n    action = calloc(1, sizeof(stonith_action_t));\n    crm_info(\"Initiating action %s for agent %s (target=%s)\", _action, agent, victim);\n    action->args = make_args(_action, victim, device_args, port_map);\n    action->agent = strdup(agent);\n    action->action = strdup(_action);\n    if (victim) {\n        action->victim = strdup(victim);\n    }\n    action->timeout = action->remaining_timeout = timeout;\n\n    value = g_hash_table_lookup(device_args, \"pcmk_fencing_max_retries\");\n    if (value && (safe_str_eq(action->action, \"on\") || safe_str_eq(action->action, \"off\")\n        || safe_str_eq(action->action, \"reboot\"))) {\n        action->max_retries = atoi(value);\n    } else {\n        action->max_retries = FAILURE_MAX_RETRIES;\n    }\n\n    return action;\n}",
        "output": "0",
        "idx": 4210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AverageEvalQuantizedInt16(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  CalculateActivationRangeQuantized(context, params->activation, output,\n                                    &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<int16_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int16_t>(output))\n  TF_LITE_AVERAGE_POOL(reference_integer_ops);\n#undef TF_LITE_AVERAGE_POOL\n}",
        "output": "1",
        "idx": 1072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void maybeAllocTrailers() override {\n    ASSERT(processing_trailers_);\n    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {\n      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());\n    }\n  }",
        "output": "1",
        "idx": 4469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n\tconst size_t bytes_total = (size_t) size;\n        size_t bytes_written;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_written=0; bytes_written < bytes_total; bytes_written+=count)\n        {\n                const char *buf_offset = (char *) buf+bytes_written;\n                size_t io_size = bytes_total-bytes_written;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=write(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_written;\n\t/* return ((tmsize_t) write(fdh.fd, buf, bytes_total)); */\n}",
        "output": "0",
        "idx": 764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rpmsg_char_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, \"rpmsg\");\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsg: failed to allocate char dev region\\n\");\n\t\treturn ret;\n\t}\n\n\trpmsg_class = class_create(THIS_MODULE, \"rpmsg\");\n\tif (IS_ERR(rpmsg_class)) {\n\t\tpr_err(\"failed to create rpmsg class\\n\");\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t\treturn PTR_ERR(rpmsg_class);\n\t}\n\n\tret = register_rpmsg_driver(&rpmsg_chrdev_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsgchr: failed to register rpmsg driver\\n\");\n\t\tclass_destroy(rpmsg_class);\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 81
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs = vd->clients;\n\n    while (vs != NULL) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        else /* TODO */\n\n            vnc_update(vs, dst_x, dst_y, w, h);\n\n        vs = vs->next;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bgp_keepalive_send(struct peer *peer)\n{\n\tstruct stream *s;\n\n\ts = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);\n\n\t/* Make keepalive packet. */\n\tbgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);\n\n\t/* Set packet size. */\n\tbgp_packet_set_size(s);\n\n\t/* Dump packet if debug option is set. */\n\t/* bgp_packet_dump (s); */\n\n\tif (bgp_debug_keepalive(peer))\n\t\tzlog_debug(\"%s sending KEEPALIVE\", peer->host);\n\n\t/* Add packet to the peer. */\n\tbgp_packet_add(peer, s);\n\n\tbgp_writes_on(peer);\n}",
        "output": "0",
        "idx": 1690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_visible_txid(txid value, const TxidSnapshot *snap)\n{\n\tif (value < snap->xmin)\n\t\treturn true;\n\telse if (value >= snap->xmax)\n\t\treturn false;\n#ifdef USE_BSEARCH_IF_NXIP_GREATER\n\telse if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)\n\t{\n\t\tvoid\t   *res;\n\n\t\tres = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\t\t/* if found, transaction is still in progress */\n\t\treturn (res) ? false : true;\n\t}\n#endif\n\telse\n\t{\n\t\tuint32\t\ti;\n\n\t\tfor (i = 0; i < snap->nxip; i++)\n\t\t{\n\t\t\tif (value == snap->xip[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}",
        "output": "0",
        "idx": 3494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dv_read_seek(AVFormatContext *s, int stream_index,\n\n                       int64_t timestamp, int flags)\n\n{\n\n    RawDVContext *r   = s->priv_data;\n\n    DVDemuxContext *c = r->dv_demux;\n\n    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);\n\n\n\n    dv_offset_reset(c, offset / c->sys->frame_size);\n\n\n\n    offset = avio_seek(s->pb, offset, SEEK_SET);\n\n    return (offset < 0) ? offset : 0;\n\n}\n",
        "output": "1",
        "idx": 3921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,\n\t\t\t      gint start, gint length, guint32 value,\n\t\t\t      const char *format, ...)\n{\n\tproto_item\t  *pi;\n\tva_list\t\t   ap;\n\n\tpi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);\n\tif (pi != tree) {\n\t\tTRY_TO_FAKE_THIS_REPR(pi);\n\n\t\tva_start(ap, format);\n\t\tproto_tree_set_representation(pi, format, ap);\n\t\tva_end(ap);\n\t}\n\n\treturn pi;\n}",
        "output": "0",
        "idx": 3749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.4 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}",
        "output": "1",
        "idx": 4145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n",
        "output": "1",
        "idx": 1324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FFTContext *av_fft_init(int nbits, int inverse)\n\n{\n\n    FFTContext *s = av_malloc(sizeof(*s));\n\n\n\n    if (s && ff_fft_init(s, nbits, inverse))\n\n        av_freep(&s);\n\n\n\n    return s;\n\n}\n",
        "output": "1",
        "idx": 398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, TCGLabel *l)\n\n{\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r=  ((uint32_t*)src)[i]&0xFF;\n\n\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\n\n\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n",
        "output": "1",
        "idx": 3093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}",
        "output": "1",
        "idx": 3033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_busid_idx(const char *busid)\n{\n\tint i;\n\tint idx = -1;\n\n\tfor (i = 0; i < MAX_BUSID; i++)\n\t\tif (busid_table[i].name[0])\n\t\t\tif (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\treturn idx;\n}",
        "output": "1",
        "idx": 2798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 3893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_mbdata (struct dfa *d)\n{\n  unsigned int i;\n\n  free(d->multibyte_prop);\n  d->multibyte_prop = NULL;\n\n  for (i = 0; i < d->nmbcsets; ++i)\n    {\n      unsigned int j;\n      struct mb_char_classes *p = &(d->mbcsets[i]);\n      free(p->chars);\n      free(p->ch_classes);\n      free(p->range_sts);\n      free(p->range_ends);\n\n      for (j = 0; j < p->nequivs; ++j)\n        free(p->equivs[j]);\n      free(p->equivs);\n\n      for (j = 0; j < p->ncoll_elems; ++j)\n        free(p->coll_elems[j]);\n      free(p->coll_elems);\n    }\n\n  free(d->mbcsets);\n  d->mbcsets = NULL;\n  d->nmbcsets = 0;\n}",
        "output": "1",
        "idx": 2239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n",
        "output": "0",
        "idx": 5490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void opt_frame_size(const char *arg)\n\n{\n\n    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {\n\n        fprintf(stderr, \"Incorrect frame size\\n\");\n\n        av_exit(1);\n\n    }\n\n    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {\n\n        fprintf(stderr, \"Frame size must be a multiple of 2\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 4152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold int ffv1_common_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n\n\n    if (!avctx->width || !avctx->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    s->avctx = avctx;\n\n    s->flags = avctx->flags;\n\n\n\n    s->picture.f = avcodec_alloc_frame();\n\n    s->last_picture.f = av_frame_alloc();\n\n\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n\n\n    s->width  = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    // defaults\n\n    s->num_h_slices = 1;\n\n    s->num_v_slices = 1;\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 1834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SMB2_sess_sendreceive(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb2_sess_setup_req *req = sess_data->iov[0].iov_base;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->SecurityBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req) -\n\t\t\t1 /* pad */ - 4 /* rfc1001 len */);\n\treq->SecurityBufferLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tinc_rfc1001_len(req, sess_data->iov[1].iov_len - 1 /* pad */);\n\n\t/* BB add code to build os and lm fields */\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t\tsess_data->iov, 2,\n\t\t\t\t&sess_data->buf0_type,\n\t\t\t\tCIFS_LOG_ERROR | CIFS_NEG_OP, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}",
        "output": "0",
        "idx": 297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_eventfd(int fds[2])\n\n{\n\n#ifdef CONFIG_EVENTFD\n\n    int ret;\n\n\n\n    ret = eventfd(0, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = ret;\n\n        qemu_set_cloexec(ret);\n\n        if ((fds[1] = dup(ret)) == -1) {\n\n            close(ret);\n\n            return -1;\n\n        }\n\n        qemu_set_cloexec(fds[1]);\n\n        return 0;\n\n    }\n\n\n\n    if (errno != ENOSYS) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    return qemu_pipe(fds);\n\n}\n",
        "output": "0",
        "idx": 359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplObjectStorage, getHash)\n{\n\tzval *obj;\n\tchar *hash;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\n\thash = emalloc(33);\n\tphp_spl_object_hash(obj, hash TSRMLS_CC);\n\t\n\tRETVAL_STRING(hash, 0);\n\n} /* }}} */",
        "output": "1",
        "idx": 5831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)\n{\n\tirda_queue_t *ret;\n\n\tpr_debug(\"dequeue_general()\\n\");\n\n\t/*\n\t * Set return value\n\t */\n\tret =  *queue;\n\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue was empty.\n\t\t */\n\t} else if ( (*queue)->q_next == *queue ) {\n\t\t/*\n\t\t *  Queue only contained a single element. It will now be\n\t\t *  empty.\n\t\t */\n\t\t*queue = NULL;\n\n\t} else {\n\t\t/*\n\t\t *  Remove specific element.\n\t\t */\n\t\telement->q_prev->q_next = element->q_next;\n\t\telement->q_next->q_prev = element->q_prev;\n\t\tif ( (*queue) == element)\n\t\t\t(*queue) = element->q_next;\n\t}\n\n\t/*\n\t * Return the removed entry (or NULL of queue was empty).\n\t */\n\treturn ret;\n}",
        "output": "0",
        "idx": 711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n",
        "output": "0",
        "idx": 727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)\n{\n\tsc_pkcs15_cert_info_t cert_info;\n\tsc_pkcs15_cert_t *cert_out = NULL;\n\tsc_pkcs15_pubkey_t *key = NULL;\n\tint r;\n\n\tcert_info.value.value = NULL;\n\tr = coolkey_get_certificate(p15card->card, obj, &cert_info.value);\n\tif (r < 0) {\n\t\tgoto fail;\n\t}\n\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert_out);\n\tif (r < 0) {\n\t\tgoto fail;\n\t}\n\tkey = cert_out->key;\n\tcert_out->key = NULL; /* adopt the key from the cert */\nfail:\n\tif (cert_out) {\n\t\tsc_pkcs15_free_certificate(cert_out);\n\t}\n\tif (cert_info.value.value) {\n\t\tfree(cert_info.value.value);\n\t}\n\treturn key;\n}",
        "output": "1",
        "idx": 948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int png_dec_end(AVCodecContext *avctx)\n\n{\n\n    PNGDecContext *s = avctx->priv_data;\n\n\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n\n    av_frame_free(&s->previous_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n\n    av_frame_free(&s->last_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->picture);\n\n    av_frame_free(&s->picture.f);\n\n    av_freep(&s->buffer);\n\n    s->buffer_size = 0;\n\n    av_freep(&s->last_row);\n\n    s->last_row_size = 0;\n\n    av_freep(&s->tmp_row);\n\n    s->tmp_row_size = 0;\n\n    av_freep(&s->extra_data);\n\n    s->extra_data_size = 0;\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mutt_b64_decode(char *out, const char *in)\n{\n  int len = 0;\n  unsigned char digit4;\n\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n\n    /* digits are already sanity-checked */\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n\n  return len;\n}",
        "output": "1",
        "idx": 109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }",
        "output": "0",
        "idx": 5453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
        "output": "0",
        "idx": 4214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n     * Lua API, we need to iterate a first time. Note that an alternative\n     * would be to do a single run, and then hack the buffer to insert the\n     * map opcodes for message pack. Too hackish for this lib. */\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}",
        "output": "1",
        "idx": 5911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cil_reset_netifcon(struct cil_netifcon *netifcon)\n{\n\tif (netifcon->if_context_str == NULL) {\n\t\tcil_reset_context(netifcon->if_context);\n\t}\n\n\tif (netifcon->packet_context_str == NULL) {\n\t\tcil_reset_context(netifcon->packet_context);\n\t}\n}",
        "output": "0",
        "idx": 4195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n",
        "output": "1",
        "idx": 4369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){\n  int i;\n  if( pA==0 && pB==0 ) return 0;\n  if( pA==0 || pB==0 ) return 1;\n  if( pA->nExpr!=pB->nExpr ) return 1;\n  for(i=0; i<pA->nExpr; i++){\n    Expr *pExprA = pA->a[i].pExpr;\n    Expr *pExprB = pB->a[i].pExpr;\n    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;\n    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;\n  }\n  return 0;\n}",
        "output": "0",
        "idx": 157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,\n\n                  int flags, int mode)\n\n{\n\n    int err;\n\n    FsCred cred;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_mode = mode & 07777;\n\n    cred.fc_uid = fidp->uid;\n\n    cred.fc_gid = gid;\n\n    v9fs_co_run_in_worker(\n\n        {\n\n            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);\n\n            err = 0;\n\n            if (fidp->fs.fd == -1) {\n\n                err = -errno;\n\n            }\n\n        });\n\n    if (!err) {\n\n        total_open_fd++;\n\n        if (total_open_fd > open_fd_hw) {\n\n            v9fs_reclaim_fd(s);\n\n        }\n\n    }\n\n    return err;\n\n}\n",
        "output": "0",
        "idx": 3782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SCK_RemoveSocket(int sock_fd)\n{\n  union sockaddr_all saddr;\n  socklen_t saddr_len;\n\n  saddr_len = sizeof (saddr);\n\n  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {\n    DEBUG_LOG(\"getsockname() failed : %s\", strerror(errno));\n    return 0;\n  }\n\n  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||\n      saddr.sa.sa_family != AF_UNIX)\n    return 0;\n\n  if (unlink(saddr.un.sun_path) < 0) {\n    DEBUG_LOG(\"unlink(%s) failed : %s\", saddr.un.sun_path, strerror(errno));\n    return 0;\n  }\n\n  DEBUG_LOG(\"Removed %s\", saddr.un.sun_path);\n\n  return 1;\n}",
        "output": "1",
        "idx": 4107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void term_flush(void)\n\n{\n\n}\n",
        "output": "0",
        "idx": 4128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)\n\n{\n\n    offset_t offset1;\n\n    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n        return -EINVAL;\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n        offset += offset1;\n\n    }\n\n    offset1 = offset - pos;\n\n    if (!s->must_flush &&\n\n        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {\n\n        /* can do the seek inside the buffer */\n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else {\n\n        if (!s->seek)\n\n            return -EPIPE;\n\n\n\n#ifdef CONFIG_MUXERS\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n            s->must_flush = 1;\n\n        } else\n\n#endif //CONFIG_MUXERS\n\n        {\n\n            s->buf_end = s->buffer;\n\n        }\n\n        s->buf_ptr = s->buffer;\n\n        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)\n\n            return -EPIPE;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}\n",
        "output": "1",
        "idx": 531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n                                 struct tftphdr *hdr)\n{\n    struct tftp_session *spt;\n    int k;\n\n    for (k = 0; k < TFTP_SESSIONS_MAX; k++) {\n        spt = &slirp->tftp_sessions[k];\n\n        if (!tftp_session_in_use(spt))\n            goto found;\n\n        /* sessions time out after 5 inactive seconds */\n        if ((int)(curtime - spt->timestamp) > 5000) {\n            tftp_session_terminate(spt);\n            goto found;\n        }\n    }\n\n    return -1;\n\nfound:\n    memset(spt, 0, sizeof(*spt));\n    memcpy(&spt->client_addr, srcsas, sockaddr_size(srcsas));\n    spt->fd = -1;\n    spt->block_size = 512;\n    spt->client_port = hdr->udp.uh_sport;\n    spt->slirp = slirp;\n\n    tftp_session_update(spt);\n\n    return k;\n}",
        "output": "0",
        "idx": 5168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // TODO(ahentz): Our current implementations rely on the input being 4D,\n  // and the size being 1D tensor with exactly 2 elements.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, size->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, size->dims->data[0], 2);\n\n  output->type = input->type;\n\n  if (!IsConstantTensor(size)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n  return ResizeOutputTensor(context, input, size, output);\n}",
        "output": "1",
        "idx": 2274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n",
        "output": "0",
        "idx": 851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rc_table_update(struct qcow_state *s, unsigned int rc_index, uint64_t refblock_offset)\n{\n\tssize_t ret;\n\n\ttcmu_dbg(\"%s: setting RC[%d] to %llx\\n\", __func__, rc_index, refblock_offset);\n\ts->refcount_table[rc_index] = htobe64(refblock_offset);\n\n\tret = pwrite(s->fd,\n\t\t&s->refcount_table[rc_index],\n\t\tsizeof(uint64_t),\n\t\ts->refcount_table_offset + (rc_index * sizeof(uint64_t)));\n\n\tif (ret != sizeof(uint64_t))\n\t\ttcmu_err(\"%s: error, RC writeback failed (%zd)\\n\", __func__, ret);\n\n\tfdatasync(s->fd);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}",
        "output": "1",
        "idx": 853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_clear_inode(struct inode *inode)\n{\n\text4_discard_preallocations(inode);\n\tif (EXT4_JOURNAL(inode))\n\t\tjbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,\n\t\t\t\t       &EXT4_I(inode)->jinode);\n}",
        "output": "0",
        "idx": 4787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void fx_finit(struct i387_fxsave_struct *fx)\n{\n\tmemset(fx, 0, xstate_size);\n\tfx->cwd = 0x37f;\n\tfx->mxcsr = MXCSR_DEFAULT;\n}",
        "output": "0",
        "idx": 759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,\n\t\t\t       snd_pcm_state_t state)\n{\n\tif (substream->runtime->trigger_master == substream)\n\t\tsubstream->ops->trigger(substream,\n\t\t\t\t\tpause_pushed(state) ?\n\t\t\t\t\tSNDRV_PCM_TRIGGER_PAUSE_RELEASE :\n\t\t\t\t\tSNDRV_PCM_TRIGGER_PAUSE_PUSH);\n}",
        "output": "0",
        "idx": 3741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jpeg_init_destination(j_compress_ptr cinfo)\n{\n    VncState *vs = cinfo->client_data;\n    Buffer *buffer = &vs->tight.jpeg;\n\n    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;\n    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);\n}",
        "output": "1",
        "idx": 2556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n",
        "output": "0",
        "idx": 3932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    FileIo::Impl::Impl(const std::string& path)\n        : path_(path),\n#ifdef EXV_UNICODE_PATH\n        wpMode_(wpStandard),\n#endif\n        fp_(0), opMode_(opSeek),\n#if defined WIN32 && !defined __CYGWIN__\n        hFile_(0), hMap_(0),\n#endif\n        pMappedArea_(0), mappedLength_(0), isMalloced_(false), isWriteable_(false)\n    {\n    }",
        "output": "0",
        "idx": 4032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *crypt_get_dir(void)\n{\n\treturn dm_get_dir();\n}",
        "output": "0",
        "idx": 148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)\n{\n    uint32_t *buf32;\n    uint32_t pix;\n    int rshift, gshift, bshift;\n\n    buf32 = (uint32_t *)buf;\n\n    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n        rshift = vs->clientds.pf.rshift;\n        gshift = vs->clientds.pf.gshift;\n        bshift = vs->clientds.pf.bshift;\n    } else {\n        rshift = 24 - vs->clientds.pf.rshift;\n        gshift = 24 - vs->clientds.pf.gshift;\n        bshift = 24 - vs->clientds.pf.bshift;\n    }\n\n    if (ret) {\n        *ret = count * 3;\n    }\n\n    while (count--) {\n        pix = *buf32++;\n        *buf++ = (char)(pix >> rshift);\n        *buf++ = (char)(pix >> gshift);\n        *buf++ = (char)(pix >> bshift);\n    }\n}",
        "output": "1",
        "idx": 2930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *scsibus_get_dev_path(DeviceState *dev)\n\n{\n\n    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);\n\n    DeviceState *hba = dev->parent_bus->parent;\n\n    char *id = NULL;\n\n\n\n    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {\n\n        id = hba->parent_bus->info->get_dev_path(hba);\n\n    }\n\n    if (id) {\n\n        return g_strdup_printf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun);\n\n    } else {\n\n        return g_strdup_printf(\"%d:%d:%d\", d->channel, d->id, d->lun);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 5411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}",
        "output": "1",
        "idx": 1159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)\n{\n\tstruct iovec iov[64];\n\tint i, ret;\n\n\tif (!vq->iotlb)\n\t\treturn log_write(vq->log_base, vq->log_addr + used_offset, len);\n\n\tret = translate_desc(vq, (uintptr_t)vq->used + used_offset,\n\t\t\t     len, iov, 64, VHOST_ACCESS_WO);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ret; i++) {\n\t\tret = log_write_hva(vq,\t(uintptr_t)iov[i].iov_base,\n\t\t\t\t    iov[i].iov_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void save_key_to(const char *algo, const char *name, const char *keydata)\n{\n\tconst char *error;\n\tstruct dict_transaction_context *ctx =\n\t\tdict_transaction_begin(keys_dict);\n\n\tdict_set(ctx, t_strconcat(DICT_PATH_SHARED, \"default/\", algo, \"/\",\n\t\t\t\t  name, NULL),\n\t\t keydata);\n\tif (dict_transaction_commit(&ctx, &error) < 0)\n\t\ti_error(\"dict_set(%s) failed: %s\", name, error);\n}",
        "output": "1",
        "idx": 5920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BitWriter::writeBits(unsigned long long val, unsigned int bits)\n{\n    write_bits(this->ch, this->bit_offset, val, bits, this->pl);\n}",
        "output": "1",
        "idx": 589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int htc_send(struct htc_target *target, struct sk_buff *skb)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\treturn htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);\n}",
        "output": "0",
        "idx": 732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}",
        "output": "1",
        "idx": 4678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)\n{\n    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;\n    int op0 = pct0->params.pdf14_op;\n\n    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {\n        /* Halftone commands are always passed to the target printer device,\n           because transparency buffers are always contone.\n           So we're safe to execute them before queued transparency compositors. */\n        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||\n                                       cmd1 == cmd_opv_ext_put_ht_seg))\n            return true;\n        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))\n            return true;\n    }\n    return false;\n}",
        "output": "0",
        "idx": 4675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vmci_transport_notify_send_pre_enqueue(\n\tstruct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->send_pre_enqueue(\n\t\t\t&vsk->sk,\n\t\t\t(struct vmci_transport_send_notify_data *)data);\n}",
        "output": "0",
        "idx": 5327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {\n  whenInputIs(\"\\\"hello \\\\\\\"world\\\\\\\"\\\"\");\n  resultMustBe(\"hello \\\"world\\\"\");\n}",
        "output": "0",
        "idx": 4131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)\n{\n    debugs(85,3, HERE << \"handleAdaptationFailure(\" << bypassable << \")\");\n\n    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();\n    const bool usedPipe = request->body_pipe != NULL &&\n                          request->body_pipe->consumedSize() > 0;\n\n    if (bypassable && !usedStore && !usedPipe) {\n        debugs(85,3, HERE << \"ICAP REQMOD callout failed, bypassing: \" << calloutContext);\n        if (calloutContext)\n            doCallouts();\n        return;\n    }\n\n    debugs(85,3, HERE << \"ICAP REQMOD callout failed, responding with error\");\n\n    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;\n    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());\n    assert(repContext);\n\n    calloutsError(ERR_ICAP_FAILURE, errDetail);\n\n    if (calloutContext)\n        doCallouts();\n}",
        "output": "0",
        "idx": 2660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, current)\n{\n\tspl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_ptr_llist_element *element = intern->traverse_pointer;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (element == NULL || element->data == NULL) {\n\t\tRETURN_NULL();\n\t} else {\n\t\tzval *data    = (zval *)element->data;\n\t\tRETURN_ZVAL(data, 1, 0);\n\t}\n}",
        "output": "0",
        "idx": 2360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  char* mutableEnd() { return mutableStart() + size_; }",
        "output": "0",
        "idx": 481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}",
        "output": "1",
        "idx": 4329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.dinfo) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n",
        "output": "0",
        "idx": 4051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,\n                                        gpointer         user_data)\n{\n  /* first figure out which layer in the layer side menu is selected */\n  gint index=callbacks_get_selected_row_index();\n  \n  /* Now save that layer */\n  if (index >= 0) {\n    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {\n      interface_show_alert_dialog(_(\"Gerbv cannot export this file type\"), \n\t\t\t\t  NULL,\n\t\t\t\t  FALSE,\n\t\t\t\t  NULL);\n      mainProject->file[index]->layer_dirty = FALSE;\n      callbacks_update_layer_tree();\n      return;\n    }\n  }\n  callbacks_update_layer_tree();\n  return;\n}",
        "output": "0",
        "idx": 4680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void handle_one(const struct inode *inode)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\tif (likely(hlist_empty(&inode->i_fsnotify_marks)))\n\t\treturn;\n\tcontext = current->audit_context;\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n#endif\n}",
        "output": "0",
        "idx": 1964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {\n    xmlXPathContextPtr ret;\n\n    ret = xmlXPathNewContext(doc);\n    if (ret == NULL)\n\treturn(ret);\n    ret->xptr = 1;\n    ret->here = here;\n    ret->origin = origin;\n\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"range-to\",\n\t                 xmlXPtrRangeToFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"range\",\n\t                 xmlXPtrRangeFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"range-inside\",\n\t                 xmlXPtrRangeInsideFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"string-range\",\n\t                 xmlXPtrStringRangeFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"start-point\",\n\t                 xmlXPtrStartPointFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"end-point\",\n\t                 xmlXPtrEndPointFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"here\",\n\t                 xmlXPtrHereFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\" origin\",\n\t                 xmlXPtrOriginFunction);\n\n    return(ret);\n}",
        "output": "1",
        "idx": 2684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "renderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n\n    if (cotable_level >= MAX_COTABLE_LEVEL)\n\treturn;\t/* workaround to prevent infinite recursion */\n    cotable_level++;\n\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}",
        "output": "1",
        "idx": 3832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n",
        "output": "1",
        "idx": 4413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pal_init (CPUState *env)\n\n{\n\n}\n",
        "output": "0",
        "idx": 4530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}",
        "output": "1",
        "idx": 222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT LPTSTR get_params() {\n    LPTSTR c;\n    TCHAR s;\n\n    c=GetCommandLine();\n    if(*c==TEXT('\\\"')) {\n        s=TEXT('\\\"');\n        ++c;\n    } else {\n        s=TEXT(' ');\n    }\n    for(; *c; ++c)\n        if(*c==s) {\n            ++c;\n            break;\n        }\n    while(*c==TEXT(' '))\n        ++c;\n    return c;\n}",
        "output": "0",
        "idx": 2880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n",
        "output": "1",
        "idx": 2792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_polygon (void)\n{\n    return rsvg_new_any_poly (FALSE);\n}",
        "output": "1",
        "idx": 5753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int shorten_decode_close(AVCodecContext *avctx)\n\n{\n\n    ShortenContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < s->channels; i++) {\n\n        s->decoded[i] -= s->nwrap;\n\n        av_freep(&s->decoded[i]);\n\n        av_freep(&s->offset[i]);\n\n    }\n\n    av_freep(&s->bitstream);\n\n    av_freep(&s->coeffs);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n    MMIOState *s= opaque;\n\n    return ide_status_read(&s->bus, 0);\n\n}\n",
        "output": "0",
        "idx": 3352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)\n{\n  /* Need to bootstrap using the allocator function directly */\n  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n\n  vt->allocator = funcs;\n  vt->allocdata = allocdata;\n\n  vt->rows = rows;\n  vt->cols = cols;\n\n  vt->parser.state = NORMAL;\n\n  vt->parser.callbacks = NULL;\n  vt->parser.cbdata    = NULL;\n\n  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */\n  vt->parser.strbuffer_cur = 0;\n  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n\n  vt->outbuffer_len = 200;\n  vt->outbuffer_cur = 0;\n  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n\n  return vt;\n}",
        "output": "1",
        "idx": 1394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}",
        "output": "0",
        "idx": 2477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)\n{\n\trr->type = (QueryType)((input[0] << 8) + input[1]);\n\trr->rr_class = (input[2] << 8) + input[3];\n\trr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];\n\trr->rdlength = (input[8] << 8) + input[9];\n}",
        "output": "0",
        "idx": 5250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svg_parse_length(SVGParser *parser, SVG_Length *length, char *value_string)\n{\n\tFloat _val;\n\tif (strstr(value_string, \"%\")) length->type = SVG_LENGTH_PERCENTAGE;\n\telse if (strstr(value_string, \"em\")) length->type = SVG_LENGTH_EMS;\n\telse if (strstr(value_string, \"ex\")) length->type = SVG_LENGTH_EXS;\n\telse if (strstr(value_string, \"px\")) length->type = SVG_LENGTH_PX;\n\telse if (strstr(value_string, \"cm\")) length->type = SVG_LENGTH_CM;\n\telse if (strstr(value_string, \"mm\")) length->type = SVG_LENGTH_MM;\n\telse if (strstr(value_string, \"in\")) length->type = SVG_LENGTH_IN;\n\telse if (strstr(value_string, \"pt\")) length->type = SVG_LENGTH_PT;\n\telse if (strstr(value_string, \"pc\")) length->type = SVG_LENGTH_PC;\n\telse length->type = SVG_LENGTH_NUMBER;\n\tsscanf(value_string, \"%f\", &_val);\n\tlength->number = FLT2FIX(_val); \n}",
        "output": "0",
        "idx": 7
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_event_exec(void)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = current->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_event_enable_on_exec(ctx);\n\t}\n\trcu_read_unlock();\n}",
        "output": "0",
        "idx": 434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n",
        "output": "0",
        "idx": 4642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n",
        "output": "0",
        "idx": 3962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScanLineInputFile::ScanLineInputFile(InputPartData* part)\n{\n    if (part->header.type() != SCANLINEIMAGE)\n        throw IEX_NAMESPACE::ArgExc(\"Can't build a ScanLineInputFile from a type-mismatched part.\");\n\n    _data = new Data(part->numThreads);\n    _streamData = part->mutex;\n    _data->memoryMapped = _streamData->is->isMemoryMapped();\n\n    _data->version = part->version;\n\n    initialize(part->header);\n\n    _data->lineOffsets = part->chunkOffsets;\n\n    _data->partNumber = part->partNumber;\n    //\n    // (TODO) change this code later.\n    // The completeness of the file should be detected in MultiPartInputFile.\n    //\n    _data->fileIsComplete = true;\n}",
        "output": "1",
        "idx": 1329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}",
        "output": "1",
        "idx": 1750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n",
        "output": "0",
        "idx": 4562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DEFUN (clear_ip_bgp_as_soft_out,\n       clear_ip_bgp_as_soft_out_cmd,\n       \"clear ip bgp <1-65535> soft out\",\n       CLEAR_STR\n       IP_STR\n       BGP_STR\n       \"Clear peers with the AS number\\n\"\n       \"Soft reconfig\\n\"\n       \"Soft reconfig outbound update\\n\")\n{\n  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_as,\n\t\t\tBGP_CLEAR_SOFT_OUT, argv[0]);\n}",
        "output": "0",
        "idx": 1014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n",
        "output": "0",
        "idx": 3184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n",
        "output": "0",
        "idx": 1302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HandleRegisterDNSMessage(void)\n{\n    DWORD err;\n    HANDLE thread = NULL;\n\n    /* Delegate this job to a sub-thread */\n    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);\n\n    /*\n     * We don't add these thread handles to the undo list -- the thread and\n     * processes it spawns are all supposed to terminate or timeout by themselves.\n     */\n    if (thread)\n    {\n        err = 0;\n        CloseHandle(thread);\n    }\n    else\n    {\n        err = GetLastError();\n    }\n\n    return err;\n}",
        "output": "0",
        "idx": 2011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void abort_codec_experimental(AVCodec *c, int encoder)\n\n{\n\n    const char *codec_string = encoder ? \"encoder\" : \"decoder\";\n\n    AVCodec *codec;\n\n    av_log(NULL, AV_LOG_FATAL, \"%s '%s' is experimental and might produce bad \"\n\n            \"results.\\nAdd '-strict experimental' if you want to use it.\\n\",\n\n            codec_string, c->name);\n\n    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);\n\n    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))\n\n        av_log(NULL, AV_LOG_FATAL, \"Or use the non experimental %s '%s'.\\n\",\n\n               codec_string, codec->name);\n\n    exit(1);\n\n}\n",
        "output": "1",
        "idx": 4004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\n\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}",
        "output": "1",
        "idx": 5442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)\n{\n    return get_attribute(si->unauth_attr, nid);\n}",
        "output": "0",
        "idx": 971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void csrhci_reset(struct csrhci_s *s)\n\n{\n\n    s->out_len = 0;\n\n    s->out_size = FIFO_LEN;\n\n    s->in_len = 0;\n\n    s->baud_delay = NANOSECONDS_PER_SECOND;\n\n    s->enable = 0;\n\n    s->in_hdr = INT_MAX;\n\n    s->in_data = INT_MAX;\n\n\n\n    s->modem_state = 0;\n\n    /* After a while... (but sooner than 10ms) */\n\n    s->modem_state |= CHR_TIOCM_CTS;\n\n\n\n    memset(&s->bd_addr, 0, sizeof(bdaddr_t));\n\n}\n",
        "output": "1",
        "idx": 4083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltParseTemplateContent(xsltStylesheetPtr style, xmlNodePtr templ) {\n    if ((style == NULL) || (templ == NULL))\n\treturn;\n\n    /*\n    * Detection of handled content of extension instructions.\n    */\n    if (XSLT_CCTXT(style)->inode->category == XSLT_ELEMENT_CATEGORY_EXTENSION) {\n\tXSLT_CCTXT(style)->inode->extContentHandled = 1;\n    }\n\n    if (templ->children != NULL) {\t\n\txmlNodePtr child = templ->children;\n\t/*\n\t* Process xsl:param elements, which can only occur as the\n\t* immediate children of xsl:template (well, and of any\n\t* user-defined extension instruction if needed).\n\t*/\t\n\tdo {\n\t    if ((child->type == XML_ELEMENT_NODE) &&\n\t\tIS_XSLT_ELEM_FAST(child) &&\n\t\tIS_XSLT_NAME(child, \"param\"))\n\t    {\n\t\tXSLT_CCTXT(style)->inode->curChildType = XSLT_FUNC_PARAM;\n\t\txsltParseAnyXSLTElem(XSLT_CCTXT(style), child);\n\t    } else\n\t\tbreak;\n\t    child = child->next;\n\t} while (child != NULL);\n\t/*\n\t* Parse the content and register the pattern.\n\t*/\n\txsltParseSequenceConstructor(XSLT_CCTXT(style), child);\n    }\n}",
        "output": "1",
        "idx": 802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_CT_CLEAR(ofpacts);\n    return NULL;\n}",
        "output": "0",
        "idx": 3619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int isHLLObjectOrReply(client *c, robj *o) {\n    struct hllhdr *hdr;\n\n    /* Key exists, check type */\n    if (checkType(c,o,OBJ_STRING))\n        return C_ERR; /* Error already sent. */\n\n    if (!sdsEncodedObject(o)) goto invalid;\n    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;\n    hdr = o->ptr;\n\n    /* Magic should be \"HYLL\". */\n    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||\n        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;\n\n    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;\n\n    /* Dense representation string length should match exactly. */\n    if (hdr->encoding == HLL_DENSE &&\n        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;\n\n    /* All tests passed. */\n    return C_OK;\n\ninvalid:\n    addReplySds(c,\n        sdsnew(\"-WRONGTYPE Key is not a valid \"\n               \"HyperLogLog string value.\\r\\n\"));\n    return C_ERR;\n}",
        "output": "0",
        "idx": 1648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n                        char part[3][LINE_SZ], int part_size, int *print_prefix, int type[2])\n{\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n    part[0][0] = part[1][0] = part[2][0] = 0;\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n    if (*print_prefix && avc) {\n        if (avc->parent_log_context_offset) {\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n                                   avc->parent_log_context_offset);\n            if (parent && *parent) {\n                snprintf(part[0], part_size, \"[%s @ %p] \",\n                         (*parent)->item_name(parent), parent);\n                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);\n            }\n        }\n        snprintf(part[1], part_size, \"[%s @ %p] \",\n                 avc->item_name(ptr), ptr);\n        if(type) type[1] = get_category(ptr);\n    }\n\n    vsnprintf(part[2], part_size, fmt, vl);\n\n    if(*part[0] || *part[1] || *part[2])\n        *print_prefix = strlen(part[2]) && part[2][strlen(part[2]) - 1] == '\\n';\n}",
        "output": "1",
        "idx": 3677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}",
        "output": "1",
        "idx": 5292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n\n        return FALSE;\n}",
        "output": "1",
        "idx": 2737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void LogOpenCLBuildFailure(MagickCLDevice device,const char *kernel,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    *log;\n\n  size_t\n    log_size;\n\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.cl\");\n\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,kernel,strlen(kernel),exception);\n\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);\n  log=(char*)AcquireMagickMemory(log_size);\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);\n\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.log\");\n\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,log,log_size,exception);\n  log=(char*)RelinquishMagickMemory(log);\n}",
        "output": "1",
        "idx": 2253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n",
        "output": "1",
        "idx": 2731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,\n\n                              int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_64:\n\n        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n",
        "output": "0",
        "idx": 4138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n\n  register const double\n    *p;\n\n  register double\n    *q;\n\n  register ssize_t\n    i;\n\n  size_t\n    n;\n\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}",
        "output": "1",
        "idx": 6218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {\n  api::WebContents* api_web_contents = api::WebContents::From(web_contents());\n  if (api_web_contents) {\n    api_web_contents->SetTemporaryZoomLevel(level);\n  }\n}",
        "output": "1",
        "idx": 2924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut64 dwarf_read_address(size_t size, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\tcase 2:\n\t\tresult = READ16(*buf);\n\t\tbreak;\n\tcase 4:\n\t\tresult = READ32(*buf);\n\t\tbreak;\n\tcase 8:\n\t\tresult = READ64(*buf);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf(\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}",
        "output": "0",
        "idx": 295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\twhile (!(err = link_path_walk(s, nd))\n\t\t&& ((err = lookup_last(nd)) > 0)) {\n\t\ts = trailing_symlink(nd);\n\t\tif (IS_ERR(s)) {\n\t\t\terr = PTR_ERR(s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY)\n\t\tif (!d_can_lookup(nd->path.dentry))\n\t\t\terr = -ENOTDIR;\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}",
        "output": "0",
        "idx": 5573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void hda_codec_device_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *k = DEVICE_CLASS(klass);\n    k->realize = hda_codec_dev_realize;\n    k->unrealize = hda_codec_dev_unrealize;\n    set_bit(DEVICE_CATEGORY_SOUND, k->categories);\n    k->bus_type = TYPE_HDA_BUS;\n    device_class_set_props(k, hda_props);",
        "output": "0",
        "idx": 2726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n",
        "output": "1",
        "idx": 1267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n",
        "output": "1",
        "idx": 618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void napi_skb_free_stolen_head(struct sk_buff *skb)\n{\n\tskb_dst_drop(skb);\n\tsecpath_reset(skb);\n\tkmem_cache_free(skbuff_head_cache, skb);",
        "output": "0",
        "idx": 366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 6168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}",
        "output": "0",
        "idx": 235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)\n{\n  char *p = (char *)bits;\n  for (; *p; p++)\n    {\n      if (*p == '0' || *p == '1')\n        bit_write_B (dat, *p != '0');\n      else\n        {\n          fprintf (stderr, \"Invalid binary input %s\\n\", p);\n          return;\n        }\n    }\n}",
        "output": "0",
        "idx": 4615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)\n{\n\tconst struct auth_passdb *passdb;\n\n\tfor (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {\n\t\tif (passdb->passdb->iface.lookup_credentials != NULL)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
        "output": "0",
        "idx": 1759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}",
        "output": "1",
        "idx": 1878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "connection_changes_done (gpointer data)\n{\n\tConnectionChangedInfo *info = (ConnectionChangedInfo *) data;\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);\n\tNMAGConfConnection *connection;\n\n\tconnection = nma_gconf_settings_get_by_path (info->settings, info->path);\n\tif (!connection) {\n\t\t/* New connection */\n\t\tconnection = nma_gconf_connection_new (priv->client, info->path);\n\t\tadd_connection_real (info->settings, connection);\n\t} else {\n\t\tif (gconf_client_dir_exists (priv->client, info->path, NULL)) {\n\t\t\t/* Updated connection */\n\t\t\tif (!nma_gconf_connection_changed (connection))\n\t\t\t\tpriv->connections = g_slist_remove (priv->connections, connection);\n\t\t}\n\t}\n\n\tg_hash_table_remove (priv->pending_changes, info->path);\n\n\treturn FALSE;\n}",
        "output": "1",
        "idx": 5524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)\n{\n    int i;\n\n    trace_usb_xhci_slot_disable(slotid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    for (i = 1; i <= 31; i++) {\n        if (xhci->slots[slotid-1].eps[i-1]) {\n            xhci_disable_ep(xhci, slotid, i);\n        }\n    }\n\n    xhci->slots[slotid-1].enabled = 0;\n    xhci->slots[slotid-1].addressed = 0;\n    xhci->slots[slotid-1].uport = NULL;\n    return CC_SUCCESS;\n}",
        "output": "0",
        "idx": 916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n\n  const int nfilled = table.size();\n\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}",
        "output": "1",
        "idx": 2247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void writeBytes(const void* data, int length) {\n      check(length);\n      memcpy(ptr, data, length);\n      ptr += length;\n    }",
        "output": "1",
        "idx": 4027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}",
        "output": "1",
        "idx": 2917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mptcp_print(netdissect_options *ndo,\n            const u_char *cp, u_int len, u_char flags)\n{\n        const struct mptcp_option *opt;\n        u_int subtype;\n\n        if (len < 3)\n                return 0;\n\n        opt = (const struct mptcp_option *) cp;\n        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);\n\n        ND_PRINT((ndo, \" %s\", mptcp_options[subtype].name));\n        return mptcp_options[subtype].print(ndo, cp, len, flags);\n}",
        "output": "0",
        "idx": 1490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}",
        "output": "1",
        "idx": 6289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {\n    return authorizationManagerPinnedUsers.setFromString(str);\n}",
        "output": "0",
        "idx": 669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n",
        "output": "1",
        "idx": 5796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp)\n{\n  unsigned long long retval = 0;\n  int mcuw, mcuh, chromasf;\n\n  if (width < 1 || height < 1 || jpegSubsamp < 0 || jpegSubsamp >= NUMSUBOPT)\n    THROWG(\"tjBufSize(): Invalid argument\");\n\n  /* This allows for rare corner cases in which a JPEG image can actually be\n     larger than the uncompressed input (we wouldn't mention it if it hadn't\n     happened before.) */\n  mcuw = tjMCUWidth[jpegSubsamp];\n  mcuh = tjMCUHeight[jpegSubsamp];\n  chromasf = jpegSubsamp == TJSAMP_GRAY ? 0 : 4 * 64 / (mcuw * mcuh);\n  retval = PAD(width, mcuw) * PAD(height, mcuh) * (2ULL + chromasf) + 2048ULL;\n  if (retval > (unsigned long long)((unsigned long)-1))\n    THROWG(\"tjBufSize(): Image is too large\");\n\nbailout:\n  return (unsigned long)retval;\n}",
        "output": "0",
        "idx": 117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n",
        "output": "0",
        "idx": 2823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n",
        "output": "1",
        "idx": 5777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}",
        "output": "1",
        "idx": 5409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qmp_input_pop(Visitor *v, void **obj)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && tos->qapi == obj);\n\n    QSLIST_REMOVE_HEAD(&qiv->stack, node);\n\n    qmp_input_stack_object_free(tos);\n\n}\n",
        "output": "0",
        "idx": 5205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, getIteratorMode)\n{\n\tspl_dllist_object *intern;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tRETURN_LONG(intern->flags);\n}",
        "output": "0",
        "idx": 3547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_user_file (const char *filename,\n                 uid_t       user,\n                 gssize      max_file_size,\n                 gboolean    relax_group,\n                 gboolean    relax_other)\n{\n        struct stat fileinfo;\n\n        if (max_file_size < 0) {\n                max_file_size = G_MAXSIZE;\n        }\n\n        /* Exists/Readable? */\n        if (stat (filename, &fileinfo) < 0) {\n                return FALSE;\n        }\n\n        /* Is a regular file */\n        if (G_UNLIKELY (!S_ISREG (fileinfo.st_mode))) {\n                return FALSE;\n        }\n\n        /* Owned by user? */\n        if (G_UNLIKELY (fileinfo.st_uid != user)) {\n                return FALSE;\n        }\n\n        /* Group not writable or relax_group? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWGRP) == S_IWGRP && !relax_group)) {\n                return FALSE;\n        }\n\n        /* Other not writable or relax_other? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWOTH) == S_IWOTH && !relax_other)) {\n                return FALSE;\n        }\n\n        /* Size is kosher? */\n        if (G_UNLIKELY (fileinfo.st_size > max_file_size)) {\n                return FALSE;\n        }\n\n        return TRUE;\n}",
        "output": "1",
        "idx": 2213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n",
        "output": "1",
        "idx": 2508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                        const uint8_t **poutbuf, int *poutbuf_size,\n\n                        const uint8_t *buf, int buf_size)\n\n{\n\n    VorbisParseContext *s = s1->priv_data;\n\n    int duration;\n\n\n\n    if (!s->vp && avctx->extradata && avctx->extradata_size) {\n\n        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);\n\n        if (!s->vp)\n\n            goto end;\n\n    }\n\n\n\n    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)\n\n        s1->duration = duration;\n\n\n\nend:\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only packet analysis */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n",
        "output": "1",
        "idx": 1227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n\n{\n\n    int rd, rt, dsp;\n\n    int result, resultdsp;\n\n\n\n    rt        = 0x12345678;\n\n    result    = 0xA000C000;\n\n    resultdsp = 1;\n\n\n\n    __asm\n\n        (\"shll.ph %0, %2, 0x0B\\n\\t\"\n\n         \"rddsp %1\\n\\t\"\n\n         : \"=r\"(rd), \"=r\"(dsp)\n\n         : \"r\"(rt)\n\n        );\n\n    dsp = (dsp >> 22) & 0x01;\n\n    assert(dsp == resultdsp);\n\n    assert(rd  == result);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void io_uring_clean_tctx(struct io_uring_task *tctx)\n{\n\tstruct file *file;\n\tunsigned long index;\n\n\txa_for_each(&tctx->xa, index, file)\n\t\tio_uring_del_task_file(file);\n\tif (tctx->io_wq) {\n\t\tio_wq_put_and_exit(tctx->io_wq);\n\t\ttctx->io_wq = NULL;\n\t}",
        "output": "0",
        "idx": 3937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMA_CC_Unmarshal(TPMA_CC *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal((UINT32 *)target, buffer, size); /* libtpms changed */\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (*target & TPMA_CC_reserved) {\n\t    rc = TPM_RC_RESERVED_BITS;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 5706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {\n  Isolate* isolate = env()->isolate();\n  HandleScope scope(isolate);\n  Local<Context> context = env()->context();\n  Context::Scope context_scope(context);\n\n  nghttp2_goaway goaway_frame = frame->goaway;\n  Debug(this, \"handling goaway frame\");\n\n  Local<Value> argv[3] = {\n    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),\n    Integer::New(isolate, goaway_frame.last_stream_id),\n    Undefined(isolate)\n  };\n\n  size_t length = goaway_frame.opaque_data_len;\n  if (length > 0) {\n    // If the copy fails for any reason here, we just ignore it.\n    // The additional goaway data is completely optional and we\n    // shouldn't fail if we're not able to process it.\n    argv[2] = Buffer::Copy(isolate,\n                           reinterpret_cast<char*>(goaway_frame.opaque_data),\n                           length).ToLocalChecked();\n  }\n\n  MakeCallback(env()->http2session_on_goaway_data_function(),\n               arraysize(argv), argv);\n}",
        "output": "0",
        "idx": 5355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\n\tmutex_unlock(&econet_mutex);\n\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}",
        "output": "1",
        "idx": 5812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setsection(ns_msg *msg, ns_sect sect)\n{\n\tmsg->_sect = sect;\n\tif (sect == ns_s_max) {\n\t\tmsg->_rrnum = -1;\n\t\tmsg->_ptr = NULL;\n\t} else {\n\t\tmsg->_rrnum = 0;\n\t\tmsg->_ptr = msg->_sections[(int)sect];\n\t}\n}",
        "output": "0",
        "idx": 1011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n\n    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1), multikeyPaths);\n    runQuery(fromjson(\"{a: {$ne: 3}, b: 2}\"));\n\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, \"\n        \"bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], \"\n        \"b: [[2, 2, true, true]]}}}}}\");\n}",
        "output": "0",
        "idx": 3448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int reuc_isrch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcasecmp(key, reuc->path);\n}",
        "output": "0",
        "idx": 701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qobject_incref(*obj);\n\n    qmp_output_add_obj(qov, name, *obj);\n\n}\n",
        "output": "0",
        "idx": 5575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n",
        "output": "1",
        "idx": 2728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_fc_log(struct fs_context *fc)\n{\n\tstruct fc_log *log = fc->log.log;\n\tint i;\n\n\tif (log) {\n\t\tif (refcount_dec_and_test(&log->usage)) {\n\t\t\tfc->log.log = NULL;\n\t\t\tfor (i = 0; i <= 7; i++)\n\t\t\t\tif (log->need_free & (1 << i))\n\t\t\t\t\tkfree(log->buffer[i]);\n\t\t\tkfree(log);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 2489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SetXtermOSC(i, s)\nint i;\nchar *s;\n{\n  static char *oscs[][2] = {\n    { WT_FLAG \";\", \"screen\" }, /* set window title */\n    { \"20;\", \"\" },      /* background */\n    { \"39;\", \"black\" }, /* default foreground (black?) */\n    { \"49;\", \"white\" }  /* default background (white?) */\n  };\n\n  ASSERT(display);\n  if (!D_CXT)\n    return;\n  if (!s)\n    s = \"\";\n  if (!D_xtermosc[i] && !*s)\n    return;\n  if (i == 0 && !D_xtermosc[0])\n    AddStr(\"\\033[22;\" WT_FLAG \"t\");\t/* stack titles (xterm patch #251) */\n  if (!*s)\n    s = oscs[i][1];\n  D_xtermosc[i] = 1;\n  AddStr(\"\\033]\");\n  AddStr(oscs[i][0]);\n  AddStr(s);\n  AddChar(7);\n}",
        "output": "1",
        "idx": 3993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "io_set_process_status(mrb_state *mrb, pid_t pid, int status)\n{\n  struct RClass *c_process, *c_status;\n  mrb_value v;\n\n  c_status = NULL;\n  if (mrb_class_defined(mrb, \"Process\")) {\n    c_process = mrb_module_get(mrb, \"Process\");\n    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, \"Status\"))) {\n      c_status = mrb_class_get_under(mrb, c_process, \"Status\");\n    }\n  }\n  if (c_status != NULL) {\n    v = mrb_funcall(mrb, mrb_obj_value(c_status), \"new\", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));\n  } else {\n    v = mrb_fixnum_value(WEXITSTATUS(status));\n  }\n  mrb_gv_set(mrb, mrb_intern_cstr(mrb, \"$?\"), v);\n}",
        "output": "0",
        "idx": 1496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *trgt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}",
        "output": "0",
        "idx": 1875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}",
        "output": "1",
        "idx": 6180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)\n{\n\tMonoJitICallInfo *info;\n\t\n\tg_assert (func);\n\tg_assert (name);\n\n\tmono_loader_lock ();\n\n\tif (!jit_icall_hash_name) {\n\t\tjit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);\n\t\tjit_icall_hash_addr = g_hash_table_new (NULL, NULL);\n\t}\n\n\tif (g_hash_table_lookup (jit_icall_hash_name, name)) {\n\t\tg_warning (\"jit icall already defined \\\"%s\\\"\\n\", name);\n\t\tg_assert_not_reached ();\n\t}\n\n\tinfo = g_new0 (MonoJitICallInfo, 1);\n\t\n\tinfo->name = name;\n\tinfo->func = func;\n\tinfo->sig = sig;\n\n\tif (is_save) {\n\t\tinfo->wrapper = func;\n\t} else {\n\t\tinfo->wrapper = NULL;\n\t}\n\n\tg_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);\n\tg_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);\n\n\tmono_loader_unlock ();\n\treturn info;\n}",
        "output": "0",
        "idx": 3412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n",
        "output": "0",
        "idx": 3517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int normalize_bits(int num, int width)\n\n{\n\n    if (!num)\n\n        return 0;\n\n    if (num == -1)\n\n        return width;\n\n    if (num < 0)\n\n        num = ~num;\n\n\n\n    return width - av_log2(num);\n\n}\n",
        "output": "1",
        "idx": 4828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx\n\t\t\t\t\t int color,\n\t\t\t\t\t int *r, int *g, int *b)\n{\n    return _nc_color_content(SP_PARM, color, r, g, b);\n}",
        "output": "0",
        "idx": 5506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int request_frame(AVFilterLink *link)\n\n{\n\n    AVFilterContext *ctx = link->src;\n\n    IDETContext *idet = ctx->priv;\n\n\n\n    do {\n\n        int ret;\n\n\n\n        if (idet->eof)\n\n            return AVERROR_EOF;\n\n\n\n        ret = ff_request_frame(link->src->inputs[0]);\n\n\n\n        if (ret == AVERROR_EOF && idet->cur) {\n\n            AVFrame *next = av_frame_clone(idet->next);\n\n\n\n            if (!next)\n\n                return AVERROR(ENOMEM);\n\n\n\n            filter_frame(link->src->inputs[0], next);\n\n            idet->eof = 1;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (!idet->cur);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void esp_fifo_push(ESPState *s, uint8_t val)\n{\n    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {\n        trace_esp_error_fifo_overrun();\n        return;\n    }\n\n    fifo8_push(&s->fifo, val);\n}",
        "output": "1",
        "idx": 4893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "option_was_set(char_u *name)\n{\n    int idx;\n\n    idx = findoption(name);\n    if (idx < 0)\t/* unknown option */\n\treturn FALSE;\n    if (options[idx].flags & P_WAS_SET)\n\treturn TRUE;\n    return FALSE;\n}",
        "output": "0",
        "idx": 5002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}",
        "output": "1",
        "idx": 2793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 4593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}",
        "output": "1",
        "idx": 4899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "has_system_location (GPtrArray  *locations,\n                     const char *id)\n{\n  int i;\n\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)\n        return TRUE;\n    }\n\n  return FALSE;\n}",
        "output": "0",
        "idx": 4112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AbstractSqlStorage::addConnectionToPool()\n{\n    QMutexLocker locker(&_connectionPoolMutex);\n    // we have to recheck if the connection pool already contains a connection for\n    // this thread. Since now (after the lock) we can only tell for sure\n    if (_connectionPool.contains(QThread::currentThread()))\n        return;\n\n    QThread *currentThread = QThread::currentThread();\n\n    int connectionId = _nextConnectionId++;\n\n    Connection *connection = new Connection(QLatin1String(QString(\"quassel_%1_con_%2\").arg(driverName()).arg(connectionId).toLatin1()));\n    connection->moveToThread(currentThread);\n    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));\n    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));\n    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));\n    _connectionPool[currentThread] = connection;\n\n    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());\n    db.setDatabaseName(databaseName());\n\n    if (!hostName().isEmpty())\n        db.setHostName(hostName());\n\n    if (port() != -1)\n        db.setPort(port());\n\n    if (!userName().isEmpty()) {\n        db.setUserName(userName());\n        db.setPassword(password());\n    }\n\n    if (!db.open()) {\n        qWarning() << \"Unable to open database\" << displayName() << \"for thread\" << QThread::currentThread();\n        qWarning() << \"-\" << db.lastError().text();\n    }\n    else {\n        initDbSession(db);\n    }\n}",
        "output": "1",
        "idx": 3572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    block_job_set_speed(job, speed, errp);\n\n}\n",
        "output": "0",
        "idx": 6255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 6095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void file_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\ttree_difference = REV_TREE_DIFFERENT;\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "output": "1",
        "idx": 5906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_qemu_strtoul_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n",
        "output": "1",
        "idx": 4683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n",
        "output": "0",
        "idx": 6092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int is_same_network(struct ieee80211_network *src,\n\t\t\t\t  struct ieee80211_network *dst)\n{\n\t/* A network is only a duplicate if the channel, BSSID, and ESSID\n\t * all match.  We treat all <hidden> with the same BSSID and channel\n\t * as one network */\n\treturn ((src->ssid_len == dst->ssid_len) &&\n\t\t(src->channel == dst->channel) &&\n\t\t!compare_ether_addr(src->bssid, dst->bssid) &&\n\t\t!memcmp(src->ssid, dst->ssid, src->ssid_len));\n}",
        "output": "0",
        "idx": 3367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ldb_kv_index_unique(struct ldb_context *ldb,\n\t\t\t\tstruct ldb_kv_private *ldb_kv,\n\t\t\t\tconst char *attr)\n{\n\tconst struct ldb_schema_attribute *a;\n\tif (ldb_kv->cache->GUID_index_attribute != NULL) {\n\t\tif (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==\n\t\t    0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (ldb_attr_dn(attr) == 0) {\n\t\treturn true;\n\t}\n\n\ta = ldb_schema_attribute_by_name(ldb, attr);\n\tif (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 3978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n\n\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}",
        "output": "1",
        "idx": 4386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n",
        "output": "0",
        "idx": 4052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n",
        "output": "0",
        "idx": 5374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "output": "1",
        "idx": 4964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t get_bit_rate(AVCodecContext *ctx)\n\n{\n\n    int64_t bit_rate;\n\n    int bits_per_sample;\n\n\n\n    switch (ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n    case AVMEDIA_TYPE_DATA:\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n    case AVMEDIA_TYPE_ATTACHMENT:\n\n        bit_rate = ctx->bit_rate;\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n\n        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;\n\n        break;\n\n    default:\n\n        bit_rate = 0;\n\n        break;\n\n    }\n\n    return bit_rate;\n\n}\n",
        "output": "1",
        "idx": 3103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_match_charset(\n    FontData\tfont_data,\n    char\t*font_name)\n{\n    char *last;\n    int length, name_len;\n\n    name_len = strlen(font_name);\n    last = font_name + name_len;\n\n    length = strlen(font_data->name);\n    if (length > name_len)\n\treturn False;\n\n    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)\n\treturn True;\n\n    return False;\n}",
        "output": "0",
        "idx": 2181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n",
        "output": "1",
        "idx": 4412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)\n\n{\n\n    double units = 1.0;\n\n\n\n    /* if cfg.op_size is defined and smaller than size we compute unit count */\n\n    if (ts->cfg.op_size && size > ts->cfg.op_size) {\n\n        units = (double) size / ts->cfg.op_size;\n\n    }\n\n\n\n    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;\n\n    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;\n\n\n\n    if (is_write) {\n\n        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;\n\n    } else {\n\n        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n",
        "output": "1",
        "idx": 4641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int au_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 24)\n\n        return 0;\n\n    if (p->buf[0] == '.' && p->buf[1] == 's' &&\n\n        p->buf[2] == 'n' && p->buf[3] == 'd')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n",
        "output": "0",
        "idx": 2154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool device_path_matched(const char *path, struct btrfs_device *device)\n{\n\tint found;\n\n\trcu_read_lock();\n\tfound = strcmp(rcu_str_deref(device->name), path);\n\trcu_read_unlock();\n\n\treturn found == 0;\n}",
        "output": "0",
        "idx": 1099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *errp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}\n",
        "output": "0",
        "idx": 5254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n",
        "output": "1",
        "idx": 3083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)\n{\n    Q_UNUSED(bufferInfo);\n    if (!msg.contains(' '))\n        return;\n\n    QString target = msg.section(' ', 0, 0);\n    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n#else\n    putPrivmsg(serverEncode(target), encMsg);\n#endif\n}",
        "output": "1",
        "idx": 2243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)\n\n{\n\n    int bit;\n\n\n\n    if(s->extra_bits){\n\n        S <<= s->extra_bits;\n\n\n\n        if(s->got_extra_bits){\n\n            S |= get_bits(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);\n\n        }\n\n    }\n\n    bit = (S & s->and) | s->or;\n\n    return (((S + bit) << s->shift) - bit) << s->post_shift;\n\n}\n",
        "output": "1",
        "idx": 1903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n\n\n\n        do {\n\n            out[x] = 0.0;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}",
        "output": "1",
        "idx": 3374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n",
        "output": "0",
        "idx": 2106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)\n{\n\tchar buf[MAXPATHLEN];\n\tstruct stat sbuf;\n\n\tif (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {\n\t\treturn FAILURE;\n\t}\n\tif (VCWD_STAT(buf, &sbuf)) {\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}",
        "output": "0",
        "idx": 623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Cached_item_field(Item_field *item)\n  {\n    field= item->field;\n    buff= (uchar*) sql_calloc(length=field->pack_length());\n  }",
        "output": "0",
        "idx": 4045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n",
        "output": "1",
        "idx": 1102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int restore_altivec(struct task_struct *tsk) { return 0; }",
        "output": "1",
        "idx": 4471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\t/* If the file has inline data, try to read it directly */\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);\n\treturn ret;\n}",
        "output": "1",
        "idx": 3869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n\n{\n\n    unsigned access_size_min = mr->ops->impl.min_access_size;\n\n    unsigned access_size_max = mr->ops->impl.max_access_size;\n\n\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n\n       otherwise specified.  */\n\n    if (access_size_min == 0) {\n\n        access_size_min = 1;\n\n    }\n\n    if (access_size_max == 0) {\n\n        access_size_max = 4;\n\n    }\n\n\n\n    /* Bound the maximum access by the alignment of the address.  */\n\n    if (!mr->ops->impl.unaligned) {\n\n        unsigned align_size_max = addr & -addr;\n\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n\n            access_size_max = align_size_max;\n\n        }\n\n    }\n\n\n\n    /* Don't attempt accesses larger than the maximum.  */\n\n    if (l > access_size_max) {\n\n        l = access_size_max;\n\n    }\n\n    /* ??? The users of this function are wrong, not supporting minimums larger\n\n       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */\n\n    assert(l >= access_size_min);\n\n\n\n    return l;\n\n}\n",
        "output": "1",
        "idx": 3437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Supports_Condition_Obj Parser::parse_supports_declaration()\n  {\n    Supports_Condition_Ptr cond;\n    // parse something declaration like\n    Expression_Obj feature = parse_expression();\n    Expression_Obj expression;\n    if (lex_css< exactly<':'> >()) {\n      expression = parse_list(DELAYED);\n    }\n    if (!feature || !expression) error(\"@supports condition expected declaration\");\n    cond = SASS_MEMORY_NEW(Supports_Declaration,\n                     feature->pstate(),\n                     feature,\n                     expression);\n    // ToDo: maybe we need an additional error condition?\n    return cond;\n  }",
        "output": "0",
        "idx": 545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n\n                                 bool query_backing)\n\n{\n\n    BlockStats *s = NULL;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n    s->stats = g_malloc0(sizeof(*s->stats));\n\n\n\n    if (!bs) {\n\n        return s;\n\n    }\n\n\n\n    if (bdrv_get_node_name(bs)[0]) {\n\n        s->has_node_name = true;\n\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n\n    }\n\n\n\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n\n\n\n    if (bs->file) {\n\n        s->has_parent = true;\n\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n\n    }\n\n\n\n    if (query_backing && bs->backing) {\n\n        s->has_backing = true;\n\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n\n    }\n\n\n\n    return s;\n\n}\n",
        "output": "1",
        "idx": 4694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nvenc_find_free_reg_resource(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;\n\n    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;\n\n\n\n    int i;\n\n\n\n    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {\n\n        for (i = 0; i < ctx->nb_registered_frames; i++) {\n\n            if (!ctx->registered_frames[i].mapped) {\n\n                if (ctx->registered_frames[i].regptr) {\n\n                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,\n\n                                                ctx->registered_frames[i].regptr);\n\n                    ctx->registered_frames[i].regptr = NULL;\n\n                }\n\n                return i;\n\n            }\n\n        }\n\n    } else {\n\n        return ctx->nb_registered_frames++;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR, \"Too many registered CUDA frames\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n",
        "output": "0",
        "idx": 2850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "        compression::algorithm compression_algorithm()\n        {\n            return comp_algorithm_;\n        }",
        "output": "0",
        "idx": 1507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n",
        "output": "1",
        "idx": 2258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "S3BootScriptSaveInformation (\r\n  IN  UINT32                                InformationLength,\r\n  IN  VOID                                 *Information\r\n  )\r\n{\r\n  UINT8                 Length;\r\n  UINT8                 *Script;\r\n  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;\r\n\r\n  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (Length);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  //\r\n  // Build script data\r\n  //\r\n  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;\r\n  ScriptInformation.Length     = Length;\r\n\r\n\r\n  ScriptInformation.InformationLength = InformationLength;\r\n\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));\r\n  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return RETURN_SUCCESS;\r\n\r\n}\r",
        "output": "1",
        "idx": 385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n",
        "output": "1",
        "idx": 176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int no_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}",
        "output": "1",
        "idx": 4951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 6076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n\t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n\t\t */\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}",
        "output": "1",
        "idx": 4182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n",
        "output": "0",
        "idx": 5607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n",
        "output": "0",
        "idx": 209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}",
        "output": "1",
        "idx": 5629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {\n  initialize();\n\n  EXPECT_THROW(request_encoder_->encodeHeaders(TestRequestHeaderMapImpl{}, true), ServerCodecError);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}",
        "output": "1",
        "idx": 2906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_mclms(WmallDecodeCtx *s)\n\n{\n\n    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;\n\n    s->mclms_scaling = get_bits(&s->gb, 4);\n\n    if(get_bits1(&s->gb)) {\n\n\t// mclms_send_coef\n\n\tint i;\n\n\tint send_coef_bits;\n\n\tint cbits = av_log2(s->mclms_scaling + 1);\n\n\tassert(cbits == my_log2(s->mclms_scaling + 1));\n\n\tif(1 << cbits < s->mclms_scaling + 1)\n\n\t    cbits++;\n\n\n\n\tsend_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;\n\n\n\n\tfor(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {\n\n\t    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);\n\n\t}\n\n\n\n\tfor(i = 0; i < s->num_channels; i++) {\n\n\t    int c;\n\n\t    for(c = 0; c < i; c++) {\n\n\t\ts->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);\n\n\t    }\n\n\t}\n\n    }\n\n}\n",
        "output": "1",
        "idx": 186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmp_addr_policies(smartlist_t *a, smartlist_t *b)\n{\n  int r, i;\n  int len_a = a ? smartlist_len(a) : 0;\n  int len_b = b ? smartlist_len(b) : 0;\n\n  for (i = 0; i < len_a && i < len_b; ++i) {\n    if ((r = cmp_single_addr_policy(smartlist_get(a, i), smartlist_get(b, i))))\n      return r;\n  }\n  if (i == len_a && i == len_b)\n    return 0;\n  if (i < len_a)\n    return -1;\n  else\n    return 1;\n}",
        "output": "1",
        "idx": 6043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,\n\n                                         src - (stride * 2) +\n\n                                         sizeof(uint8_t), stride, dst, stride);\n\n}\n",
        "output": "0",
        "idx": 3226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_str_center(argc, argv, str)\n    int argc;\n    VALUE *argv;\n    VALUE str;\n{\n    return rb_str_justify(argc, argv, str, 'c');\n}",
        "output": "0",
        "idx": 3765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int getClientTypeByName(char *name) {\n    if (!strcasecmp(name,\"normal\")) return CLIENT_TYPE_NORMAL;\n    else if (!strcasecmp(name,\"slave\")) return CLIENT_TYPE_SLAVE;\n    else if (!strcasecmp(name,\"pubsub\")) return CLIENT_TYPE_PUBSUB;\n    else if (!strcasecmp(name,\"master\")) return CLIENT_TYPE_MASTER;\n    else return -1;\n}",
        "output": "0",
        "idx": 4491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 1405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n",
        "output": "0",
        "idx": 1397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void merge_unsafe_rollback_flags()\n  {\n    if (transaction.stmt.modified_non_trans_table)\n      transaction.all.modified_non_trans_table= TRUE;\n    transaction.all.m_unsafe_rollback_flags|=\n      (transaction.stmt.m_unsafe_rollback_flags &\n       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |\n        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |\n        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |\n        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));\n  }",
        "output": "0",
        "idx": 5021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void memory_global_dirty_log_stop(void)\n\n{\n\n    global_dirty_log = false;\n\n\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n\n    memory_region_transaction_begin();\n\n    memory_region_update_pending = true;\n\n    memory_region_transaction_commit();\n\n\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n\n}\n",
        "output": "0",
        "idx": 6178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct kobject *device_to_dev_kobj(struct device *dev)\n{\n\tstruct kobject *kobj;\n\n\tif (dev->class)\n\t\tkobj = dev->class->dev_kobj;\n\telse\n\t\tkobj = sysfs_dev_char_kobj;\n\n\treturn kobj;\n}",
        "output": "0",
        "idx": 1696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\n\treturn prog;\n}",
        "output": "1",
        "idx": 4882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t read_ts(char **line, int *duration)\n\n{\n\n    int64_t start, end;\n\n\n\n    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {\n\n        *line += strcspn(*line, \"\\\"\") + 1;\n\n        *duration = end - start;\n\n        return start;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n",
        "output": "1",
        "idx": 5994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iperf_get_control_socket(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck;\n}",
        "output": "0",
        "idx": 3984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)\n{\n  int ph, nc, retval = 0;\n\n  if (height < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    _throwg(\"tjPlaneHeight(): Invalid argument\");\n  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);\n  if (componentID < 0 || componentID >= nc)\n    _throwg(\"tjPlaneHeight(): Invalid argument\");\n\n  ph = PAD(height, tjMCUHeight[subsamp] / 8);\n  if (componentID == 0)\n    retval = ph;\n  else\n    retval = ph * 8 / tjMCUHeight[subsamp];\n\nbailout:\n  return retval;\n}",
        "output": "0",
        "idx": 2686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *args = NULL;\n\tphp_com_dotnet_object *obj = (php_com_dotnet_object*)object;\n\tint nargs;\n\tVARIANT v;\n\tint ret = FAILURE;\n\n\tif (V_VT(&obj->v) != VT_DISPATCH) {\n\t\treturn FAILURE;\n\t}\n\n\tnargs = ZEND_NUM_ARGS();\n\n\tif (nargs) {\n\t\targs = (zval *)safe_emalloc(sizeof(zval), nargs, 0);\n\t\tzend_get_parameters_array_ex(nargs, args);\n\t}\n\n\tVariantInit(&v);\n\n\tif (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {\n\t\tphp_com_zval_from_variant(return_value, &v, obj->code_page);\n\t\tret = SUCCESS;\n\t\tVariantClear(&v);\n\t}\n\n\tif (args) {\n\t\tefree(args);\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    buffer_verify(buffer);\n\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (buffer->used + len < len) {\n        return -1;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}",
        "output": "1",
        "idx": 2611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
        "output": "0",
        "idx": 714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void op_cp1_registers(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n",
        "output": "0",
        "idx": 2170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *zrle_convert_fb(VncState *vs, int x, int y, int w, int h,\n                             int bpp)\n{\n    Buffer tmp;\n\n    buffer_reset(&vs->zrle.fb);\n    buffer_reserve(&vs->zrle.fb, w * h * bpp + bpp);\n\n    tmp = vs->output;\n    vs->output = vs->zrle.fb;\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vs->zrle.fb = vs->output;\n    vs->output = tmp;\n    return vs->zrle.fb.buffer;\n}",
        "output": "1",
        "idx": 1817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n\n{\n\n    int hours, minutes, seconds;\n\n\n\n    if (!show_bits(gb, 23)) {\n\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hours   = get_bits(gb, 5);\n\n    minutes = get_bits(gb, 6);\n\n    skip_bits1(gb);\n\n    seconds = get_bits(gb, 6);\n\n\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n\n\n    skip_bits1(gb);\n\n    skip_bits1(gb);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n",
        "output": "0",
        "idx": 3266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,\n\t\t\t      int len)\n{\n\tstruct sockaddr_in sin;\n\tint ret = 0;\n\n\t/* racing with another thread binding seems ok here */\n\tif (rs->rs_bound_addr == 0) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (len < sizeof(struct sockaddr_in)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&sin, optval, sizeof(sin))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trds_send_drop_to(rs, &sin);\nout:\n\treturn ret;\n}",
        "output": "0",
        "idx": 3956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TryReuseIndex(Oid oldId, IndexStmt *stmt)\n{\n\tif (CheckIndexCompatible(oldId,\n\t\t\t\t\t\t\t stmt->relation,\n\t\t\t\t\t\t\t stmt->accessMethod,\n\t\t\t\t\t\t\t stmt->indexParams,\n\t\t\t\t\t\t\t stmt->excludeOpNames))\n\t{\n\t\tRelation\tirel = index_open(oldId, NoLock);\n\n\t\tstmt->oldNode = irel->rd_node.relNode;\n\t\tindex_close(irel, NoLock);\n\t}\n}",
        "output": "1",
        "idx": 672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n",
        "output": "1",
        "idx": 3092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _CONSTRUCTOR lib_init(void)\n{\nint ret;\nconst char *e;\n\n\tif (_gnutls_global_init_skip() != 0)\n\t\treturn;\n\n\te = getenv(\"GNUTLS_NO_EXPLICIT_INIT\");\n\tif (e != NULL) {\n\t\tret = atoi(e);\n\t\tif (ret == 1)\n\t\t\treturn;\n\t}\n\n\tret = gnutls_global_init();\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error in GnuTLS initialization: %s\\n\", gnutls_strerror(ret));\n\t\t_gnutls_switch_lib_state(LIB_STATE_ERROR);\n\t}\n}",
        "output": "1",
        "idx": 2751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, \n        unsigned char * OffsetBase, unsigned ExifLength)\n{\n    if (strstr(ImageInfo.CameraMake, \"Canon\")){\n        // So it turns out that some canons cameras use big endian, others use little\n        // endian in the main exif header.  But the maker note is always little endian.\n        static int MotorolaOrderSave;\n        MotorolaOrderSave = MotorolaOrder;\n        MotorolaOrder = 0; // Temporarily switch to little endian.\n        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);\n        MotorolaOrder = MotorolaOrderSave;\n    }else{\n        if (ShowTags){\n            ShowMakerNoteGeneric(ValuePtr, ByteCount);\n        }\n    }\n}",
        "output": "0",
        "idx": 5634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_grow_inner(garray_T *gap, int n)\n{\n    size_t\told_len;\n    size_t\tnew_len;\n    char_u\t*pp;\n\n    if (n < gap->ga_growsize)\n\tn = gap->ga_growsize;\n\n    // A linear growth is very inefficient when the array grows big.  This\n    // is a compromise between allocating memory that won't be used and too\n    // many copy operations. A factor of 1.5 seems reasonable.\n    if (n < gap->ga_len / 2)\n\tn = gap->ga_len / 2;\n\n    new_len = gap->ga_itemsize * (gap->ga_len + n);\n    pp = vim_realloc(gap->ga_data, new_len);\n    if (pp == NULL)\n\treturn FAIL;\n    old_len = gap->ga_itemsize * gap->ga_maxlen;\n    vim_memset(pp + old_len, 0, new_len - old_len);\n    gap->ga_maxlen = gap->ga_len + n;\n    gap->ga_data = pp;\n    return OK;\n}",
        "output": "0",
        "idx": 2465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n",
        "output": "0",
        "idx": 2100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}",
        "output": "0",
        "idx": 3119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static errno_t sssctl_manage_service(enum sssctl_svc_action action)\n{\n#ifdef HAVE_SYSTEMD\n    switch (action) {\n    case SSSCTL_SVC_START:\n        return sssctl_systemd_start();\n    case SSSCTL_SVC_STOP:\n        return sssctl_systemd_stop();\n    case SSSCTL_SVC_RESTART:\n        return sssctl_systemd_restart();\n    }\n#elif defined(HAVE_SERVICE)\n    switch (action) {\n    case SSSCTL_SVC_START:\n        return sssctl_run_command(SERVICE_PATH\" sssd start\");\n    case SSSCTL_SVC_STOP:\n        return sssctl_run_command(SERVICE_PATH\" sssd stop\");\n    case SSSCTL_SVC_RESTART:\n        return sssctl_run_command(SERVICE_PATH\" sssd restart\");\n    }\n#endif\n\n    return ENOSYS;\n}",
        "output": "1",
        "idx": 5596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)\n\n{\n\n    MpegTSFilter *tss;\n\n    PESContext *pes;\n\n\n\n    /* if no pid found, then add a pid context */\n\n    pes = av_mallocz(sizeof(PESContext));\n\n    if (!pes)\n\n        return 0;\n\n    pes->ts = ts;\n\n    pes->stream = ts->stream;\n\n    pes->pid = pid;\n\n    pes->pcr_pid = pcr_pid;\n\n    pes->stream_type = stream_type;\n\n    pes->state = MPEGTS_SKIP;\n\n    pes->pts = AV_NOPTS_VALUE;\n\n    pes->dts = AV_NOPTS_VALUE;\n\n    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);\n\n    if (!tss) {\n\n        av_free(pes);\n\n        return 0;\n\n    }\n\n    return pes;\n\n}\n",
        "output": "0",
        "idx": 2645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {\n\tconst color_t *tp = InfoOf(sp).defaultPalette;\n\n\tTR(TRACE_ATTRS,\n\t   (\"initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)\",\n\t    pair,\n\t    tp[f].red, tp[f].green, tp[f].blue,\n\t    tp[b].red, tp[b].green, tp[b].blue));\n\n\tNCURSES_PUTP2(\"initialize_pair\",\n\t\t      TPARM_7(initialize_pair,\n\t\t\t      pair,\n\t\t\t      tp[f].red, tp[f].green, tp[f].blue,\n\t\t\t      tp[b].red, tp[b].green, tp[b].blue));\n    }\n}",
        "output": "1",
        "idx": 6230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)\n{\n\text4_fsblk_t block = ext4_ext_pblock(ext);\n\tint len = ext4_ext_get_actual_len(ext);\n\text4_lblk_t lblock = le32_to_cpu(ext->ee_block);\n\n\t/*\n\t * We allow neither:\n\t *  - zero length\n\t *  - overflow/wrap-around\n\t */\n\tif (lblock + len <= lblock)\n\t\treturn 0;\n\treturn ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);\n}",
        "output": "1",
        "idx": 305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t\t\t     struct timespec64 *ts, enum hrtimer_mode mode)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_cancel_data cd = { .data = user_data, };\n\tstruct io_kiocb *req = io_timeout_extract(ctx, &cd);\n\tstruct io_timeout_data *data;\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->timeout.off = 0; /* noseq */\n\tdata = req->async_data;\n\tlist_add_tail(&req->timeout.list, &ctx->timeout_list);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), mode);\n\tdata->timer.function = io_timeout_fn;\n\thrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);\n\treturn 0;",
        "output": "1",
        "idx": 3319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n",
        "output": "1",
        "idx": 4197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n",
        "output": "1",
        "idx": 4873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n",
        "output": "1",
        "idx": 3585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "http_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  GTlsCertificateFlags cert_flags;\n  gboolean op_res;\n  gboolean using_https;\n\n  error = NULL;\n  op_res = FALSE;\n\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  if (!data->accept_ssl_errors)\n    {\n      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);\n      if (using_https && cert_flags != 0)\n        {\n          goa_utils_set_error_ssl (&error, cert_flags);\n          goto out;\n        }\n    }\n\n  op_res = TRUE;\n\n out:\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (http_client_check_data_free, data);\n}",
        "output": "1",
        "idx": 4821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CURLcode hsts_push(struct Curl_easy *data,\n                          struct curl_index *i,\n                          struct stsentry *sts,\n                          bool *stop)\n{\n  struct curl_hstsentry e;\n  CURLSTScode sc;\n  struct tm stamp;\n  CURLcode result;\n\n  e.name = (char *)sts->host;\n  e.namelen = strlen(sts->host);\n  e.includeSubDomains = sts->includeSubDomains;\n\n  if(sts->expires != TIME_T_MAX) {\n    result = Curl_gmtime((time_t)sts->expires, &stamp);\n    if(result)\n      return result;\n\n    msnprintf(e.expire, sizeof(e.expire), \"%d%02d%02d %02d:%02d:%02d\",\n              stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,\n              stamp.tm_hour, stamp.tm_min, stamp.tm_sec);\n  }\n  else\n    strcpy(e.expire, UNLIMITED);\n\n  sc = data->set.hsts_write(data, &e, i,\n                            data->set.hsts_write_userp);\n  *stop = (sc != CURLSTS_OK);\n  return sc == CURLSTS_FAIL ? CURLE_BAD_FUNCTION_ARGUMENT : CURLE_OK;\n}",
        "output": "0",
        "idx": 4774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unit_unwatch_bus_name(Unit *u, const char *name) {\n        assert(u);\n        assert(name);\n\n        (void) hashmap_remove_value(u->manager->watch_bus, name, u);\n        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);\n}",
        "output": "0",
        "idx": 285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ZipTest::verifyDataFile(const std::string& path, Poco::UInt64 size)\n{\n\tstd::ifstream in(path.c_str(), std::ios::binary);\n\tassert( ! in.fail() );\n\tPoco::Buffer<char> buffer1(MB);\n\tPoco::Buffer<char> buffer2(MB);\n\tfor (int i = 0; size != 0; i++)\n\t{\n\t\tstd::memset(buffer1.begin(), i, buffer1.size());\n\t\tstd::memset(buffer2.begin(), 0, buffer2.size());\n\t\tPoco::UInt64 bytesToRead = std::min(size, static_cast<Poco::UInt64>(buffer2.size()));\n\t\tin.read(buffer2.begin(), bytesToRead);\n\t\tassert(!in.fail() );\n\t\tassert(std::memcmp(buffer1.begin(), buffer2.begin(), static_cast<std::size_t>(bytesToRead)) == 0);\n\t\tsize -= bytesToRead;\n\t}\n\tchar c;\n\tin.read(&c, 1);\n\tassert ( in.eof() );\n}",
        "output": "1",
        "idx": 601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);",
        "output": "1",
        "idx": 280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_run_all_timers(void)\n\n{\n\n    alarm_timer->pending = 0;\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->expired) {\n\n        alarm_timer->expired = 0;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    qemu_run_timers(vm_clock);\n\n    qemu_run_timers(rt_clock);\n\n    qemu_run_timers(host_clock);\n\n}\n",
        "output": "0",
        "idx": 4803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }",
        "output": "0",
        "idx": 3039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void stl_phys_notdirty(hwaddr addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n",
        "output": "0",
        "idx": 6308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline TfLiteTensor* GetTemporary(TfLiteContext* context,\n                                  const TfLiteNode* node, int index) {\n  return &context->tensors[node->temporaries->data[index]];\n}",
        "output": "1",
        "idx": 1660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_parsed_dn_duplicates(struct ldb_module *module,\n\t\t\t\t      struct ldb_message_element *el,\n\t\t\t\t      struct parsed_dn *pdn)\n{\n\tunsigned int i;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\n\tfor (i = 1; i < el->num_values; i++) {\n\t\tstruct parsed_dn *p = &pdn[i];\n\t\tif (parsed_dn_compare(p, &pdn[i - 1]) == 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"Linked attribute %s has \"\n\t\t\t\t\t       \"multiple identical values\",\n\t\t\t\t\t       el->name);\n\t\t\tif (ldb_attr_cmp(el->name, \"member\") == 0) {\n\t\t\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t\t\t} else {\n\t\t\t\treturn LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;\n\t\t\t}\n\t\t}\n\t}\n\treturn LDB_SUCCESS;\n}",
        "output": "0",
        "idx": 4586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,\n\t\t\t\tuint8_t rcv_id_len, const char *raw_pdu,\n\t\t\t\tsize_t raw_pdu_len)\n{\n\tconst char *xpath = \"/frr-isisd:id-len-mismatch\";\n\tstruct list *arguments = yang_data_list_new();\n\tchar xpath_arg[XPATH_MAXLEN];\n\tstruct yang_data *data;\n\tstruct isis_area *area = circuit->area;\n\n\tnotif_prep_instance_hdr(xpath, area, \"default\", arguments);\n\tnotif_prepr_iface_hdr(xpath, circuit, arguments);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/pdu-field-len\", xpath);\n\tdata = yang_data_new_uint8(xpath_arg, rcv_id_len);\n\tlistnode_add(arguments, data);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/raw-pdu\", xpath);\n\tdata = yang_data_new(xpath_arg, raw_pdu);\n\tlistnode_add(arguments, data);\n\n\thook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,\n\t\t  raw_pdu_len);\n\n\tnb_notification_send(xpath, arguments);\n}",
        "output": "1",
        "idx": 5976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "launch_test_addresses(int fd, short event, void *args)\n{\n  const or_options_t *options = get_options();\n  struct evdns_request *req;\n  (void)fd;\n  (void)event;\n  (void)args;\n\n  if (options->DisableNetwork)\n    return;\n\n  log_info(LD_EXIT, \"Launching checks to see whether our nameservers like to \"\n           \"hijack *everything*.\");\n  /* This situation is worse than the failure-hijacking situation.  When this\n   * happens, we're no good for DNS requests at all, and we shouldn't really\n   * be an exit server.*/\n  if (!options->ServerDNSTestAddresses)\n    return;\n  tor_assert(the_evdns_base);\n  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,\n                          const char *, address) {\n    char *a = tor_strdup(address);\n    req = evdns_base_resolve_ipv4(the_evdns_base,\n                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);\n\n    if (!req) {\n      log_info(LD_EXIT, \"eventdns rejected test address %s\",\n               escaped_safe_str(address));\n      tor_free(a);\n    }\n  } SMARTLIST_FOREACH_END(address);\n}",
        "output": "0",
        "idx": 5759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n\n{\n\n    int ret = 0;\n\n\n\n    assert(len > 0);\n\n    ccid_bulk_in_get(s);\n\n    if (s->current_bulk_in != NULL) {\n\n        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n\n        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n\n        s->current_bulk_in->pos += ret;\n\n        if (s->current_bulk_in->pos == s->current_bulk_in->len) {\n\n            ccid_bulk_in_release(s);\n\n        }\n\n    } else {\n\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n\n        ret = USB_RET_NAK;\n\n    }\n\n    if (ret > 0) {\n\n        DPRINTF(s, D_MORE_INFO,\n\n                \"%s: %d/%d req/act to guest (BULK_IN)\\n\", __func__, len, ret);\n\n    }\n\n    if (ret != USB_RET_NAK && ret < len) {\n\n        DPRINTF(s, 1,\n\n            \"%s: returning short (EREMOTEIO) %d < %d\\n\", __func__, ret, len);\n\n    }\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 2993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n",
        "output": "1",
        "idx": 215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "addChar(char c, Lineprop mode)\n{\n    addMChar(&c, mode, 1);\n}",
        "output": "1",
        "idx": 1030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int device_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dmar_domain *domain;\n\n\tif (iommu_dummy(dev))\n\t\treturn 0;\n\n\tif (action != BUS_NOTIFY_REMOVED_DEVICE)\n\t\treturn 0;\n\n\tdomain = find_domain(dev);\n\tif (!domain)\n\t\treturn 0;\n\n\tdmar_remove_one_dev_info(domain, dev);\n\tif (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))\n\t\tdomain_exit(domain);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CServer::IsAuthed(int ClientID) const\n{\n\treturn m_aClients[ClientID].m_Authed;\n}",
        "output": "0",
        "idx": 5737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int checkout_conflict_add(\n\tcheckout_data *data,\n\tconst git_index_entry *conflict)\n{\n\tint error = git_index_remove(data->index, conflict->path, 0);\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgit_error_clear();\n\telse if (error < 0)\n\t\treturn error;\n\n\treturn git_index_add(data->index, conflict);\n}",
        "output": "0",
        "idx": 1552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \"X\" */\n\tchar *endptr;\n\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\t\t\t\n\t/* strtol allows whitespace and other stuff in the beginning\n\t\t* we're not interested */\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it's HTML\n\t * (and which version) or XML. */\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 1619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)\n\t{\n\tint extdatalen=0;\n\tunsigned char *ret = p;\n\n\tret+=2;\n\tif (ret>=limit) return NULL; /* this really never occurs, but ... */\n\n\tif (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)\n\t\t{ \n\t\tif (limit - p - 4 < 0) return NULL; \n\n\t\ts2n(TLSEXT_TYPE_server_name,ret);\n\t\ts2n(0,ret);\n\t\t}\n\t\n\tif ((extdatalen = ret-p-2)== 0) \n\t\treturn p;\n\n\ts2n(extdatalen,p);\n\treturn ret;\n}",
        "output": "1",
        "idx": 51
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n        static const char module[] = \"TIFFWriteDirectoryTagCheckedRational\";\n\tuint32 m[2];\n\tassert(sizeof(uint32)==4);\n        if( value < 0 )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Negative value is illegal\");\n            return 0;\n        }\n\telse if (value==0.0)\n\t{\n\t\tm[0]=0;\n\t\tm[1]=1;\n\t}\n\telse if (value==(double)(uint32)value)\n\t{\n\t\tm[0]=(uint32)value;\n\t\tm[1]=1;\n\t}\n\telse if (value<1.0)\n\t{\n\t\tm[0]=(uint32)(value*0xFFFFFFFF);\n\t\tm[1]=0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tm[0]=0xFFFFFFFF;\n\t\tm[1]=(uint32)(0xFFFFFFFF/value);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t{\n\t\tTIFFSwabLong(&m[0]);\n\t\tTIFFSwabLong(&m[1]);\n\t}\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));\n}",
        "output": "1",
        "idx": 5165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,\n\n                          const int16_t *filter, const int16_t *filterPos,\n\n                          int filterSize)\n\n{\n\n    int i;\n\n    for (i=0; i<dstW; i++) {\n\n        int j;\n\n        int srcPos= filterPos[i];\n\n        int val=0;\n\n        for (j=0; j<filterSize; j++) {\n\n            val += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n        }\n\n        //filter += hFilterSize;\n\n        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...\n\n        //dst[i] = val>>7;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int esp_select(ESPState *s)\n{\n    int target;\n\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n\n    s->ti_size = 0;\n    fifo8_reset(&s->fifo);\n\n    if (s->current_req) {\n        /* Started a new command before the old one finished.  Cancel it.  */\n        scsi_req_cancel(s->current_req);\n        s->async_len = 0;\n    }\n\n    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);\n    if (!s->current_dev) {\n        /* No such drive */\n        s->rregs[ESP_RSTAT] = 0;\n        s->rregs[ESP_RINTR] |= INTR_DC;\n        s->rregs[ESP_RSEQ] = SEQ_0;\n        esp_raise_irq(s);\n        return -1;\n    }\n\n    /*\n     * Note that we deliberately don't raise the IRQ here: this will be done\n     * either in do_busid_cmd() for DATA OUT transfers or by the deferred\n     * IRQ mechanism in esp_transfer_data() for DATA IN transfers\n     */\n    s->rregs[ESP_RINTR] |= INTR_FC;\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n    return 0;\n}",
        "output": "1",
        "idx": 35
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n",
        "output": "1",
        "idx": 1789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ndisc_handler(sd_ndisc *nd, int event, void *userdata) {\n        Link *link = userdata;\n        int r;\n\n        assert(link);\n\n        if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))\n                return;\n\n        switch (event) {\n        case SD_NDISC_EVENT_TIMEOUT:\n                dhcp6_request_address(link);\n\n                r = sd_dhcp6_client_start(link->dhcp6_client);\n                if (r < 0 && r != -EALREADY)\n                        log_link_warning_errno(link, r, \"Starting DHCPv6 client after NDisc timeout failed: %m\");\n                break;\n        case SD_NDISC_EVENT_STOP:\n                break;\n        default:\n                log_link_warning(link, \"IPv6 Neighbor Discovery unknown event: %d\", event);\n        }\n}",
        "output": "0",
        "idx": 2914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}",
        "output": "1",
        "idx": 1446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_timeout(void *arg)\n{\n  FILE *f;\n  double temp, comp;\n\n  f = fopen(filename, \"r\");\n\n  if (f && fscanf(f, \"%lf\", &temp) == 1) {\n    comp = get_tempcomp(temp);\n\n    if (fabs(comp) <= MAX_COMP) {\n      comp = LCL_SetTempComp(comp);\n\n      DEBUG_LOG(\"tempcomp updated to %f for %f\", comp, temp);\n\n      if (logfileid != -1) {\n        struct timespec now;\n\n        LCL_ReadCookedTime(&now, NULL);\n        LOG_FileWrite(logfileid, \"%s %11.4e %11.4e\",\n            UTI_TimeToLogForm(now.tv_sec), temp, comp);\n      }\n    } else {\n      LOG(LOGS_WARN, \"Temperature compensation of %.3f ppm exceeds sanity limit of %.1f\",\n          comp, MAX_COMP);\n    }\n  } else {\n    LOG(LOGS_WARN, \"Could not read temperature from %s\", filename);\n  }\n\n  if (f)\n    fclose(f);\n\n  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);\n}",
        "output": "1",
        "idx": 1811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }",
        "output": "0",
        "idx": 896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hso_serial_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\tu8 usb_gone;\n\n\thso_dbg(0x1, \"Closing serial port\\n\");\n\n\t/* Open failed, no close cleanup required */\n\tif (serial == NULL)\n\t\treturn;\n\n\tmutex_lock(&serial->parent->mutex);\n\tusb_gone = serial->parent->usb_gone;\n\n\tif (!usb_gone)\n\t\tusb_autopm_get_interface(serial->parent->interface);\n\n\t/* reset the rts and dtr */\n\t/* do the actual close */\n\tserial->port.count--;\n\n\tif (serial->port.count <= 0) {\n\t\tserial->port.count = 0;\n\t\ttty_port_tty_set(&serial->port, NULL);\n\t\tif (!usb_gone)\n\t\t\thso_stop_serial_device(serial->parent);\n\t\ttasklet_kill(&serial->unthrottle_tasklet);\n\t}\n\n\tif (!usb_gone)\n\t\tusb_autopm_put_interface(serial->parent->interface);\n\n\tmutex_unlock(&serial->parent->mutex);\n}",
        "output": "0",
        "idx": 5062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n\n{\n\n    int ret, i;\n\n\n\n    frame->width  = s->avctx->width  + 2;\n\n    frame->height = s->avctx->height + 2;\n\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    for (i = 0; frame->data[i]; i++) {\n\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n\n        frame->data[i] += offset;\n\n    }\n\n    frame->width  = s->avctx->width;\n\n    frame->height = s->avctx->height;\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  file_synch_write (rw, slice_ptr (command->slice),\n                    command->slice.len, command->offset);\n  /* file_synch_write called exit() on error */\n  cb.callback (cb.user_data, &dummy);\n}",
        "output": "0",
        "idx": 5303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);",
        "output": "1",
        "idx": 4348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int quicklistBookmarkDelete(quicklist *ql, const char *name) {\n    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);\n    if (!bm)\n        return 0;\n    _quicklistBookmarkDelete(ql, bm);\n    return 1;\n}",
        "output": "0",
        "idx": 2041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GSource *iohandler_get_g_source(void)\n\n{\n\n    iohandler_init();\n\n    return aio_get_g_source(iohandler_ctx);\n\n}\n",
        "output": "0",
        "idx": 6315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_VID)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_VID)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 3590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}",
        "output": "0",
        "idx": 6309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void net_checksum_calculate(uint8_t *data, int length)\n\n{\n\n    int hlen, plen, proto, csum_offset;\n\n    uint16_t csum;\n\n\n\n    if ((data[14] & 0xf0) != 0x40)\n\n\treturn; /* not IPv4 */\n\n    hlen  = (data[14] & 0x0f) * 4;\n\n    plen  = (data[16] << 8 | data[17]) - hlen;\n\n    proto = data[23];\n\n\n\n    switch (proto) {\n\n    case PROTO_TCP:\n\n\tcsum_offset = 16;\n\n\tbreak;\n\n    case PROTO_UDP:\n\n\tcsum_offset = 6;\n\n\tbreak;\n\n    default:\n\n\treturn;\n\n    }\n\n\n\n    if (plen < csum_offset+2)\n\n\treturn;\n\n\n\n    data[14+hlen+csum_offset]   = 0;\n\n    data[14+hlen+csum_offset+1] = 0;\n\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n\n    data[14+hlen+csum_offset]   = csum >> 8;\n\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n\n}\n",
        "output": "0",
        "idx": 443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pg_role_aclcheck(Oid role_oid, Oid roleid, AclMode mode)\n{\n\tif (mode & ACL_GRANT_OPTION_FOR(ACL_CREATE))\n\t{\n\t\tif (is_admin_of_role(roleid, role_oid))\n\t\t\treturn ACLCHECK_OK;\n\t}\n\tif (mode & ACL_CREATE)\n\t{\n\t\tif (is_member_of_role(roleid, role_oid))\n\t\t\treturn ACLCHECK_OK;\n\t}\n\tif (mode & ACL_USAGE)\n\t{\n\t\tif (has_privs_of_role(roleid, role_oid))\n\t\t\treturn ACLCHECK_OK;\n\t}\n\treturn ACLCHECK_NO_PRIV;\n}",
        "output": "1",
        "idx": 1412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key, *dot;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tdot = strrchr(key, '.');\n\tif (dot) {\n\t\tstruct credential want = CREDENTIAL_INIT;\n\t\tchar *url = xmemdupz(key, dot - key);\n\t\tint matched;\n\n\t\tcredential_from_url(&want, url);\n\t\tmatched = credential_match(&want, c);\n\n\t\tcredential_clear(&want);\n\t\tfree(url);\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t\tkey = dot + 1;\n\t}\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username)\n\t\t\tc->username = xstrdup(value);\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n",
        "output": "0",
        "idx": 4596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sox_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    int ret, size;\n\n\n\n    if (url_feof(s->pb))\n\n        return AVERROR_EOF;\n\n\n\n    size = SOX_SAMPLES*s->streams[0]->codec->block_align;\n\n    ret = av_get_packet(s->pb, pkt, size);\n\n    if (ret < 0)\n\n        return AVERROR(EIO);\n\n\n    pkt->stream_index = 0;\n\n    pkt->size = ret;\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 3121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_image (void)\n{\n    RsvgNodeImage *image;\n    image = g_new (RsvgNodeImage, 1);\n    _rsvg_node_init (&image->super);\n    g_assert (image->super.state);\n    image->img = NULL;\n    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;\n    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (\"0\");\n    image->super.free = rsvg_node_image_free;\n    image->super.draw = rsvg_node_image_draw;\n    image->super.set_atts = rsvg_node_image_set_atts;\n    return &image->super;\n}",
        "output": "1",
        "idx": 6244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n",
        "output": "1",
        "idx": 5233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n",
        "output": "1",
        "idx": 2698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(imagepng)\n{\n#ifdef USE_GD_IOCTX\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImagePngCtxEx);\n#else\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImagePng);\n#endif\n}",
        "output": "0",
        "idx": 3871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n",
        "output": "1",
        "idx": 5814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_marker_parse (const RsvgDefs * defs, const char *str)\n{\n    char *name;\n\n    name = rsvg_get_url_string (str);\n    if (name) {\n        RsvgNode *val;\n        val = rsvg_defs_lookup (defs, name);\n        g_free (name);\n\n        if (val && (!strcmp (val->type->str, \"marker\")))\n            return val;\n    }\n    return NULL;\n}",
        "output": "1",
        "idx": 4965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_reset(struct perf_event *event)\n{\n\t(void)perf_event_read(event);\n\tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}",
        "output": "1",
        "idx": 4918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
        "output": "1",
        "idx": 1643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n\n                        AVFilterInOut **open_outputs, AVClass *log_ctx)\n\n{\n\n    int pad = 0;\n\n\n\n    while (**buf == '[') {\n\n        char *name = parse_link_name(buf, log_ctx);\n\n        AVFilterInOut *match;\n\n\n\n        if (!name)\n\n            return AVERROR(EINVAL);\n\n\n\n        /* First check if the label is not in the open_outputs list */\n\n        match = extract_inout(name, open_outputs);\n\n\n\n        if (match) {\n\n            av_free(name);\n\n        } else {\n\n            /* Not in the list, so add it as an input */\n\n            match = av_mallocz(sizeof(AVFilterInOut));\n\n            match->name    = name;\n\n            match->pad_idx = pad;\n\n        }\n\n\n\n        insert_inout(curr_inputs, match);\n\n\n\n        *buf += strspn(*buf, WHITESPACES);\n\n        pad++;\n\n    }\n\n\n\n    return pad;\n\n}\n",
        "output": "1",
        "idx": 335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,\n                                                   HValue* key) {\n  HValue* context = environment()->LookupContext();\n  return new(zone()) HLoadKeyedGeneric(context, object, key);\n}",
        "output": "0",
        "idx": 1292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n",
        "output": "1",
        "idx": 5505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sqlite3ExprDelete(sqlite3 *db, Expr *p){\n  if( p ) sqlite3ExprDeleteNN(db, p);\n}",
        "output": "0",
        "idx": 6097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int cpu_gdb_index(CPUState *cpu)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    return cpu->host_tid;\n\n#else\n\n    return cpu->cpu_index + 1;\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 4102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPM_CAP_Unmarshal(TPM_CAP *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case TPM_CAP_ALGS:\n\t  case TPM_CAP_HANDLES:\n\t  case TPM_CAP_COMMANDS:\n\t  case TPM_CAP_PP_COMMANDS:\n\t  case TPM_CAP_AUDIT_COMMANDS:\n\t  case TPM_CAP_PCRS:\n\t  case TPM_CAP_TPM_PROPERTIES:\n\t  case TPM_CAP_PCR_PROPERTIES:\n\t  case TPM_CAP_ECC_CURVES:\n\t  case TPM_CAP_AUTH_POLICIES:\n\t  case TPM_CAP_ACT:\n\t  case TPM_CAP_VENDOR_PROPERTY:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 3919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_rsync(const char *src, const char *dest)\n{\n\t// call out to rsync\n\tpid_t pid;\n\tchar *s;\n\tsize_t l;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\treturn -1;\n\tif (pid > 0)\n\t\treturn wait_for_pid(pid);\n\n\tl = strlen(src) + 2;\n\ts = malloc(l);\n\tif (!s)\n\t\texit(1);\n\tstrcpy(s, src);\n\ts[l-2] = '/';\n\ts[l-1] = '\\0';\n\n\texeclp(\"rsync\", \"rsync\", \"-aH\", s, dest, (char *)NULL);\n\texit(1);\n}",
        "output": "0",
        "idx": 2408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tg3_ptp_init(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, PTP_CAPABLE))\n\t\treturn;\n\n\t/* Initialize the hardware clock to the system time. */\n\ttg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));\n\ttp->ptp_adjust = 0;\n\ttp->ptp_info = tg3_ptp_caps;\n}",
        "output": "0",
        "idx": 5624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Magick::Image::solarize(const double factor_)\n{\n  modifyImage();\n  GetPPException;\n  SolarizeImage(image(),factor_,exceptionInfo);\n  ThrowImageException;\n}",
        "output": "0",
        "idx": 3474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rpmte rpmteNew(const rpmts ts, Header h,\n\t\trpmElementType type,\n\t\tfnpyKey key,\n\t\trpmRelocation * relocs,\n\t\tint dboffset)\n{\n    rpmte p = xcalloc(1, sizeof(*p));\n\n    p->type = type;\n    addTE(ts, p, h, key, relocs);\n    switch (type) {\n    case TR_ADDED:\n\tp->pkgFileSize = headerGetNumber(h, RPMTAG_LONGSIGSIZE) + 96 + 256;\n\tbreak;\n    case TR_REMOVED:\n\t/* nothing to do */\n\tbreak;\n    }\n\n    return p;\n}",
        "output": "0",
        "idx": 4630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lexer_compare_identifiers (parser_context_t *context_p, /**< context */\n                           const lexer_lit_location_t *left_p, /**< left literal */\n                           const lexer_lit_location_t *right_p) /**< right literal */\n{\n  prop_length_t length = left_p->length;\n\n  if (length != right_p->length)\n  {\n    return false;\n  }\n\n  if (!left_p->has_escape)\n  {\n    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);\n  }\n\n  if (!right_p->has_escape)\n  {\n    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);\n  }\n\n  if (length <= 64)\n  {\n    uint8_t buf_p[64];\n    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);\n    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);\n  }\n\n  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);\n\n  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);\n  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);\n  parser_free (dynamic_buf_p, length);\n\n  return result;\n} /* lexer_compare_identifiers */",
        "output": "1",
        "idx": 2339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tty_prepare_flip_string_flags(struct tty_struct *tty,\n\t\t\tunsigned char **chars, char **flags, size_t size)\n{\n\tint space = tty_buffer_request_room(tty, size);\n\tif (likely(space)) {\n\t\tstruct tty_buffer *tb = tty->buf.tail;\n\t\t*chars = tb->char_buf_ptr + tb->used;\n\t\t*flags = tb->flag_buf_ptr + tb->used;\n\t\ttb->used += space;\n\t}\n\treturn space;\n}",
        "output": "1",
        "idx": 3561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);",
        "output": "1",
        "idx": 866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",
        "output": "1",
        "idx": 3043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)\n{\n\ttimer->start_site = NULL;\n}",
        "output": "1",
        "idx": 4645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,\n\n                                        uint8_t isc, bool swap,\n\n                                        bool is_maskable)\n\n{\n\n    struct kvm_s390_io_adapter adapter = {\n\n        .id = id,\n\n        .isc = isc,\n\n        .maskable = is_maskable,\n\n        .swap = swap,\n\n    };\n\n    KVMS390FLICState *flic = KVM_S390_FLIC(fs);\n\n    int r, ret;\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,\n\n        .addr = (uint64_t)&adapter,\n\n    };\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {\n\n        /* nothing to do */\n\n        return 0;\n\n    }\n\n\n\n    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);\n\n\n\n    ret = r ? -errno : 0;\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 1351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_binary_float_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble f;\n\n\tf = get_float64 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FLOAT;\n\tret->data = r_str_newf (\"%.15g\", f);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 5415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.type = NBD_CMD_FLUSH;\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n",
        "output": "1",
        "idx": 4376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tint tag, unsigned int nr_pages, struct page **pages)\n{\n\tunsigned int i;\n\tunsigned int ret;\n\tunsigned int nr_found;\n\n\trcu_read_lock();\nrestart:\n\tnr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,\n\t\t\t\t(void ***)pages, *index, nr_pages, tag);\n\tret = 0;\n\tfor (i = 0; i < nr_found; i++) {\n\t\tstruct page *page;\nrepeat:\n\t\tpage = radix_tree_deref_slot((void **)pages[i]);\n\t\tif (unlikely(!page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * this can only trigger if nr_found == 1, making livelock\n\t\t * a non issue.\n\t\t */\n\t\tif (unlikely(page == RADIX_TREE_RETRY))\n\t\t\tgoto restart;\n\n\t\tif (!page_cache_get_speculative(page))\n\t\t\tgoto repeat;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != *((void **)pages[i]))) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tpages[ret] = page;\n\t\tret++;\n\t}\n\trcu_read_unlock();\n\n\tif (ret)\n\t\t*index = pages[ret - 1]->index + 1;\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,\n                                 struct ofpbuf *b)\n{\n    const struct ofp_header *oh = b->data;\n\n    if (oh->version < OFP13_VERSION) {\n        /* Try adding a port description to the message, but drop it again if\n         * the buffer overflows.  (This possibility for overflow is why\n         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */\n        size_t start_ofs = b->size;\n        ofputil_put_phy_port(oh->version, pp, b);\n        if (b->size > UINT16_MAX) {\n            b->size = start_ofs;\n        }\n    }\n}",
        "output": "0",
        "idx": 2324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT void save_log() {\n    TCHAR file_name[MAX_PATH];\n    OPENFILENAME ofn;\n    LPTSTR txt;\n    LPSTR str;\n\n    ZeroMemory(&ofn, sizeof ofn);\n    file_name[0]='\\0';\n\n    ofn.lStructSize=sizeof ofn;\n    ofn.hwndOwner=hwnd;\n    ofn.lpstrFilter=TEXT(\"Log Files (*.log)\\0*.log\\0All Files (*.*)\\0*.*\\0\\0\");\n    ofn.lpstrFile=file_name;\n    ofn.nMaxFile=MAX_PATH;\n    ofn.lpstrDefExt=TEXT(\"LOG\");\n    ofn.lpstrInitialDir=TEXT(\".\");\n\n    ofn.lpstrTitle=TEXT(\"Save Log\");\n    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|\n        OFN_OVERWRITEPROMPT;\n    if(!GetSaveFileName(&ofn))\n        return;\n\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);\n    txt=log_txt(); /* need to convert the result to UTF-8 */\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);\n    str=tstr2str(txt);\n    str_free(txt);\n    save_text_file(file_name, str);\n    str_free(str);\n}",
        "output": "0",
        "idx": 5495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n",
        "output": "0",
        "idx": 5801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n",
        "output": "1",
        "idx": 2060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcessWalSndrMessage(XLogRecPtr walEnd, TimestampTz sendTime)\n{\n\t/* use volatile pointer to prevent code rearrangement */\n\tvolatile WalRcvData *walrcv = WalRcv;\n\n\tTimestampTz lastMsgReceiptTime = GetCurrentTimestamp();\n\n\t/* Update shared-memory status */\n\tSpinLockAcquire(&walrcv->mutex);\n\tif (walrcv->latestWalEnd < walEnd)\n\t\twalrcv->latestWalEndTime = sendTime;\n\twalrcv->latestWalEnd = walEnd;\n\twalrcv->lastMsgSendTime = sendTime;\n\twalrcv->lastMsgReceiptTime = lastMsgReceiptTime;\n\tSpinLockRelease(&walrcv->mutex);\n\n\tif (log_min_messages <= DEBUG2)\n\t\telog(DEBUG2, \"sendtime %s receipttime %s replication apply delay %d ms transfer latency %d ms\",\n\t\t\t timestamptz_to_str(sendTime),\n\t\t\t timestamptz_to_str(lastMsgReceiptTime),\n\t\t\t GetReplicationApplyDelay(),\n\t\t\t GetReplicationTransferLatency());\n}",
        "output": "0",
        "idx": 3682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int adpcm_decode_init(AVCodecContext * avctx)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n\n\n    if(avctx->channels > 2U){\n\n        return -1;\n\n    }\n\n\n\n    c->channel = 0;\n\n    c->status[0].predictor = c->status[1].predictor = 0;\n\n    c->status[0].step_index = c->status[1].step_index = 0;\n\n    c->status[0].step = c->status[1].step = 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_CT:\n\n        c->status[0].step = c->status[1].step = 511;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)\n{\n\text4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;\n\tstruct ext4_group_desc *gdp = NULL;\n\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn ngroups;\n\n\tfor (group = 0; group < ngroups; group++) {\n\t\tgdp = ext4_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))\n\t\t\tcontinue;\n\t\tif (group != 0)\n\t\t\tbreak;\n\t\text4_error(sb, \"Inode table for bg 0 marked as \"\n\t\t\t   \"needing zeroing\");\n\t\tif (sb_rdonly(sb))\n\t\t\treturn ngroups;\n\t}\n\n\treturn group;\n}",
        "output": "0",
        "idx": 5772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part     = (1 << porder);\n\n    all_bits = 4 * part;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for (i = 0; i < part; i++) {\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n        cnt = n >> porder;\n\n    }\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n",
        "output": "1",
        "idx": 2423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n",
        "output": "0",
        "idx": 1669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n",
        "output": "0",
        "idx": 5975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {\n    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);\n    auto oldServer = ServerDescriptionBuilder()\n                         .withAddress(topologyDescription->getServers().back()->getAddress())\n                         .withType(ServerType::kRSPrimary)\n                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)\n                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)\n                         .instance();\n    topologyDescription->installServerDescription(oldServer);\n\n    ASSERT(!topologyDescription->isWireVersionCompatible());\n    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),\n                       DBException,\n                       ErrorCodes::IncompatibleServerVersion);\n}",
        "output": "1",
        "idx": 49
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n\t     flag, p, end, items);\n}",
        "output": "0",
        "idx": 3890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long mmap_rnd(void)\n{\n\tunsigned long rnd = 0UL;\n\n\tif (current->flags & PF_RANDOMIZE) {\n\t\tunsigned long val = get_random_int();\n\t\tif (test_thread_flag(TIF_32BIT))\n\t\t\trnd = (val % (1UL << (23UL-PAGE_SHIFT)));\n\t\telse\n\t\t\trnd = (val % (1UL << (30UL-PAGE_SHIFT)));\n\t}\n\treturn rnd << PAGE_SHIFT;\n}",
        "output": "0",
        "idx": 153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cubieboard_init(QEMUMachineInitArgs *args)\n\n{\n\n    CubieBoardState *s = g_new(CubieBoardState, 1);\n\n    Error *err = NULL;\n\n\n\n    s->a10 = AW_A10(object_new(TYPE_AW_A10));\n\n    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"Couldn't realize Allwinner A10: %s\\n\",\n\n                error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,\n\n                                &s->sdram);\n\n\n\n    cubieboard_binfo.ram_size = args->ram_size;\n\n    cubieboard_binfo.kernel_filename = args->kernel_filename;\n\n    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);\n\n}\n",
        "output": "0",
        "idx": 3204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_validate_fail_struct_nested(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n",
        "output": "1",
        "idx": 5991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\t/* Unpin physical memory we referred to in current vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\n\tnested_free_all_saved_vmcss(vmx);\n}",
        "output": "0",
        "idx": 1465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 4525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SELECTOR_RPL_MASK;\n\t\tsave->dpl = save->selector & SELECTOR_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}",
        "output": "0",
        "idx": 1309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)\n\n{\n\n    LM32JuartState *s = LM32_JUART(d);\n\n    unsigned char ch = jtx & 0xff;\n\n\n\n    trace_lm32_juart_set_jtx(s->jtx);\n\n\n\n    s->jtx = jtx;\n\n    if (s->chr) {\n\n\n\n        qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n    }\n\n}",
        "output": "1",
        "idx": 110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct work *clone_work(struct work *work)\n{\n\tstruct work *work_clone;\n\tbool cloned = false;\n\tint rolled = 0;\n\n\twork_clone = make_clone(work);\n\twhile (rolled++ < mining_threads && can_roll(work) && should_roll(work)) {\n\t\tapplog(LOG_DEBUG, \"Pushing rolled converted work to stage thread\");\n\t\tif (unlikely(!stage_work(work_clone))) {\n\t\t\tcloned = false;\n\t\t\tbreak;\n\t\t}\n\t\troll_work(work);\n\t\twork_clone = make_clone(work);\n\t\t/* Roll it again to prevent duplicates should this be used\n\t\t * directly later on */\n\t\troll_work(work);\n\t\tcloned = true;\n\t}\n\n\tif (cloned) {\n\t\tstage_work(work);\n\t\treturn work_clone;\n\t}\n\n\tfree_work(work_clone);\n\n\treturn work;\n}",
        "output": "0",
        "idx": 3788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)\n{\n\tswitch (order) {\n\tcase 0:\n\t\treturn (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;\n\tcase 1:\n\t\treturn (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;\n\tcase 2:\n\t\treturn (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;\n\tcase 3:\n\t\treturn ((uint8_t *)rcblock)[index];\n\tcase 4:\n\t\treturn be16toh(((uint16_t *)rcblock)[index]);\n\tcase 5:\n\t\treturn be32toh(((uint32_t *)rcblock)[index]);\n\tcase 6:\n\t\treturn be64toh(((uint64_t *)rcblock)[index]);\n\tdefault:\n\t\tassert(0);\n\t}\n\n\treturn 0;\t/* NOT REACHED */\n}",
        "output": "0",
        "idx": 3254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info)\n{\n    info->magic = (unsigned short) get_be16(f);\n    info->rle = get_byte(f);\n    info->bytes_per_channel = get_byte(f);\n    info->dimension = (unsigned short)get_be16(f);\n    info->xsize = (unsigned short) get_be16(f);\n    info->ysize = (unsigned short) get_be16(f);\n    info->zsize = (unsigned short) get_be16(f);\n#ifdef DEBUG\n    printf(\"sgi header fields:\\n\");\n    printf(\"  magic: %d\\n\", info->magic);\n    printf(\"    rle: %d\\n\", info->rle);\n    printf(\"    bpc: %d\\n\", info->bytes_per_channel);\n    printf(\"    dim: %d\\n\", info->dimension);\n    printf(\"  xsize: %d\\n\", info->xsize);\n    printf(\"  ysize: %d\\n\", info->ysize);\n    printf(\"  zsize: %d\\n\", info->zsize);\n#endif\n    return;\n}",
        "output": "1",
        "idx": 472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    /* Dig for more from OpenSSL error queue */\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}",
        "output": "1",
        "idx": 653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tftp_send_next_block(struct tftp_session *spt,\n                                 struct tftp_t *recv_tp)\n{\n    struct mbuf *m;\n    struct tftp_t *tp;\n    int nobytes;\n\n    m = m_get(spt->slirp);\n\n    if (!m) {\n        return;\n    }\n\n    tp = tftp_prep_mbuf_data(spt, m);\n\n    tp->tp_op = htons(TFTP_DATA);\n    tp->x.tp_data.tp_block_nr = htons((spt->block_nr + 1) & 0xffff);\n\n    nobytes = tftp_read_data(spt, spt->block_nr, tp->x.tp_data.tp_buf,\n                             spt->block_size);\n\n    if (nobytes < 0) {\n        m_free(m);\n\n        /* send \"file not found\" error back */\n\n        tftp_send_error(spt, 1, \"File not found\", tp);\n\n        return;\n    }\n\n    m->m_len = sizeof(struct tftp_t) - (TFTP_BLOCKSIZE_MAX - nobytes) -\n               sizeof(struct udphdr);\n    tftp_udp_output(spt, m, recv_tp);\n\n    if (nobytes == spt->block_size) {\n        tftp_session_update(spt);\n    } else {\n        tftp_session_terminate(spt);\n    }\n\n    spt->block_nr++;\n}",
        "output": "1",
        "idx": 4480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vnc_should_update(VncState *vs)\n\n{\n\n    switch (vs->update) {\n\n    case VNC_STATE_UPDATE_NONE:\n\n        break;\n\n    case VNC_STATE_UPDATE_INCREMENTAL:\n\n        /* Only allow incremental updates if the output buffer\n\n         * is empty, or if audio capture is enabled.\n\n         */\n\n        if (!vs->output.offset || vs->audio_cap) {\n\n            return true;\n\n        }\n\n        break;\n\n    case VNC_STATE_UPDATE_FORCE:\n\n        return true;\n\n    }\n\n    return false;\n\n}\n",
        "output": "1",
        "idx": 2286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n",
        "output": "1",
        "idx": 771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n",
        "output": "0",
        "idx": 2013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tDlfcnModule(void* m)\n\t\t: module(m)\n\t{}",
        "output": "1",
        "idx": 3779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int compare_int64(const void *a, const void *b)\n\n{\n\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n\n    return va < vb ? -1 : va > vb ? +1 : 0;\n\n}\n",
        "output": "1",
        "idx": 5305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n",
        "output": "1",
        "idx": 3577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n",
        "output": "1",
        "idx": 6028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)\n{\n\treturn J9PORT_SIG_EXCEPTION_RETURN;\n}",
        "output": "0",
        "idx": 6040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    INT32 startSize;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT16_Unmarshal(&target->size, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->size == 0) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tstartSize = *size;\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->size != startSize - *size) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned int ScaleQuantumToLong(const Quantum quantum)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((unsigned int) (65537UL*quantum));\n#else\n  if (quantum <= 0.0)\n    return(0UL);\n  if ((65537.0*quantum) >= 4294967295.0)\n    return(4294967295U);\n  return((unsigned int) (65537.0*quantum+0.5));\n#endif\n}",
        "output": "1",
        "idx": 3208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n",
        "output": "0",
        "idx": 1628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lzw_decoder_class_init (LZWDecoderClass *klass)\n{\n}",
        "output": "0",
        "idx": 162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",
        "output": "1",
        "idx": 1257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tor_addr_is_public_for_reject(const tor_addr_t *addr)\n{\n  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)\n          && !tor_addr_is_multicast(addr));\n}",
        "output": "0",
        "idx": 480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n",
        "output": "1",
        "idx": 59
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void tcg_out_ld_ptr(TCGContext *s, int ret,\n\n                                  tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with offset %ld\\n\", __func__, arg);\n\n    if (arg != (arg & 0xfff))\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));\n\n    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |\n\n              INSN_IMM13(arg & 0x3ff));\n\n#else\n\n    tcg_out_ld_raw(s, ret, arg);\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 1253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 5121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf,\n                                          size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->handshake->new_session_ticket == 0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding session ticket extension\" ) );\n\n    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );\n    p += 2;\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}",
        "output": "0",
        "idx": 4019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ftrace_rec_iter *ftrace_rec_iter_start(void)\n{\n\t/*\n\t * We only use a single iterator.\n\t * Protected by the ftrace_lock mutex.\n\t */\n\tstatic struct ftrace_rec_iter ftrace_rec_iter;\n\tstruct ftrace_rec_iter *iter = &ftrace_rec_iter;\n\n\titer->pg = ftrace_pages_start;\n\titer->index = 0;\n\n\t/* Could have empty pages */\n\twhile (iter->pg && !iter->pg->index)\n\t\titer->pg = iter->pg->next;\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}",
        "output": "0",
        "idx": 4201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_free_timer(QEMUTimer *ts)\n\n{\n\n    g_free(ts);\n\n}\n",
        "output": "0",
        "idx": 969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ephy_string_shorten (char  *str,\n                     gsize  target_length)\n{\n  char *new_str;\n  glong actual_length;\n  gulong bytes;\n\n  g_assert (target_length > 0);\n\n  if (!str)\n    return NULL;\n\n  /* FIXME: this function is a big mess. While it is utf-8 safe now,\n   * it can still split a sequence of combining characters.\n   */\n  actual_length = g_utf8_strlen (str, -1);\n\n  /* if the string is already short enough, or if it's too short for\n   * us to shorten it, return a new copy */\n  if ((gsize)actual_length <= target_length)\n    return str;\n\n  /* create string */\n  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);\n\n  /* +1 for ellipsis, +1 for trailing NUL */\n  new_str = g_new (gchar, bytes + 1 + 1);\n\n  strncpy (new_str, str, bytes);\n  strcat (new_str, \"\u2026\");\n\n  g_free (str);\n\n  return new_str;\n}",
        "output": "1",
        "idx": 3034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MaybeLocal<Value> GetCipherStandardName(\n    Environment* env,\n    const SSL_CIPHER* cipher) {\n  return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);\n}",
        "output": "0",
        "idx": 3947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip6_output(struct sk_buff *skb)\n{\n\tif (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))\n\t\treturn ip6_fragment(skb, ip6_output2);\n\telse\n\t\treturn ip6_output2(skb);\n}",
        "output": "1",
        "idx": 3426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}",
        "output": "1",
        "idx": 2758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n",
        "output": "1",
        "idx": 5308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n",
        "output": "1",
        "idx": 2052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *sub_name;\n\tint len;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tlen = spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\tRETURN_STRINGL(sub_name, len, 0);\n\t} else {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t}\n}",
        "output": "1",
        "idx": 5435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 6089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const\n{\n  /* Assume we don't have rtti */\n  if (this == item)\n    return 1;\t\t\t\t\t// Same item is same.\n  /* Check if other type is also a get_user_var() object */\n  if (item->type() != FUNC_ITEM ||\n      ((Item_func*) item)->functype() != functype())\n    return 0;\n  Item_func_get_user_var *other=(Item_func_get_user_var*) item;\n  return (name.length == other->name.length &&\n\t  !memcmp(name.str, other->name.str, name.length));\n}",
        "output": "0",
        "idx": 3334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct zr364xx_camera *cam;\n\n\tif (!file)\n\t\treturn -ENODEV;\n\tcam = video_drvdata(file);\n\n\tf->fmt.pix.pixelformat = formats[0].fourcc;\n\tf->fmt.pix.field = V4L2_FIELD_NONE;\n\tf->fmt.pix.width = cam->width;\n\tf->fmt.pix.height = cam->height;\n\tf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\n\tf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\n\tf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_kernel_module_from_file(struct file *file)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec;\n\tstruct file_security_struct *fsec;\n\tu32 sid = current_sid();\n\tint rc;\n\n\t/* init_module */\n\tif (file == NULL)\n\t\treturn avc_has_perm(sid, sid, SECCLASS_SYSTEM,\n\t\t\t\t\tSYSTEM__MODULE_LOAD, NULL);\n\n\t/* finit_module */\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\n\tfsec = file->f_security;\n\tif (sid != fsec->sid) {\n\t\trc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tisec = inode_security(file_inode(file));\n\treturn avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,\n\t\t\t\tSYSTEM__MODULE_LOAD, &ad);\n}",
        "output": "0",
        "idx": 715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool does_follow(int a, int b)\n{\n  if (follows[a][b]) {\n    lockdep_dout(0) << \"\\n\";\n    *_dout << \"------------------------------------\" << \"\\n\";\n    *_dout << \"existing dependency \" << lock_names[a] << \" (\" << a << \") -> \"\n           << lock_names[b] << \" (\" << b << \") at:\\n\";\n    follows[a][b]->print(*_dout);\n    *_dout << dendl;\n    return true;\n  }\n\n  for (int i=0; i<MAX_LOCKS; i++) {\n    if (follows[a][i] &&\n\tdoes_follow(i, b)) {\n      lockdep_dout(0) << \"existing intermediate dependency \" << lock_names[a]\n          << \" (\" << a << \") -> \" << lock_names[i] << \" (\" << i << \") at:\\n\";\n      follows[a][i]->print(*_dout);\n      *_dout << dendl;\n      return true;\n    }\n  }\n\n  return false;\n}",
        "output": "0",
        "idx": 5159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int float64_eq( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n",
        "output": "0",
        "idx": 6179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)\n{\n\tGF_NALUFFParamArray *pa = NULL;\n\tu32 i, count;\n\tcount = gf_list_count(param_list);\n\tfor (i=0; i<count; i++) {\n\t\tpa = gf_list_get(param_list, i);\n\t\tif (pa->type == nal_type) break;\n\t\tpa = NULL;\n\t}\n\tif (!pa) {\n\t\tGF_SAFEALLOC(pa, GF_NALUFFParamArray);\n\t\tif (!pa) return;\n\n\t\tpa->array_completeness = 1;\n\t\tpa->type = nal_type;\n\t\tpa->nalus = gf_list_new();\n\t\tgf_list_add(param_list, pa);\n\t}\n\tgf_list_add(pa->nalus, sl);\n}",
        "output": "0",
        "idx": 644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))\n\n{\n\n    while (queue->p_head)\n\n        free_func(ff_schro_queue_pop(queue));\n\n}\n",
        "output": "1",
        "idx": 1373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n}",
        "output": "1",
        "idx": 3291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main( int argc, char *argv[] )\n{\n    ((void) argc);\n    ((void) argv);\n\n    printf(\"POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or \"\n           \"POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or \"\n           \"POLARSSL_FS_IO not defined.\\n\");\n    return( 0 );\n}",
        "output": "1",
        "idx": 3659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void register_if_needed(h2_mplx *m) \n{\n    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {\n        apr_status_t status = h2_workers_register(m->workers, m); \n        if (status == APR_SUCCESS) {\n            m->is_registered = 1;\n        }\n        else {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)\n                          \"h2_mplx(%ld): register at workers\", m->id);\n        }\n    }\n}",
        "output": "0",
        "idx": 4997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_info_cancel (NautilusDirectory *directory)\n{\n\tif (directory->details->get_info_in_progress != NULL) {\n\t\tg_cancellable_cancel (directory->details->get_info_in_progress->cancellable);\n\t\tdirectory->details->get_info_in_progress->directory = NULL;\n\t\tdirectory->details->get_info_in_progress = NULL;\n\t\tdirectory->details->get_info_file = NULL;\n\n\t\tasync_job_end (directory, \"file info\");\n\t}\n}",
        "output": "0",
        "idx": 1692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}",
        "output": "1",
        "idx": 4977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vhost_add_used_and_signal(struct vhost_dev *dev,\n\t\t\t       struct vhost_virtqueue *vq,\n\t\t\t       unsigned int head, int len)\n{\n\tvhost_add_used(vq, head, len);\n\tvhost_signal(dev, vq);\n}",
        "output": "0",
        "idx": 5683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcx_screen_dump(void *opaque, const char *filename, bool cswitch,\n                            Error **errp)\n{\n    TCXState *s = opaque;\n    FILE *f;\n    uint8_t *d, *d1, v;\n    int y, x;\n\n    f = fopen(filename, \"wb\");\n    if (!f)\n        return;\n    fprintf(f, \"P6\\n%d %d\\n%d\\n\", s->width, s->height, 255);\n    d1 = s->vram;\n    for(y = 0; y < s->height; y++) {\n        d = d1;\n        for(x = 0; x < s->width; x++) {\n            v = *d;\n            fputc(s->r[v], f);\n            fputc(s->g[v], f);\n            fputc(s->b[v], f);\n            d++;\n        }\n        d1 += MAXX;\n    }\n    fclose(f);\n    return;\n}",
        "output": "0",
        "idx": 2757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n\n\n    count/=2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for(i=0; i<count; i++){\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 88
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\n\tclient->auth_user = client->db->auth_user;\n\t/* have to fetch user info from db */\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t\t/*\n\t\t * Should do instead:\n\t\t *   res = pktbuf_send_queued(buf, client->link);\n\t\t * but that needs better integration with SBuf.\n\t\t */\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}",
        "output": "1",
        "idx": 1863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gnutls_system_mutex_deinit(void **priv)\n{\n\tpthread_mutex_destroy((pthread_mutex_t *) * priv);\n\tfree(*priv);\n\treturn 0;\n}",
        "output": "0",
        "idx": 671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n    OPEN_READER(re, &s->gb);\n\n    count /= 2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n}\n",
        "output": "1",
        "idx": 2316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t max_time_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time;\n\tktime_t max_time = ws->max_time;\n\n\tif (ws->active) {\n\t\tactive_time = ktime_sub(ktime_get(), ws->last_time);\n\t\tif (active_time > max_time)\n\t\t\tmax_time = active_time;\n\t}\n\treturn sprintf(buf, \"%lld\\n\", ktime_to_ms(max_time));\n}",
        "output": "1",
        "idx": 4874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n",
        "output": "0",
        "idx": 4178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const AVOption *av_opt_next(void *obj, const AVOption *last)\n\n{\n\n    AVClass *class = *(AVClass**)obj;\n\n    if (!last && class->option[0].name) return class->option;\n\n    if (last && last[1].name)           return ++last;\n\n    return NULL;\n\n}\n",
        "output": "1",
        "idx": 4549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int racls_del_cb(void *rock,\n                  const char *key, size_t keylen,\n                  const char *data __attribute__((unused)),\n                  size_t datalen __attribute__((unused)))\n{\n    struct txn **txn = (struct txn **)rock;\n    return cyrusdb_delete(mbdb, key, keylen, txn, /*force*/0);\n}",
        "output": "0",
        "idx": 3874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)\n{\n\treturn __htab_lru_map_lookup_elem(map, key, false);\n}",
        "output": "0",
        "idx": 697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 6324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_payload_header(\n\n                                AVFormatContext *s,\n\n                                ASFStream       *stream,\n\n                                int             presentation_time,\n\n                                int             m_obj_size,\n\n                                int             m_obj_offset,\n\n                                int             payload_len\n\n            )\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    ByteIOContext *pb = &asf->pb;\n\n    int val;\n\n    \n\n    val = stream->num;\n\n    if (s->streams[val - 1]->codec.coded_frame->key_frame)\n\n        val |= ASF_PL_FLAG_KEY_FRAME;\n\n    put_byte(pb, val);\n\n        \n\n    put_byte(pb, stream->seq);  //Media object number\n\n    put_le32(pb, m_obj_offset); //Offset Into Media Object\n\n         \n\n    // Replicated Data shall be at least 8 bytes long.\n\n    // The first 4 bytes of data shall contain the \n\n    // Size of the Media Object that the payload belongs to.\n\n    // The next 4 bytes of data shall contain the \n\n    // Presentation Time for the media object that the payload belongs to.\n\n    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);\n\n\n\n    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size\n\n    put_le32(pb, presentation_time);//Replicated Data - Presentation Time\n\n    \n\n    if (asf->multi_payloads_present){\n\n        put_le16(pb, payload_len);   //payload length\n\n    }\n\n}\n",
        "output": "0",
        "idx": 6086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *pcibus_get_fw_dev_path(DeviceState *dev)\n\n{\n\n    PCIDevice *d = (PCIDevice *)dev;\n\n    char path[50], name[33];\n\n    int off;\n\n\n\n    off = snprintf(path, sizeof(path), \"%s@%x\",\n\n                   pci_dev_fw_name(dev, name, sizeof name),\n\n                   PCI_SLOT(d->devfn));\n\n    if (PCI_FUNC(d->devfn))\n\n        snprintf(path + off, sizeof(path) + off, \",%x\", PCI_FUNC(d->devfn));\n\n    return strdup(path);\n\n}\n",
        "output": "0",
        "idx": 4569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init fdt_find_uefi_params(unsigned long node, const char *uname,\n\t\t\t\t       int depth, void *data)\n{\n\tstruct param_info *info = data;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dt_params); i++) {\n\t\tconst char *subnode = dt_params[i].subnode;\n\n\t\tif (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {\n\t\t\tinfo->missing = dt_params[i].params[0].name;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (subnode) {\n\t\t\tint err = of_get_flat_dt_subnode_by_name(node, subnode);\n\n\t\t\tif (err < 0)\n\t\t\t\treturn 0;\n\n\t\t\tnode = err;\n\t\t}\n\n\t\treturn __find_uefi_params(node, info, dt_params[i].params);\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n\n{\n\n    int i;\n\n    size_t pagesize = getpagesize();\n\n\n\n    memory = (memory + pagesize - 1) & -pagesize;\n\n    for (i = 0; i < memory / pagesize; i++) {\n\n        memset(area + pagesize * i, 0, 1);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n",
        "output": "1",
        "idx": 5373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static apr_status_t unschedule_slow_tasks(h2_mplx *m) \n{\n    h2_stream *stream;\n    int n;\n    \n    /* Try to get rid of streams that occupy workers. Look for safe requests\n     * that are repeatable. If none found, fail the connection.\n     */\n    n = (m->tasks_active - m->limit_active - (int)h2_ihash_count(m->sredo));\n    while (n > 0 && (stream = get_latest_repeatable_unsubmitted_stream(m))) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, m->c, \n                      \"h2_mplx(%s): unschedule, resetting task for redo later\",\n                      stream->task->id);\n        h2_task_rst(stream->task, H2_ERR_CANCEL);\n        h2_ihash_add(m->sredo, stream);\n        --n;\n    }\n    \n    if ((m->tasks_active - h2_ihash_count(m->sredo)) > m->limit_active) {\n        stream = get_timed_out_busy_stream(m);\n        if (stream) {\n            /* Too many busy workers, unable to cancel enough streams\n             * and with a busy, timed out stream, we tell the client\n             * to go away... */\n            return APR_TIMEUP;\n        }\n    }\n    return APR_SUCCESS;\n}",
        "output": "1",
        "idx": 647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,\n\t\t\t\t   xmlSchemaTypePtr type)\n{\n    if (! WXS_IS_UNION(type))\n\treturn(0);\n    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,\n\ttype->memberTypes));\n}",
        "output": "0",
        "idx": 943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tmap[i].dev_name = dev_name(p->dev);\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map) {\n\t\tdt_free_map(pctldev, map, num_maps);\n\t\treturn -ENOMEM;\n\t}\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n}",
        "output": "1",
        "idx": 475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)\n{\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        unsigned st_name = get_te32(&sym->st_name);\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 2790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n",
        "output": "1",
        "idx": 835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n",
        "output": "0",
        "idx": 396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void yurex_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_yurex *dev;\n\tint minor = interface->minor;\n\n\tdev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\t/* give back our minor */\n\tusb_deregister_dev(interface, &yurex_class);\n\n\t/* prevent more I/O from starting */\n\tmutex_lock(&dev->io_mutex);\n\tdev->interface = NULL;\n\tmutex_unlock(&dev->io_mutex);\n\n\t/* wakeup waiters */\n\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\twake_up_interruptible(&dev->waitq);\n\n\t/* decrement our usage count */\n\tkref_put(&dev->kref, yurex_delete);\n\n\tdev_info(&interface->dev, \"USB YUREX #%d now disconnected\\n\", minor);\n}",
        "output": "1",
        "idx": 1217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline double atanh(const double x) {\n#if cimg_use_cpp11==1 && !defined(_MSC_VER)\n      return std::atanh(x);\n#else\n      return 0.5*std::log((1. + x)/(1. - x));\n#endif\n    }",
        "output": "0",
        "idx": 3991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_system_reset(void)\n\n{\n\n    QEMUResetEntry *re, *nre;\n\n\n\n    /* reset all devices */\n\n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n\n        re->func(re->opaque);\n\n    }\n\n\n}",
        "output": "1",
        "idx": 4994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n    int src_len, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    pd = dest;\n\n    if (src_len & 1)\n\n        *pd++ = *ps++;\n\n\n\n    src_len >>= 1;\n\n    i = 0;\n\n    do {\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_len);\n\n\n\n    return ps - src;\n\n}\n",
        "output": "1",
        "idx": 1910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {\n\tif ( oldV == newV ) {\n\t\tMSG_WriteBits( msg, 0, 1 );\n\t\treturn;\n\t}\n\tMSG_WriteBits( msg, 1, 1 );\n\tMSG_WriteBits( msg, newV ^ key, bits );\n}",
        "output": "0",
        "idx": 2102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)\n\n{\n\n    c->high = 255;\n\n    c->bits = -16;\n\n    c->buffer = buf;\n\n    c->end = buf + buf_size;\n\n    c->code_word = bytestream_get_be24(&c->buffer);\n\n}\n",
        "output": "1",
        "idx": 5449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static js_Ast *additive(js_State *J)\n{\n\tjs_Ast *a = multiplicative(J);\nloop:\n\tif (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }\n\tif (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }\n\treturn a;\n}",
        "output": "1",
        "idx": 1651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BIO_ADDR_make(BIO_ADDR *ap, const struct sockaddr *sa)\n{\n    if (sa->sa_family == AF_INET) {\n        ap->s_in = *(const struct sockaddr_in *)sa;\n        return 1;\n    }\n#ifdef AF_INET6\n    if (sa->sa_family == AF_INET6) {\n        ap->s_in6 = *(const struct sockaddr_in6 *)sa;\n        return 1;\n    }\n#endif\n#ifdef AF_UNIX\n    if (sa->sa_family == AF_UNIX) {\n        ap->s_un = *(const struct sockaddr_un *)sa;\n        return 1;\n    }\n#endif\n\n    return 0;\n}",
        "output": "0",
        "idx": 1842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ConvertTimeZoneAbbrevs(TimeZoneAbbrevTable *tbl,\n\t\t\t\t\t   struct tzEntry *abbrevs, int n)\n{\n\tdatetkn    *newtbl = tbl->abbrevs;\n\tint\t\t\ti;\n\n\ttbl->numabbrevs = n;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstrncpy(newtbl[i].token, abbrevs[i].abbrev, TOKMAXLEN);\n\t\tnewtbl[i].type = abbrevs[i].is_dst ? DTZ : TZ;\n\t\tTOVAL(&newtbl[i], abbrevs[i].offset / MINS_PER_HOUR);\n\t}\n\n\t/* Check the ordering, if testing */\n\tAssert(CheckDateTokenTable(\"timezone offset\", newtbl, n));\n}",
        "output": "1",
        "idx": 6009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,\n\n                          int *end_pos2)\n\n{\n\n    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {\n\n        s->gb           = s->in_gb;\n\n        s->in_gb.buffer = NULL;\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        skip_bits_long(&s->gb, *pos - *end_pos);\n\n        *end_pos2 =\n\n        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;\n\n        *pos      = get_bits_count(&s->gb);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sco_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\t/* Kill socket */\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\n\tif (sk) {\n\t\tsock_hold(sk);\n\t\tbh_lock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsco_chan_del(sk, err);\n\t\tbh_unlock_sock(sk);\n\t\tsco_sock_kill(sk);\n\t\tsock_put(sk);\n\t}\n\n\thcon->sco_data = NULL;\n\tkfree(conn);\n}",
        "output": "0",
        "idx": 1404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)\n{\n\tGSList *l;\n\tstruct pending_req *req;\n\n\twhile ((l = g_slist_find_custom(session->prio_queue, stream,\n\t\t\t\t\t\t\tpending_req_cmp))) {\n\t\treq = l->data;\n\t\tpending_req_free(req);\n\t\tsession->prio_queue = g_slist_remove(session->prio_queue, req);\n\t}\n\n\twhile ((l = g_slist_find_custom(session->req_queue, stream,\n\t\t\t\t\t\t\tpending_req_cmp))) {\n\t\treq = l->data;\n\t\tpending_req_free(req);\n\t\tsession->req_queue = g_slist_remove(session->req_queue, req);\n\t}\n}",
        "output": "0",
        "idx": 901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Free resources */\n\n    qemu_iovec_destroy(&acb->cur_qiov);\n\n    qed_unref_l2_cache_entry(acb->request.l2_table);\n\n\n\n    /* Free the buffer we may have allocated for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        qemu_vfree(acb->qiov->iov[0].iov_base);\n\n        acb->qiov->iov[0].iov_base = NULL;\n\n    }\n\n\n\n    /* Start next allocating write request waiting behind this one.  Note that\n\n     * requests enqueue themselves when they first hit an unallocated cluster\n\n     * but they wait until the entire request is finished before waking up the\n\n     * next request in the queue.  This ensures that we don't cycle through\n\n     * requests multiple times but rather finish one at a time completely.\n\n     */\n\n    if (acb == s->allocating_acb) {\n\n        s->allocating_acb = NULL;\n\n        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {\n\n            qemu_co_enter_next(&s->allocating_write_reqs);\n\n        } else if (s->header.features & QED_F_NEED_CHECK) {\n\n            qed_start_need_check_timer(s);\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_send_alert(SSL *s, int level, int desc)\n{\n    /* Map tls/ssl alert value to correct one */\n    desc = s->method->ssl3_enc->alert_value(desc);\n    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)\n        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have\n                                          * protocol_version alerts */\n    if (desc < 0)\n        return -1;\n    /* If a fatal one, remove from cache */\n    if ((level == 2) && (s->session != NULL))\n        SSL_CTX_remove_session(s->session_ctx, s->session);\n\n    s->s3->alert_dispatch = 1;\n    s->s3->send_alert[0] = level;\n    s->s3->send_alert[1] = desc;\n    if (s->s3->wbuf.left == 0)  /* data still being written out? */\n        return s->method->ssl_dispatch_alert(s);\n    /*\n     * else data is still being written out, we will get written some time in\n     * the future\n     */\n    return -1;\n}",
        "output": "1",
        "idx": 5052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_assignlist(asdl_seq *targets, expr_context_ty ctx)\n{\n    return validate_nonempty_seq(targets, \"targets\", ctx == Del ? \"Delete\" : \"Assign\") &&\n        validate_exprs(targets, ctx, 0);\n}",
        "output": "0",
        "idx": 5853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)\n{\n  int i;\n  int* rarray;\n\n  MALLOC(rarray, d->states[s].mbps.nelem);\n  for (i = 0; i < d->states[s].mbps.nelem; ++i)\n    {\n      position pos = d->states[s].mbps.elems[i];\n      switch(d->tokens[pos.index])\n        {\n        case ANYCHAR:\n          rarray[i] = match_anychar(d, s, pos, idx);\n          break;\n        case MBCSET:\n          rarray[i] = match_mb_charset(d, s, pos, idx);\n          break;\n        default:\n          break; /* cannot happen.  */\n        }\n    }\n  return rarray;\n}",
        "output": "1",
        "idx": 3053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n",
        "output": "0",
        "idx": 418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    UINT32 i;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(&target->count, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->count > MAX_TAGGED_POLICIES) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\trc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 3793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    /* Clear the remaining bytes in the last word.  */\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n\n    return size;\n}",
        "output": "1",
        "idx": 431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(getcwd)\n{\n\tchar path[MAXPATHLEN];\n\tchar *ret=NULL;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n#if HAVE_GETCWD\n\tret = VCWD_GETCWD(path, MAXPATHLEN);\n#elif HAVE_GETWD\n\tret = VCWD_GETWD(path);\n#endif\n\n\tif (ret) {\n\t\tRETURN_STRING(path, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "1",
        "idx": 2464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)\n{\n\tDropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);\n\n\tCOPY_STRING_FIELD(tablespacename);\n\tCOPY_SCALAR_FIELD(missing_ok);\n\n\treturn newnode;\n}",
        "output": "0",
        "idx": 465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nautilus_file_list_free (GList *list)\n{\n\tnautilus_file_list_unref (list);\n\tg_list_free (list);\n}",
        "output": "0",
        "idx": 2717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool IsSupported(const NodeDef* node) const override {\n    return IsAnySparseSegmentReduction(*node);\n  }",
        "output": "0",
        "idx": 5063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool pc_machine_get_nvdimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->nvdimm;\n\n}\n",
        "output": "0",
        "idx": 4374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string dump_time_to_str(const real_time& t)\n{\n  char timestr[TIME_BUF_SIZE];\n  dump_time_header_impl(timestr, t);\n\n  return timestr;\n}",
        "output": "0",
        "idx": 2851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_pyeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_pyeval(str, rettv);\n}",
        "output": "1",
        "idx": 1277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n",
        "output": "1",
        "idx": 3287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)\n{\n\tif (!access_ok(VERIFY_WRITE, up, sizeof(*up)))\n\t\treturn -EFAULT;\n\treturn __put_v4l2_format32(kp, up);\n}",
        "output": "1",
        "idx": 2796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}",
        "output": "1",
        "idx": 588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n",
        "output": "0",
        "idx": 1474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n",
        "output": "1",
        "idx": 4883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "loop_info(\n\tsockaddr_u *srcadr,\n\tendpt *inter,\n\tstruct req_pkt *inpkt\n\t)\n{\n\tstruct info_loop *li;\n\tl_fp ltmp;\n\n\tli = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,\n\t    sizeof(struct info_loop));\n\n\tDTOLFP(last_offset, &ltmp);\n\tHTONL_FP(&ltmp, &li->last_offset);\n\tDTOLFP(drift_comp * 1e6, &ltmp);\n\tHTONL_FP(&ltmp, &li->drift_comp);\n\tli->compliance = htonl((u_int32)(tc_counter));\n\tli->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));\n\n\tmore_pkt();\n\tflush_pkt();\n}",
        "output": "1",
        "idx": 1731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n",
        "output": "1",
        "idx": 4104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bucket_insert (index_bucket *bucket,\n               CK_OBJECT_HANDLE handle)\n{\n\tunsigned int alloc;\n\tint at = 0;\n\n\tif (bucket->elem) {\n\t\tat = binary_search (bucket->elem, 0, bucket->num, handle);\n\t\tif (at < bucket->num && bucket->elem[at] == handle)\n\t\t\treturn;\n\t}\n\n\talloc = alloc_size (bucket->num);\n\tif (bucket->num + 1 > alloc) {\n\t\tCK_OBJECT_HANDLE *elem;\n\n\t\talloc = alloc ? alloc * 2 : 1;\n\t\treturn_if_fail (alloc != 0);\n\t\telem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));\n\t\treturn_if_fail (elem != NULL);\n\t\tbucket->elem = elem;\n\t}\n\n\treturn_if_fail (bucket->elem != NULL);\n\tmemmove (bucket->elem + at + 1, bucket->elem + at,\n\t         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));\n\tbucket->elem[at] = handle;\n\tbucket->num++;\n}",
        "output": "1",
        "idx": 332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Avahi::addService(int, int, const QString &name, const QString &type, const QString &domain, uint)\n{\n    if (isLocalDomain(domain) && !services.contains(name)) {\n        AvahiService *srv=new AvahiService(name, type, domain);\n        services.insert(name, srv);\n        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));\n    }\n}",
        "output": "1",
        "idx": 4998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ppc4xx_pob_reset (void *opaque)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    /* No error */\n\n    pob->bear = 0x00000000;\n\n    pob->besr[0] = 0x0000000;\n\n    pob->besr[1] = 0x0000000;\n\n}\n",
        "output": "1",
        "idx": 2273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n        int v = get_bits(&s->gb, 8);\n\n        if (v == 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\");\n\n            return -1;\n\n        }\n\n        if (intra && i == 0 && v != 8) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix specifies invalid DC quantizer %d, ignoring\\n\", v);\n\n            v = 8; // needed by pink.mpg / issue1046\n\n        }\n\n        matrix0[j] = v;\n\n        if (matrix1)\n\n            matrix1[j] = v;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 3479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl_clear_bad_session(SSL *s)\n{\n    if ((s->session != NULL) &&\n        !(s->shutdown & SSL_SENT_SHUTDOWN) &&\n        !(SSL_in_init(s) || SSL_in_before(s))) {\n        SSL_CTX_remove_session(s->ctx, s->session);\n        return (1);\n    } else\n        return (0);\n}",
        "output": "0",
        "idx": 5746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){\n\n    int i;\n\n\n\n    for(i=0; i<w-1; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n        i++;\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    for(; i<w; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    return acc;\n\n}\n",
        "output": "1",
        "idx": 3400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "calc_binint(char *bytes, int nbytes)\n{\n    unsigned char *s = (unsigned char *)bytes;\n    Py_ssize_t i;\n    long x = 0;\n\n    for (i = 0; i < nbytes; i++) {\n        x |= (long)s[i] << (8 * i);\n    }\n\n    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)\n     * is signed, so on a box with longs bigger than 4 bytes we need\n     * to extend a BININT's sign bit to the full width.\n     */\n    if (SIZEOF_LONG > 4 && nbytes == 4) {\n        x |= -(x & (1L << 31));\n    }\n\n    return x;\n}",
        "output": "0",
        "idx": 2983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}",
        "output": "1",
        "idx": 4932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline WordCount SegmentReader::getOffsetTo(const word* ptr) {\n  return intervalLength(this->ptr.begin(), ptr);\n}",
        "output": "0",
        "idx": 4164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 1790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "val_exp_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_buffer_t interprocess_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (interprocess_token != GSS_C_NO_BUFFER) {\n\tinterprocess_token->length = 0;\n\tinterprocess_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL || *context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (interprocess_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}",
        "output": "0",
        "idx": 1388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}",
        "output": "1",
        "idx": 5692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  dump_start(s);\n  // Explicitly use chunked transfer encoding so that we can stream the result\n  // to the user without having to wait for the full length of it.\n  end_header(s, NULL, \"application/xml\", CHUNKED_TRANSFER_ENCODING);\n\n  if (! op_ret) {\n    list_all_buckets_start(s);\n    dump_owner(s, s->user->user_id, s->user->display_name);\n    s->formatter->open_array_section(\"Buckets\");\n    sent_data = true;\n  }\n}",
        "output": "0",
        "idx": 5618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n",
        "output": "1",
        "idx": 1653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    bool contains(const T& pixel, t& x, t& y, t& z) const {\n      const ulongT wh = (ulongT)_width*_height, whd = wh*_depth, siz = whd*_spectrum;\n      const T *const ppixel = &pixel;\n      if (is_empty() || ppixel<_data || ppixel>=_data + siz) return false;\n      ulongT off = ((ulongT)(ppixel - _data))%whd;\n      const ulongT nz = off/wh;\n      off%=wh;\n      const ulongT ny = off/_width, nx = off%_width;\n      x = (t)nx; y = (t)ny; z = (t)nz;\n      return true;\n    }",
        "output": "0",
        "idx": 2652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 2573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NO_INLINE JsVar *jspParse() {\n  JsVar *v = 0;\n  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {\n    jsvUnLock(v);\n    v = jspeBlockOrStatement();\n  }\n  return v;\n}",
        "output": "0",
        "idx": 5626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();",
        "output": "1",
        "idx": 521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)\n{\n\tstruct ttm_bo_device *bdev = bo->bdev;\n\tuint32_t page_flags = 0;\n\n\tdma_resv_assert_held(bo->base.resv);\n\n\tif (bo->ttm)\n\t\treturn 0;\n\n\tif (bdev->need_dma32)\n\t\tpage_flags |= TTM_PAGE_FLAG_DMA32;\n\n\tif (bdev->no_retry)\n\t\tpage_flags |= TTM_PAGE_FLAG_NO_RETRY;\n\n\tswitch (bo->type) {\n\tcase ttm_bo_type_device:\n\t\tif (zero_alloc)\n\t\t\tpage_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;\n\t\tbreak;\n\tcase ttm_bo_type_kernel:\n\t\tbreak;\n\tcase ttm_bo_type_sg:\n\t\tpage_flags |= TTM_PAGE_FLAG_SG;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Illegal buffer object type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);\n\tif (unlikely(bo->ttm == NULL))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->compress_flags = compress_flags;\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 2257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\terr = fuse_do_readpage(file, page);\n\tfuse_invalidate_atime(inode);\n out:\n\tunlock_page(page);\n\treturn err;\n}",
        "output": "1",
        "idx": 4880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}",
        "output": "1",
        "idx": 4701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;",
        "output": "1",
        "idx": 3498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n",
        "output": "1",
        "idx": 2878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    int64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    mr = host_memory_backend_get_memory(dimm->hostmem, errp);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_int(v, name, &value, errp);\n\n}\n",
        "output": "0",
        "idx": 5601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ip_vs_lookup_real_service(int af, __u16 protocol,\n\t\t\t  const union nf_inet_addr *daddr,\n\t\t\t  __be16 dport)\n{\n\tunsigned hash;\n\tstruct ip_vs_dest *dest;\n\n\t/*\n\t *\tCheck for \"full\" addressed entries\n\t *\tReturn the first found entry\n\t */\n\thash = ip_vs_rs_hashkey(af, daddr, dport);\n\n\tread_lock(&__ip_vs_rs_lock);\n\tlist_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {\n\t\tif ((dest->af == af)\n\t\t    && ip_vs_addr_equal(af, &dest->addr, daddr)\n\t\t    && (dest->port == dport)\n\t\t    && ((dest->protocol == protocol) ||\n\t\t\tdest->vfwmark)) {\n\t\t\t/* HIT */\n\t\t\tread_unlock(&__ip_vs_rs_lock);\n\t\t\treturn dest;\n\t\t}\n\t}\n\tread_unlock(&__ip_vs_rs_lock);\n\n\treturn NULL;\n}",
        "output": "0",
        "idx": 1041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,\n\t\t\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tu64 bytes, packets;\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_irq(&ring->syncp);\n\t\tpackets = ring->stats.packets;\n\t\tbytes   = ring->stats.bytes;\n\t} while (u64_stats_fetch_retry_irq(&ring->syncp, start));\n\n\tstats->tx_packets += packets;\n\tstats->tx_bytes   += bytes;\n}",
        "output": "0",
        "idx": 2799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}",
        "output": "0",
        "idx": 6299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    ref *pvalue;\n\n    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&\n          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&\n          r_has_type(pvalue, t_integer))\n        )\n        return gs_param_policy_ignore;\n    return (int)pvalue->value.intval;\n}",
        "output": "0",
        "idx": 5150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\txdr_buf_tail_copy_left(buf, base, len, shift);\n}",
        "output": "0",
        "idx": 3027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool isIdIndex(const BSONObj& pattern) {\n    BSONObjIterator i(pattern);\n    BSONElement e = i.next();\n    //_id index must have form exactly {_id : 1} or {_id : -1}.\n    // Allows an index of form {_id : \"hashed\"} to exist but\n    // do not consider it to be the primary _id index\n    if (!(strcmp(e.fieldName(), \"_id\") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))\n        return false;\n    return i.next().eoo();\n}",
        "output": "0",
        "idx": 4012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "htmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n\n    /*\n     * Handler for more complex cases\n     */\n    GROW;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */\n\t(!IS_LETTER(c) && (c != '_') &&\n         (c != ':'))) {\n\treturn(NULL);\n    }\n\n    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */\n\t   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n            (c == '.') || (c == '-') ||\n\t    (c == '_') || (c == ':') ||\n\t    (IS_COMBINING(c)) ||\n\t    (IS_EXTENDER(c)))) {\n\tif (count++ > 100) {\n\t    count = 0;\n\t    GROW;\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n    }\n    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));\n}",
        "output": "1",
        "idx": 2534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n",
        "output": "0",
        "idx": 3698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct vhost_net *n = file->private_data;\n\tstruct vhost_dev *dev = &n->dev;\n\n\treturn vhost_chr_write_iter(dev, from);\n}",
        "output": "0",
        "idx": 1300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}",
        "output": "1",
        "idx": 5507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n",
        "output": "1",
        "idx": 5502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0;\n\n\n\n    dc0=0;\n\n    for(i=0;i<8; i++)\n\n        dc0+= src[i-stride];\n\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]=\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 6251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n",
        "output": "0",
        "idx": 2350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ldap_decode_attrib(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n\t\t\t       struct ldb_message_element *attrib)\n{\n\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n\tasn1_read_OctetString_talloc(mem_ctx, data, &attrib->name);\n\tasn1_start_tag(data, ASN1_SET);\n\twhile (asn1_peek_tag(data, ASN1_OCTET_STRING)) {\n\t\tDATA_BLOB blob;\n\t\tasn1_read_OctetString(data, mem_ctx, &blob);\n\t\tadd_value_to_attrib(mem_ctx, &blob, attrib);\n\t}\n\tasn1_end_tag(data);\n\tasn1_end_tag(data);\n\t\n}",
        "output": "1",
        "idx": 5085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GENERAL_NAME_set0_value(GENERAL_NAME *a, int type, void *value)\n{\n    switch (type) {\n    case GEN_X400:\n    case GEN_EDIPARTY:\n        a->d.other = value;\n        break;\n\n    case GEN_OTHERNAME:\n        a->d.otherName = value;\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        a->d.ia5 = value;\n        break;\n\n    case GEN_DIRNAME:\n        a->d.dirn = value;\n        break;\n\n    case GEN_IPADD:\n        a->d.ip = value;\n        break;\n\n    case GEN_RID:\n        a->d.rid = value;\n        break;\n    }\n    a->type = type;\n}",
        "output": "1",
        "idx": 2904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn -ENOSYS;\n}",
        "output": "1",
        "idx": 1384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {\n\tRBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);\n\tif (local_name) {\n\t\tif (!consume_u32_r (b, bound, &local_name->index)) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tlocal_name->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!local_name->names) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\treturn local_name;\n\t}\nbeach:\n\twasm_custom_name_local_free (local_name);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 3160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n",
        "output": "1",
        "idx": 3276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipv6_mc_unmap(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *i;\n\n\t/* Install multicast list, except for all-nodes (already installed) */\n\n\tmutex_lock(&idev->mc_lock);\n\tfor_each_mc_mclock(idev, i)\n\t\tigmp6_group_dropped(i);\n\tmutex_unlock(&idev->mc_lock);\n}",
        "output": "0",
        "idx": 2560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}",
        "output": "1",
        "idx": 6124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n\n        return 1;\n} /* end readContigStripsIntoBuffer */",
        "output": "1",
        "idx": 516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_nc_find_user_entry(const char *string)\n{\n    const HashData *data = _nc_get_hash_user();\n    int hashvalue;\n    struct user_table_entry const *ptr = 0;\n    struct user_table_entry const *real_table;\n\n    hashvalue = data->hash_of(string);\n\n    if (data->table_data[hashvalue] >= 0) {\n\n\treal_table = _nc_get_userdefs_table();\n\tptr = real_table + data->table_data[hashvalue];\n\twhile (!data->compare_names(ptr->ute_name, string)) {\n\t    if (ptr->ute_link < 0) {\n\t\tptr = 0;\n\t\tbreak;\n\t    }\n\t    ptr = real_table + (ptr->ute_link\n\t\t\t\t+ data->table_data[data->table_size]);\n\t}\n    }\n\n    return (ptr);\n}",
        "output": "1",
        "idx": 3884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "     \\param user_path Specified path, or \\c 0 to get the path currently used.\n     \\param reinit_path Force path to be recalculated (may take some time).\n     \\return Path containing the \\c gzip binary.\n  **/\n  inline const char *gzip_path(const char *const user_path, const bool reinit_path) {\n    static CImg<char> s_path;\n    cimg::mutex(7);\n    if (reinit_path) s_path.assign();\n    if (user_path) {\n      if (!s_path) s_path.assign(1024);\n      std::strncpy(s_path,user_path,1023);\n    } else if (!s_path) {\n      s_path.assign(1024);\n      bool path_found = false;\n      std::FILE *file = 0;\n#if cimg_OS==2\n      if (!path_found) {\n        std::strcpy(s_path,\".\\\\gzip.exe\");\n        if ((file=std_fopen(s_path,\"r\"))!=0) { cimg::fclose(file); path_found = true; }\n      }\n      if (!path_found) std::strcpy(s_path,\"gzip.exe\");\n#else\n      if (!path_found) {\n        std::strcpy(s_path,\"./gzip\");\n        if ((file=std_fopen(s_path,\"r\"))!=0) { cimg::fclose(file); path_found = true; }\n      }\n      if (!path_found) std::strcpy(s_path,\"gzip\");\n#endif\n      winformat_string(s_path);",
        "output": "0",
        "idx": 515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n",
        "output": "1",
        "idx": 5402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}",
        "output": "1",
        "idx": 4563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {\n    // true means multikey\n    addIndex(BSON(\"a.b\" << 1 << \"a.c\" << 1), true);\n    runQuery(fromjson(\"{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}\"));\n\n    assertNumSolutions(3U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: \"\n        \"{'a.b': [[1,1,true,true]], \"\n        \" 'a.c': [[1,1,true,true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: \"\n        \"{'a.b': [[1,1,true,true]], \"\n        \" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}\");\n}",
        "output": "0",
        "idx": 2559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}",
        "output": "1",
        "idx": 784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int estimate_qp(MpegEncContext *s, int dry_run){\n\n    if (s->next_lambda){\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = s->next_lambda;\n\n        if(!dry_run) s->next_lambda= 0;\n\n    } else if (!s->fixed_qscale) {\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);\n\n        if (s->current_picture.f.quality < 0)\n\n            return -1;\n\n    }\n\n\n\n    if(s->adaptive_quant){\n\n        switch(s->codec_id){\n\n        case AV_CODEC_ID_MPEG4:\n\n            if (CONFIG_MPEG4_ENCODER)\n\n                ff_clean_mpeg4_qscales(s);\n\n            break;\n\n        case AV_CODEC_ID_H263:\n\n        case AV_CODEC_ID_H263P:\n\n        case AV_CODEC_ID_FLV1:\n\n            if (CONFIG_H263_ENCODER)\n\n                ff_clean_h263_qscales(s);\n\n            break;\n\n        default:\n\n            ff_init_qscale_tab(s);\n\n        }\n\n\n\n        s->lambda= s->lambda_table[0];\n\n        //FIXME broken\n\n    }else\n\n        s->lambda = s->current_picture.f.quality;\n\n    update_qscale(s);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 5034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n",
        "output": "1",
        "idx": 15
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void create_map(vorbis_context *vc, unsigned floor_number)\n\n{\n\n    vorbis_floor *floors = vc->floors;\n\n    vorbis_floor0 *vf;\n\n    int idx;\n\n    int blockflag, n;\n\n    int32_t *map;\n\n\n\n    for (blockflag = 0; blockflag < 2; ++blockflag) {\n\n        n = vc->blocksize[blockflag] / 2;\n\n        floors[floor_number].data.t0.map[blockflag] =\n\n            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel\n\n\n\n        map =  floors[floor_number].data.t0.map[blockflag];\n\n        vf  = &floors[floor_number].data.t0;\n\n\n\n        for (idx = 0; idx < n; ++idx) {\n\n            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *\n\n                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));\n\n            if (vf->bark_map_size-1 < map[idx])\n\n                map[idx] = vf->bark_map_size - 1;\n\n        }\n\n        map[n] = -1;\n\n        vf->map_size[blockflag] = n;\n\n    }\n\n\n\n    for (idx = 0; idx <= n; ++idx) {\n\n        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 5492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg;\n\n    rb_scan_args(argc, argv, \"02\", &str, &sg);\n\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n\n    {\n\tVALUE hash = date_s__iso8601(klass, str);\n\treturn dt_new_by_frags(klass, hash, sg);\n    }\n}",
        "output": "1",
        "idx": 4341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool blk_dev_is_tray_open(BlockBackend *blk)\n\n{\n\n    if (blk->dev_ops && blk->dev_ops->is_tray_open) {\n\n        return blk->dev_ops->is_tray_open(blk->dev_opaque);\n\n    }\n\n    return false;\n\n}\n",
        "output": "0",
        "idx": 5186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)\n\n{\n\n    USBHubPort *port;\n\n    USBDevice *dev;\n\n    int i, ret;\n\n\n\n    for(i = 0; i < NUM_PORTS; i++) {\n\n        port = &s->ports[i];\n\n        dev = port->port.dev;\n\n        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {\n\n            ret = usb_handle_packet(dev, p);\n\n            if (ret != USB_RET_NODEV) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return USB_RET_NODEV;\n\n}\n",
        "output": "0",
        "idx": 778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n",
        "output": "0",
        "idx": 2617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 6284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dump_branches(void)\n{\n\tunsigned int i;\n\tstruct branch *b;\n\n\tfor (i = 0; i < branch_table_sz; i++) {\n\t\tfor (b = branch_table[i]; b; b = b->table_next_branch)\n\t\t\tfailure |= update_branch(b);\n\t}\n}",
        "output": "0",
        "idx": 5816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdk_pixbuf__gif_image_load_animation (FILE *file,\n                                      GError **error)\n{\n\tGifContext *context;\n\tGdkPixbufAnimation *animation;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\n        context->error = error;\n\tcontext->file = file;\n\n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error (context->error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n\n                g_object_unref (G_OBJECT (context->animation));\n                context->animation = NULL;\n        }\n\n        if (context->animation)\n                animation = GDK_PIXBUF_ANIMATION (context->animation);\n        else\n                animation = NULL;\n\n        if (context->error && *(context->error))\n                g_print (\"%s\\n\", (*(context->error))->message);\n        \n        g_free (context->buf);\n\tg_free (context);\n\treturn animation;\n}",
        "output": "1",
        "idx": 651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}",
        "output": "1",
        "idx": 3866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}",
        "output": "0",
        "idx": 390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        AsyncPolkitQuery *q = userdata;\n        int r;\n\n        assert(reply);\n        assert(q);\n\n        q->slot = sd_bus_slot_unref(q->slot);\n        q->reply = sd_bus_message_ref(reply);\n\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0) {\n                r = sd_bus_reply_method_errno(q->request, r, NULL);\n                goto finish;\n        }\n\n        r = q->callback(q->request, q->userdata, &error_buffer);\n        r = bus_maybe_reply_error(q->request, r, &error_buffer);\n\nfinish:\n        async_polkit_query_free(q);\n\n        return r;\n}",
        "output": "1",
        "idx": 5698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "null_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n}",
        "output": "1",
        "idx": 5929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 1433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cgit_print_http_headers(void)\n{\n\tif (ctx.env.no_http && !strcmp(ctx.env.no_http, \"1\"))\n\t\treturn;\n\n\tif (ctx.page.status)\n\t\thtmlf(\"Status: %d %s\\n\", ctx.page.status, ctx.page.statusmsg);\n\tif (ctx.page.mimetype && ctx.page.charset)\n\t\thtmlf(\"Content-Type: %s; charset=%s\\n\", ctx.page.mimetype,\n\t\t      ctx.page.charset);\n\telse if (ctx.page.mimetype)\n\t\thtmlf(\"Content-Type: %s\\n\", ctx.page.mimetype);\n\tif (ctx.page.size)\n\t\thtmlf(\"Content-Length: %zd\\n\", ctx.page.size);\n\tif (ctx.page.filename)\n\t\thtmlf(\"Content-Disposition: inline; filename=\\\"%s\\\"\\n\",\n\t\t      ctx.page.filename);\n\tif (!ctx.env.authenticated)\n\t\thtml(\"Cache-Control: no-cache, no-store\\n\");\n\thtmlf(\"Last-Modified: %s\\n\", http_date(ctx.page.modified));\n\thtmlf(\"Expires: %s\\n\", http_date(ctx.page.expires));\n\tif (ctx.page.etag)\n\t\thtmlf(\"ETag: \\\"%s\\\"\\n\", ctx.page.etag);\n\thtml(\"\\n\");\n\tif (ctx.env.request_method && !strcmp(ctx.env.request_method, \"HEAD\"))\n\t\texit(0);\n}",
        "output": "1",
        "idx": 6036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t parse_gain(const char *gain)\n\n{\n\n    char *fraction;\n\n    int  scale = 10000;\n\n    int32_t mb = 0;\n\n    int sign   = 1;\n\n    int db;\n\n\n\n    if (!gain)\n\n        return INT32_MIN;\n\n\n\n    gain += strspn(gain, \" \\t\");\n\n\n\n    if (*gain == '-')\n\n        sign = -1;\n\n\n\n    db = strtol(gain, &fraction, 0);\n\n    if (*fraction++ == '.') {\n\n        while (av_isdigit(*fraction) && scale) {\n\n            mb += scale * (*fraction - '0');\n\n            scale /= 10;\n\n            fraction++;\n\n        }\n\n    }\n\n\n\n    if (abs(db) > (INT32_MAX - mb) / 100000)\n\n        return INT32_MIN;\n\n\n\n    return db * 100000 + sign * mb;\n\n}\n",
        "output": "1",
        "idx": 4601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long align_sigframe(unsigned long sp)\n{\n#ifdef CONFIG_X86_32\n\t/*\n\t * Align the stack pointer according to the i386 ABI,\n\t * i.e. so that on function entry ((sp + 4) & 15) == 0.\n\t */\n\tsp = ((sp + 4) & -16ul) - 4;\n#else /* !CONFIG_X86_32 */\n\tsp = round_down(sp, 16) - 8;\n#endif\n\treturn sp;\n}",
        "output": "0",
        "idx": 3583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"stbl\");\n\n    mov_write_stsd_tag(pb, track);\n\n    mov_write_stts_tag(pb, track);\n\n    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&\n\n        track->has_keyframes && track->has_keyframes < track->entry)\n\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n        track->flags & MOV_TRACK_CTTS && track->entry)\n\n        mov_write_ctts_tag(pb, track);\n\n    mov_write_stsc_tag(pb, track);\n\n    mov_write_stsz_tag(pb, track);\n\n    mov_write_stco_tag(pb, track);\n\n    return update_size(pb, pos);\n\n}\n",
        "output": "1",
        "idx": 1083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,\n\n                                               abi_ulong target_addr)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))\n\n        return -TARGET_EFAULT;\n\n    host_ts->tv_sec = tswapal(target_ts->tv_sec);\n\n    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 0);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_serial_register_types(void)\n{\n    type_register_static(&virtser_bus_info);\n    type_register_static(&virtio_serial_port_type_info);\n    type_register_static(&virtio_device_info);\n}",
        "output": "0",
        "idx": 5874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1]<<16;\n\n    return (b+r) << 1;\n\n}\n",
        "output": "1",
        "idx": 461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n",
        "output": "1",
        "idx": 229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)\n{\n    return nic->ncs + queue_index;\n}",
        "output": "0",
        "idx": 5447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
        "output": "1",
        "idx": 3201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TopologyManager::onServerRTTUpdated(HostAndPort hostAndPort, IsMasterRTT rtt) {\n    {\n        stdx::lock_guard<mongo::Mutex> lock(_mutex);\n\n        auto oldServerDescription = _topologyDescription->findServerByAddress(hostAndPort);\n        if (oldServerDescription) {\n            auto newServerDescription = (*oldServerDescription)->cloneWithRTT(rtt);\n\n            auto oldTopologyDescription = _topologyDescription;\n            _topologyDescription = std::make_shared<TopologyDescription>(*_topologyDescription);\n            _topologyDescription->installServerDescription(newServerDescription);\n\n            _publishTopologyDescriptionChanged(oldTopologyDescription, _topologyDescription);\n\n            return;\n        }\n    }\n    // otherwise, the server was removed from the topology. Nothing to do.\n    LOGV2(4333201,\n          \"Not updating RTT. Server {server} does not exist in {replicaSet}\",\n          \"Not updating RTT. The server does not exist in the replica set\",\n          \"server\"_attr = hostAndPort,\n          \"replicaSet\"_attr = getTopologyDescription()->getSetName());\n}",
        "output": "1",
        "idx": 5044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit IPCRenderer(v8::Isolate* isolate)\n      : content::RenderFrameObserver(GetCurrentRenderFrame()) {\n    RenderFrame* render_frame = GetCurrentRenderFrame();\n    DCHECK(render_frame);\n    weak_context_ =\n        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());\n    weak_context_.SetWeak();\n\n    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(\n        &electron_browser_remote_);\n  }",
        "output": "1",
        "idx": 1701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   OFB crypt/decrypt data using key key with cipher cipher starting with iv */\nPHP_FUNCTION(mcrypt_encrypt)\n{\n\tzval **mode;\n\tchar *cipher, *key, *data, *iv = NULL;\n\tint cipher_len, key_len, data_len, iv_len = 0;\n\t\n\tMCRYPT_GET_CRYPT_ARGS\n\t\n\tconvert_to_string_ex(mode);\n\n\tphp_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);",
        "output": "1",
        "idx": 1656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void omap_rtc_reset(struct omap_rtc_s *s)\n\n{\n\n    struct tm tm;\n\n\n\n    s->interrupts = 0;\n\n    s->comp_reg = 0;\n\n    s->running = 0;\n\n    s->pm_am = 0;\n\n    s->auto_comp = 0;\n\n    s->round = 0;\n\n    s->tick = qemu_get_clock(rt_clock);\n\n    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));\n\n    s->alarm_tm.tm_mday = 0x01;\n\n    s->status = 1 << 7;\n\n    qemu_get_timedate(&tm, 0);\n\n    s->ti = mktimegm(&tm);\n\n\n\n    omap_rtc_alarm_update(s);\n\n    omap_rtc_tick(s);\n\n}\n",
        "output": "0",
        "idx": 5687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_compat_mq_attr(struct mq_attr *attr,\n\t\t\tconst struct compat_mq_attr __user *uattr)\n{\n\tstruct compat_mq_attr v;\n\n\tif (copy_from_user(&v, uattr, sizeof(*uattr)))\n\t\treturn -EFAULT;\n\n\tmemset(attr, 0, sizeof(*attr));\n\tattr->mq_flags = v.mq_flags;\n\tattr->mq_maxmsg = v.mq_maxmsg;\n\tattr->mq_msgsize = v.mq_msgsize;\n\tattr->mq_curmsgs = v.mq_curmsgs;\n\treturn 0;\n}",
        "output": "0",
        "idx": 6147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n",
        "output": "1",
        "idx": 2816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n",
        "output": "0",
        "idx": 5538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool pipe_writable(const struct pipe_inode_info *pipe)\n{\n\tunsigned int head = READ_ONCE(pipe->head);\n\tunsigned int tail = READ_ONCE(pipe->tail);\n\tunsigned int max_usage = READ_ONCE(pipe->max_usage);\n\n\treturn !pipe_full(head, tail, max_usage) ||\n\t\t!READ_ONCE(pipe->readers);\n}",
        "output": "0",
        "idx": 1980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FILE* safe_fopen(char const* filename, char const* mode)\n{\n    // This function is basically a \"C\" port of QUtil::safe_fopen.\n    FILE* f = 0;\n#ifdef _MSC_VER\n    errno_t err = fopen_s(&f, filename, mode);\n    if (err != 0)\n    {\n        char buf[94];\n        strerror_s(buf, sizeof(buf), errno);\n\tfprintf(stderr, \"%s: unable to open %s: %s\\n\",\n\t\twhoami, filename, buf);\n\texit(2);\n    }\n#else\n    f = fopen(filename, mode);\n    if (f == NULL)\n    {\n\tfprintf(stderr, \"%s: unable to open %s: %s\\n\",\n\t\twhoami, filename, strerror(errno));\n\texit(2);\n    }\n#endif\n    return f;\n}",
        "output": "0",
        "idx": 3862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ftp_abort(URLContext *h)\n\n{\n\n    static const char *command = \"ABOR\\r\\n\";\n\n    int err;\n\n    static const int abor_codes[] = {225, 226, 0};\n\n    FTPContext *s = h->priv_data;\n\n\n\n    /* According to RCF 959:\n\n       \"ABOR command tells the server to abort the previous FTP\n\n       service command and any associated transfer of data.\"\n\n\n\n       There are FTP server implementations that don't response\n\n       to any commands during data transfer in passive mode (including ABOR).\n\n\n\n       This implementation closes data connection by force.\n\n    */\n\n\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n\n        ftp_close_both_connections(s);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    } else {\n\n        ftp_close_data_connection(s);\n\n    }\n\n\n\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n\n        /* wu-ftpd also closes control connection after data connection closing */\n\n        ffurl_closep(&s->conn_control);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(pcntl_strerror)\n{\n        long error;\n\n        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &error) == FAILURE) {\n                RETURN_FALSE;\n        }\n\n        RETURN_STRING(strerror(error), 1);\n}",
        "output": "0",
        "idx": 2082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,\n\t\t\t    struct wait_queue_head *head,\n\t\t\t    struct io_poll_iocb **poll_ptr)\n{\n\tstruct io_kiocb *req = pt->req;\n\n\t/*\n\t * If poll->head is already set, it's because the file being polled\n\t * uses multiple waitqueues for poll handling (eg one for read, one\n\t * for write). Setup a separate io_poll_iocb if this happens.\n\t */\n\tif (unlikely(poll->head)) {\n\t\tstruct io_poll_iocb *poll_one = poll;\n\n\t\t/* already have a 2nd entry, fail a third attempt */\n\t\tif (*poll_ptr) {\n\t\t\tpt->error = -EINVAL;\n\t\t\treturn;\n\t\t}\n\t\tpoll = kmalloc(sizeof(*poll), GFP_ATOMIC);\n\t\tif (!poll) {\n\t\t\tpt->error = -ENOMEM;\n\t\t\treturn;\n\t\t}\n\t\tio_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);\n\t\trefcount_inc(&req->refs);\n\t\tpoll->wait.private = req;\n\t\t*poll_ptr = poll;\n\t}\n\n\tpt->error = 0;\n\tpoll->head = head;\n\n\tif (poll->events & EPOLLEXCLUSIVE)\n\t\tadd_wait_queue_exclusive(head, &poll->wait);\n\telse\n\t\tadd_wait_queue(head, &poll->wait);",
        "output": "0",
        "idx": 5313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,\n                                 hwaddr *plen, bool resolve_subpage)\n{\n    MemoryRegionSection *section;\n    MemoryRegion *mr;\n    Int128 diff;\n\n    section = address_space_lookup_region(d, addr, resolve_subpage);\n    /* Compute offset within MemoryRegionSection */\n    addr -= section->offset_within_address_space;\n\n    /* Compute offset within MemoryRegion */\n    *xlat = addr + section->offset_within_region;\n\n    mr = section->mr;\n    if (memory_region_is_ram(mr)) {\n        diff = int128_sub(mr->size, int128_make64(addr));\n        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));\n    }\n    return section;\n}",
        "output": "1",
        "idx": 2781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}",
        "output": "1",
        "idx": 2366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void switch_to_bitmap(unsigned long tifp) { }",
        "output": "1",
        "idx": 4712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void igmp_gq_start_timer(struct in_device *in_dev)\n{\n\tint tv = prandom_u32() % in_dev->mr_maxdelay;\n\tunsigned long exp = jiffies + tv + 2;\n\n\tif (in_dev->mr_gq_running &&\n\t    time_after_eq(exp, (in_dev->mr_gq_timer).expires))\n\t\treturn;\n\n\tin_dev->mr_gq_running = 1;\n\tif (!mod_timer(&in_dev->mr_gq_timer, exp))\n\t\tin_dev_hold(in_dev);\n}",
        "output": "0",
        "idx": 3381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t adts_frame(adts_header *adts, bitfile *ld)\n{\n    /* faad_byte_align(ld); */\n    if (adts_fixed_header(adts, ld))\n        return 5;\n    adts_variable_header(adts, ld);\n    adts_error_check(adts, ld);\n\n    return 0;\n}",
        "output": "0",
        "idx": 4043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemcpy(RTA_DATA(rta), data, attrlen);\n}",
        "output": "1",
        "idx": 4125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)\n{\n  CURLcode result = CURLE_OK;\n  enum dupstring i;\n\n  /* Copy src->set into dst->set first, then deal with the strings\n     afterwards */\n  dst->set = src->set;\n\n  /* clear all string pointers first */\n  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));\n\n  /* duplicate all strings */\n  for(i=(enum dupstring)0; i< STRING_LAST; i++) {\n    result = setstropt(&dst->set.str[i], src->set.str[i]);\n    if(result)\n      break;\n  }\n\n  /* If a failure occurred, freeing has to be performed externally. */\n  return result;\n}",
        "output": "1",
        "idx": 1895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Token *zap_white(Token *x)\n{\n    while (tok_white(x))\n        x = delete_Token(x);\n\n    return x;\n}",
        "output": "0",
        "idx": 2836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}",
        "output": "1",
        "idx": 6140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n",
        "output": "1",
        "idx": 2176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}",
        "output": "1",
        "idx": 620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) /* q is optional */\n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}",
        "output": "1",
        "idx": 2866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n",
        "output": "1",
        "idx": 4539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(HeaderMapImplTest, LargeCharInHeader) {\n  TestRequestHeaderMapImpl headers;\n  LowerCaseString static_key(\"\\x90hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n}",
        "output": "0",
        "idx": 4500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n",
        "output": "0",
        "idx": 5473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_efdneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 2295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n",
        "output": "1",
        "idx": 379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean\nmono_verifier_verify_class (MonoClass *class)\n{\n\t/*Neither <Module>, object or ifaces have parent.*/\n\tif (!class->parent &&\n\t\tclass != mono_defaults.object_class && \n\t\t!MONO_CLASS_IS_INTERFACE (class) &&\n\t\t(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/\n\t\treturn FALSE;\n\tif (class->parent) {\n\t\tif (MONO_CLASS_IS_INTERFACE (class->parent))\n\t\t\treturn FALSE;\n\t\tif (!class->generic_class && class->parent->generic_container)\n\t\t\treturn FALSE;\n\t}\n\tif (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)\n\t\treturn FALSE;\n\tif (class->generic_container && !verify_generic_parameters (class))\n\t\treturn FALSE;\n\tif (!verify_class_for_overlapping_reference_fields (class))\n\t\treturn FALSE;\n\tif (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))\n\t\treturn FALSE;\n\tif (class->generic_class == NULL && !verify_class_fields (class))\n\t\treturn FALSE;\n\tif (class->valuetype && !verify_valuetype_layout (class))\n\t\treturn FALSE;\n\tif (!verify_interfaces (class))\n\t\treturn FALSE;\n\treturn TRUE;",
        "output": "0",
        "idx": 1299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long get_devid(uint8_t busnum, uint8_t devnum)\n{\n\treturn (busnum << 16) | devnum;\n}",
        "output": "0",
        "idx": 4420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n",
        "output": "1",
        "idx": 6004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = strdup(RSTRING_PTR(object_nl));\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 2161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hash_walk_next(struct crypto_hash_walk *walk)\n{\n\tunsigned int alignmask = walk->alignmask;\n\tunsigned int offset = walk->offset;\n\tunsigned int nbytes = min(walk->entrylen,\n\t\t\t\t  ((unsigned int)(PAGE_SIZE)) - offset);\n\n\tif (walk->flags & CRYPTO_ALG_ASYNC)\n\t\twalk->data = kmap(walk->pg);\n\telse\n\t\twalk->data = kmap_atomic(walk->pg);\n\twalk->data += offset;\n\n\tif (offset & alignmask) {\n\t\tunsigned int unaligned = alignmask + 1 - (offset & alignmask);\n\n\t\tif (nbytes > unaligned)\n\t\t\tnbytes = unaligned;\n\t}\n\n\twalk->entrylen -= nbytes;\n\treturn nbytes;\n}",
        "output": "0",
        "idx": 5177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vp8_release_frame(VP8Context *s, VP8Frame *f)\n{\n    av_buffer_unref(&f->seg_map);\n    ff_thread_release_buffer(s->avctx, &f->tf);\n}",
        "output": "0",
        "idx": 4011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;",
        "output": "1",
        "idx": 5640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 38
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)\n{\n    *stage = 0;\n    *cont = 1;\n    return 0;\n}",
        "output": "0",
        "idx": 5393
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}",
        "output": "1",
        "idx": 4507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usbredir_get_bufpq(QEMUFile *f, void *priv, size_t unused,\n                              const VMStateField *field)\n{\n    struct endp_data *endp = priv;\n    USBRedirDevice *dev = endp->dev;\n    struct buf_packet *bufp;\n    int i;\n\n    endp->bufpq_size = qemu_get_be32(f);\n    for (i = 0; i < endp->bufpq_size; i++) {\n        bufp = g_new(struct buf_packet, 1);\n        bufp->len = qemu_get_be32(f);\n        bufp->status = qemu_get_be32(f);\n        bufp->offset = 0;\n        bufp->data = qemu_oom_check(malloc(bufp->len)); /* regular malloc! */\n        bufp->free_on_destroy = bufp->data;\n        qemu_get_buffer(f, bufp->data, bufp->len);\n        QTAILQ_INSERT_TAIL(&endp->bufpq, bufp, next);\n        DPRINTF(\"get_bufpq %d/%d len %d status %d\\n\", i + 1, endp->bufpq_size,\n                bufp->len, bufp->status);\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 5598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n",
        "output": "0",
        "idx": 1331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\n\targs->ast = ast->parent;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\t// At this point we no longer have any need for parse_current or any of its\n\t// siblings; they have all been converted to the appropriate AST node. The\n\t// full parse tree will get deleted elsewhere, but in an attempt to\n\t// minimize memory usage (of which the parse tree uses a lot), start\n\t// deleting the parts we don't need now.\n\tcil_tree_children_destroy(parse_current->parent);\n\n\treturn SEPOL_OK;\n}",
        "output": "1",
        "idx": 1763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                            sizeof(diag_501), 0) ||\n\n        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,\n\n                            sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Hints::getPageObjectNum(int page)\n{\n    if ((page < 1) || (page > nPages)) {\n        return 0;\n    }\n\n    if (page - 1 > pageFirst) {\n        return pageObjectNum[page - 1];\n    } else if (page - 1 < pageFirst) {\n        return pageObjectNum[page];\n    } else {\n        return pageObjectNum[0];\n    }\n}",
        "output": "0",
        "idx": 6209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_read: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n",
        "output": "1",
        "idx": 1724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_io_channel_ipv4(bool async)\n\n{\n\n    SocketAddress *listen_addr = g_new0(SocketAddress, 1);\n\n    SocketAddress *connect_addr = g_new0(SocketAddress, 1);\n\n\n\n    listen_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    listen_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");\n\n    listen_addr->u.inet->port = NULL; /* Auto-select */\n\n\n\n    connect_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    connect_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");\n\n    connect_addr->u.inet->port = NULL; /* Filled in later */\n\n\n\n    test_io_channel(async, listen_addr, connect_addr);\n\n\n\n    qapi_free_SocketAddress(listen_addr);\n\n    qapi_free_SocketAddress(connect_addr);\n\n}\n",
        "output": "0",
        "idx": 4159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {\n    register const xmlChar *cmp = other;\n    register const xmlChar *in;\n    const xmlChar *ret;\n\n    GROW;\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(NULL);\n\n    in = ctxt->input->cur;\n    while (*in != 0 && *in == *cmp) {\n\t++in;\n\t++cmp;\n\tctxt->input->col++;\n    }\n    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {\n\t/* success */\n\tctxt->input->cur = in;\n\treturn (const xmlChar*) 1;\n    }\n    /* failure (or end of input buffer), check with full function */\n    ret = xmlParseName (ctxt);\n    /* strings coming from the dictionary direct compare possible */\n    if (ret == other) {\n\treturn (const xmlChar*) 1;\n    }\n    return ret;\n}",
        "output": "0",
        "idx": 5872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_context_in_disassemble_cmd(expand_T *xp, char_u *arg)\n{\n    char_u\t*p;\n\n    // Default: expand user functions, \"debug\" and \"profile\"\n    xp->xp_context = EXPAND_DISASSEMBLE;\n    xp->xp_pattern = arg;\n\n    // first argument already typed: only user function names\n    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)\n    {\n\txp->xp_context = EXPAND_USER_FUNC;\n\txp->xp_pattern = skipwhite(p);\n    }\n}",
        "output": "0",
        "idx": 1860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}",
        "output": "1",
        "idx": 6148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n",
        "output": "1",
        "idx": 1870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n",
        "output": "1",
        "idx": 4296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n",
        "output": "1",
        "idx": 3964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\t       ep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\t       epi->ffd.file->private_data, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}",
        "output": "1",
        "idx": 2210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 2666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stream_close(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int i;\n\n    /* XXX: use a special url_shutdown call to abort parse cleanly */\n\n    is->abort_request = 1;\n\n    SDL_WaitThread(is->read_tid, NULL);\n\n    SDL_WaitThread(is->refresh_tid, NULL);\n\n    packet_queue_destroy(&is->videoq);\n\n    packet_queue_destroy(&is->audioq);\n\n    packet_queue_destroy(&is->subtitleq);\n\n\n\n    /* free all pictures */\n\n    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {\n\n        vp = &is->pictq[i];\n\n#if CONFIG_AVFILTER\n\n        avfilter_unref_bufferp(&vp->picref);\n\n#endif\n\n        if (vp->bmp) {\n\n            SDL_FreeYUVOverlay(vp->bmp);\n\n            vp->bmp = NULL;\n\n        }\n\n    }\n\n    SDL_DestroyMutex(is->pictq_mutex);\n\n    SDL_DestroyCond(is->pictq_cond);\n\n    SDL_DestroyMutex(is->subpq_mutex);\n\n    SDL_DestroyCond(is->subpq_cond);\n\n    SDL_DestroyCond(is->continue_read_thread);\n\n#if !CONFIG_AVFILTER\n\n    sws_freeContext(is->img_convert_ctx);\n\n#endif\n\n    av_free(is);\n\n}\n",
        "output": "0",
        "idx": 2376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n",
        "output": "0",
        "idx": 2084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op && filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tdnotify_flush(filp, id);\n\tlocks_remove_posix(filp, id);\n\tfput(filp);\n\treturn retval;\n}",
        "output": "0",
        "idx": 1871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n",
        "output": "1",
        "idx": 4686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {\n  return connection_manager_.config_.tracingConfig()->max_path_tag_length_;\n}",
        "output": "0",
        "idx": 3900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= -1;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb= 1<<16;\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n",
        "output": "0",
        "idx": 5857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t csum_and_copy_to_pipe_iter(const void *addr, size_t bytes,\n\t\t\t\t\t struct iov_iter *i, __wsum *sump)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\t__wsum sum = *sump;\n\tsize_t off = 0;\n\tunsigned int i_head;\n\tsize_t r;\n\n\tif (!sanity(i))\n\t\treturn 0;\n\n\tbytes = push_pipe(i, bytes, &i_head, &r);\n\twhile (bytes) {\n\t\tsize_t chunk = min_t(size_t, bytes, PAGE_SIZE - r);\n\t\tchar *p = kmap_local_page(pipe->bufs[i_head & p_mask].page);\n\t\tsum = csum_and_memcpy(p + r, addr + off, chunk, sum, off);\n\t\tkunmap_local(p);\n\t\ti->head = i_head;\n\t\ti->iov_offset = r + chunk;\n\t\tbytes -= chunk;\n\t\toff += chunk;\n\t\tr = 0;\n\t\ti_head++;\n\t}\n\t*sump = sum;\n\ti->count -= off;\n\treturn off;\n}",
        "output": "0",
        "idx": 2057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)\n{\n#ifdef USE_CALLOUT\n  param->callout_user_data = user_data;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}",
        "output": "0",
        "idx": 5232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n",
        "output": "0",
        "idx": 58
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}",
        "output": "1",
        "idx": 6254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned tget(const uint8_t **p, int type, int le)\n\n{\n\n    switch (type) {\n\n    case TIFF_BYTE:\n\n        return *(*p)++;\n\n    case TIFF_SHORT:\n\n        return tget_short(p, le);\n\n    case TIFF_LONG:\n\n        return tget_long(p, le);\n\n    default:\n\n        return UINT_MAX;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 6123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}",
        "output": "1",
        "idx": 31
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 8
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n",
        "output": "0",
        "idx": 316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t allocation_policy_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\tunsigned int ci_attr = this_leaf->attributes;\n\tint n = 0;\n\n\tif ((ci_attr & CACHE_READ_ALLOCATE) && (ci_attr & CACHE_WRITE_ALLOCATE))\n\t\tn = sprintf(buf, \"ReadWriteAllocate\\n\");\n\telse if (ci_attr & CACHE_READ_ALLOCATE)\n\t\tn = sprintf(buf, \"ReadAllocate\\n\");\n\telse if (ci_attr & CACHE_WRITE_ALLOCATE)\n\t\tn = sprintf(buf, \"WriteAllocate\\n\");\n\treturn n;\n}",
        "output": "1",
        "idx": 2933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ASN1_STRING* X509_NAME::GetEntry(int i)\n{\n    if (i < 0 || i >= int(sz_))\n        return 0;\n\n    if (entry_.data)\n        ysArrayDelete(entry_.data);\n    entry_.data = NEW_YS byte[sz_];       // max size;\n\n    memcpy(entry_.data, &name_[i], sz_ - i);\n    if (entry_.data[sz_ -i - 1]) {\n        entry_.data[sz_ - i] = 0;\n        entry_.length = int(sz_) - i;\n    }\n    else\n        entry_.length = int(sz_) - i - 1;\n    entry_.type = 0;\n\n    return &entry_;\n}",
        "output": "1",
        "idx": 5895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_msi_enabled(struct pci_vdev *dev)\n{\n\treturn dev->msi.enabled;\n}",
        "output": "0",
        "idx": 3941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska)\n\n{\n\n    EbmlList *index_list;\n\n    MatroskaIndex *index;\n\n    int index_scale = 1;\n\n    int i, j;\n\n\n\n    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)\n\n        return;\n\n\n\n    index_list = &matroska->index;\n\n    index      = index_list->elem;\n\n    if (index_list->nb_elem &&\n\n        index[0].time > 1E14 / matroska->time_scale) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");\n\n        index_scale = matroska->time_scale;\n\n    }\n\n    for (i = 0; i < index_list->nb_elem; i++) {\n\n        EbmlList *pos_list    = &index[i].pos;\n\n        MatroskaIndexPos *pos = pos_list->elem;\n\n        for (j = 0; j < pos_list->nb_elem; j++) {\n\n            MatroskaTrack *track = matroska_find_track_by_num(matroska,\n\n                                                              pos[j].track);\n\n            if (track && track->stream)\n\n                av_add_index_entry(track->stream,\n\n                                   pos[j].pos + matroska->segment_start,\n\n                                   index[i].time / index_scale, 0, 0,\n\n                                   AVINDEX_KEYFRAME);\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)\n{\n    make_tav(pe, t_integer, imemory_new_mask(imem), intval,\n             ((const gs_param_int_array *)pvalue)->data[i]);\n    return 0;\n}",
        "output": "0",
        "idx": 1510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_display_name_ext(OM_uint32 *minor_status,\n\t\t\t    gss_name_t name,\n\t\t\t    gss_OID display_as_name_type,\n\t\t\t    gss_buffer_t display_name)\n{\n\tOM_uint32 ret;\n\tret = gss_display_name_ext(minor_status,\n\t\t\t\t   name,\n\t\t\t\t   display_as_name_type,\n\t\t\t\t   display_name);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n",
        "output": "0",
        "idx": 486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}",
        "output": "1",
        "idx": 5996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)\n{\n  ciss_url_t url;\n\n  mutt_account_tourl (&mx->account, &url);\n  url.path = path;\n\n  url_ciss_tobuffer (&url, dest, 0);\n}",
        "output": "0",
        "idx": 3859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n#ifdef DEBUG\n      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));\n#endif\n      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {\n        // else remove properly.\n        /* we use jsvIsChild here just in case. delete probably isn't called\n        that often so it pays to be safe */\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}",
        "output": "0",
        "idx": 1876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n\n    if (oldcode == -1) {\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}",
        "output": "1",
        "idx": 832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }",
        "output": "0",
        "idx": 6221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PS_SERIALIZER_ENCODE_FUNC(wddx)\n{\n\twddx_packet *packet;\n\tPS_ENCODE_VARS;\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\n\tPS_ENCODE_LOOP(\n\t\tphp_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);\n\t);\n\t\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\t*newstr = php_wddx_gather(packet);\n\tphp_wddx_destructor(packet);\n\t\n\tif (newlen) {\n\t\t*newlen = strlen(*newstr);\n\t}\n\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 3211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\t/* Special case, because of NET_IP_ALIGN. Given metadata sits\n\t\t * right in front, treat it the very same way.\n\t\t */\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}",
        "output": "1",
        "idx": 919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sig_chatnet_destroyed(IRC_CHATNET_REC *rec)\n{\n\tif (IS_IRC_CHATNET(rec))\n                g_free(rec->usermode);\n}",
        "output": "1",
        "idx": 4462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,\n                      TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteUniqueParams*>(node->builtin_data);\n  if (params == nullptr) {\n    context->ReportError(context, \"Null params passed\");\n    return kTfLiteError;\n  }\n  switch (params->index_out_type) {\n    case kTfLiteInt32:\n      return EvalImpl<T, int32_t>(context, input, node);\n    case kTfLiteInt64:\n      return EvalImpl<T, int64_t>(context, input, node);\n    default:\n      context->ReportError(\n          context,\n          \"Unique index output array can only be Int32 or In64, requested: %s\",\n          TfLiteTypeGetName(params->index_out_type));\n  }\n  return kTfLiteError;\n}",
        "output": "1",
        "idx": 1630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CopySendString(CopyState cstate, const char *str)\n{\n\tappendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));\n}",
        "output": "0",
        "idx": 196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bdrv_is_read_only(BlockDriverState *bs)\n\n{\n\n    return bs->read_only;\n\n}\n",
        "output": "0",
        "idx": 5204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n",
        "output": "1",
        "idx": 1640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Chapters::Display::Clear() {\n  delete[] m_string;\n  m_string = NULL;\n\n  delete[] m_language;\n  m_language = NULL;\n\n  delete[] m_country;\n  m_country = NULL;\n}",
        "output": "0",
        "idx": 4078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}",
        "output": "1",
        "idx": 6011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n",
        "output": "1",
        "idx": 4921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)\n{\n  for (TABLE_LIST *table= tables; table; table= table->next_global)\n  {\n    DBUG_ASSERT(table->db && table->table_name);\n    if (table->updating && !thd->find_tmp_table_share(table))\n      return 1;\n  }\n  return 0;\n}",
        "output": "0",
        "idx": 2811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Equalize histogram of pixel values \\newinstance.\n    CImg<T> get_equalize(const unsigned int nblevels) const {\n      return (+*this).equalize(nblevels);",
        "output": "0",
        "idx": 5902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstU, dstV, src1, width);\n\n}\n",
        "output": "0",
        "idx": 4697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Downstream::inspect_http1_request() {\n  if (req_.method == HTTP_CONNECT) {\n    req_.upgrade_request = true;\n  } else if (req_.http_minor > 0) {\n    auto upgrade = req_.fs.header(http2::HD_UPGRADE);\n    if (upgrade) {\n      const auto &val = upgrade->value;\n      // TODO Perform more strict checking for upgrade headers\n      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),\n                        val.size())) {\n        req_.http2_upgrade_seen = true;\n      } else {\n        req_.upgrade_request = true;\n\n        // TODO Should we check Sec-WebSocket-Key, and\n        // Sec-WebSocket-Version as well?\n        if (util::strieq_l(\"websocket\", val)) {\n          req_.connect_proto = ConnectProto::WEBSOCKET;\n        }\n      }\n    }\n  }\n  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);\n  if (transfer_encoding) {\n    req_.fs.content_length = -1;\n    if (util::iends_with_l(transfer_encoding->value, \"chunked\")) {\n      chunked_request_ = true;\n    }\n  }\n}",
        "output": "1",
        "idx": 1022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\n\tZ_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;\n\tZ_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;\n\n\treturn ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);\n}",
        "output": "0",
        "idx": 5868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (1, bin->ne_header->EntryTableLength);\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}",
        "output": "1",
        "idx": 5246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 1015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tsize_t count)\n{\n\tBUG_ON(direction != ITER_PIPE);\n\ti->type = direction;\n\ti->pipe = pipe;\n\ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}",
        "output": "1",
        "idx": 4163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n\n    code = (njs_vmcode_array_t *) pc;\n\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n\n    if (njs_fast_path(array != NULL)) {\n\n        if (code->ctor) {\n            /* Array of the form [,,,], [1,,]. */\n            value = array->start;\n            length = array->length;\n\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n\n        } else {\n            /* Array of the form [], [,,1], [1,2,3]. */\n            array->length = 0;\n        }\n\n        njs_set_array(&vm->retval, array);\n\n        return sizeof(njs_vmcode_array_t);\n    }\n\n    return NJS_ERROR;\n}",
        "output": "1",
        "idx": 1518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n",
        "output": "1",
        "idx": 4213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}",
        "output": "0",
        "idx": 1408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n",
        "output": "0",
        "idx": 5884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      return &header;\n    }\n  }\n\n  return nullptr;\n}",
        "output": "1",
        "idx": 2125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,\n\n                                              target_ulong eaddr, uint32_t pid)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n    ppcemb_tlb_t *tlb;\n\n    hwaddr raddr;\n\n    target_ulong page, end;\n\n    int i;\n\n\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb.tlbe[i];\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {\n\n            end = tlb->EPN + tlb->size;\n\n            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {\n\n                tlb_flush_page(cs, page);\n\n            }\n\n            tlb->prot &= ~PAGE_VALID;\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    ppc4xx_tlb_invalidate_all(env);\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 6090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)\n{\n    UINT16 written = 0;\n    written += TPM2B_Marshal(&source->b, buffer, size);\n    return written;\n}",
        "output": "1",
        "idx": 1633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)\n{\n\treturn fsetxattr(fsp->fh->fd, name, value, size, flags);\n}",
        "output": "0",
        "idx": 1605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n",
        "output": "1",
        "idx": 845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sja1105_cold_reset(const struct sja1105_private *priv)\n{\n\tstruct sja1105_reset_cmd reset = {0};\n\n\treset.cold_rst = 1;\n\treturn priv->info->reset_cmd(priv, &reset);\n}",
        "output": "0",
        "idx": 2644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  // Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}",
        "output": "1",
        "idx": 78
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int channelmap_query_formats(AVFilterContext *ctx)\n\n{\n\n    ChannelMapContext *s = ctx->priv;\n\n\n\n    ff_set_common_formats(ctx, ff_planar_sample_fmts());\n\n    ff_set_common_samplerates(ctx, ff_all_samplerates());\n\n    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);\n\n    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);\n\n\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 3878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int restore_fp(struct task_struct *tsk)\n{\n\tif (tsk->thread.load_fp || tm_active_with_fp(tsk)) {\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tcurrent->thread.load_fp++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 2761
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tstruct extent_io_tree *tree;\n\tstruct extent_map_tree *map;\n\tint ret;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\tmap = &BTRFS_I(page->mapping->host)->extent_tree;\n\tret = try_release_extent_mapping(map, tree, page, gfp_flags);\n\tif (ret == 1) {\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tpage_cache_release(page);\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* logical unicode object */\n\tPyObject *result = NULL;\t/* output string object */\n\n\t/* Always needed for the string length */\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\t/* Shortcut for utf8 strings (little faster) */\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\t/* Invoke log2vis_unicode and encode back to encoding */\n\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\n\tPy_DECREF (logical);\n\n\treturn result;\n}",
        "output": "1",
        "idx": 3380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}",
        "output": "1",
        "idx": 568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static CImg<T> get_load_bmp(std::FILE *const file) {\n      return CImg<T>().load_bmp(file);\n    }",
        "output": "0",
        "idx": 5144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned int msi_nr_vectors(uint16_t flags)\n\n{\n\n    return 1U <<\n\n        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));\n\n}\n",
        "output": "0",
        "idx": 1991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_dispatch_cmd_failure(void)\n\n{\n\n    QDict *req = qdict_new();\n\n\n    QObject *resp;\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n\n\n    /* check that with extra arguments it throws an error */\n\n    req = qdict_new();\n\n    qdict_put(args, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args);\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n}",
        "output": "1",
        "idx": 1531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n",
        "output": "1",
        "idx": 2725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}",
        "output": "1",
        "idx": 5269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline const char *stros() {\n#if defined(linux) || defined(__linux) || defined(__linux__)\n      static const char *const str = \"Linux\";\n#elif defined(sun) || defined(__sun)\n      static const char *const str = \"Sun OS\";\n#elif defined(BSD) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined (__DragonFly__)\n      static const char *const str = \"BSD\";\n#elif defined(sgi) || defined(__sgi)\n      static const char *const str = \"Irix\";\n#elif defined(__MACOSX__) || defined(__APPLE__)\n      static const char *const str = \"Mac OS\";\n#elif defined(unix) || defined(__unix) || defined(__unix__)\n      static const char *const str = \"Generic Unix\";\n#elif defined(_MSC_VER) || defined(WIN32)  || defined(_WIN32) || defined(__WIN32__) || \\\n  defined(WIN64) || defined(_WIN64) || defined(__WIN64__)\n      static const char *const str = \"Windows\";\n#else\n      const char\n        *const _str1 = std::getenv(\"OSTYPE\"),\n        *const _str2 = _str1?_str1:std::getenv(\"OS\"),\n        *const str = _str2?_str2:\"Unknown OS\";\n#endif\n      return str;\n    }",
        "output": "0",
        "idx": 6070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,\n\t\t\t\t        unsigned int status,\n\t\t\t\t\tconst char *enh_code,\n\t\t\t\t\tconst char *const *text_lines)\n{\n\tstruct smtp_reply reply;\n\n\ti_zero(&reply);\n\treply.status = status;\n\treply.text_lines = text_lines;\n\n\tif (!smtp_reply_parse_enhanced_code(\n\t\tenh_code, &reply.enhanced_code, NULL))\n\t\treply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);\n\n\tT_BEGIN {\n\t\tstring_t *str;\n\n\t\te_debug(conn->event, \"Sent: %s\", smtp_reply_log(&reply));\n\n\t\tstr = t_str_new(256);\n\t\tsmtp_reply_write(str, &reply);\n\t\to_stream_nsend(conn->conn.output, str_data(str), str_len(str));\n\t} T_END;\n}",
        "output": "0",
        "idx": 2008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)\n{\n\tstruct nfsd4_copy *copy = NULL;\n\n\tspin_lock(&clp->async_lock);\n\tif (!list_empty(&clp->async_copies)) {\n\t\tcopy = list_first_entry(&clp->async_copies, struct nfsd4_copy,\n\t\t\t\t\tcopies);\n\t\trefcount_inc(&copy->refcount);\n\t}\n\tspin_unlock(&clp->async_lock);\n\treturn copy;\n}",
        "output": "0",
        "idx": 5249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_rsvg_node_poly_free (RsvgNode * self)\n{\n    RsvgNodePoly *poly = (RsvgNodePoly *) self;\n    if (poly->path)\n        rsvg_cairo_path_destroy (poly->path);\n    _rsvg_node_finalize (&poly->super);\n    g_free (poly);\n}",
        "output": "0",
        "idx": 2121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n",
        "output": "0",
        "idx": 4962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ib_destroy_cm_id(struct ib_cm_id *cm_id)\n{\n\tcm_destroy_id(cm_id, 0);\n}",
        "output": "0",
        "idx": 4635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vinput->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    /* force virtio-1.0 */\n\n    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;\n\n    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n",
        "output": "0",
        "idx": 3609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n",
        "output": "0",
        "idx": 2118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,\n                          EC_POINT *points[], BN_CTX *ctx)\n{\n    size_t i;\n\n    if (group->meth->points_make_affine == 0) {\n        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    for (i = 0; i < num; i++) {\n        if (!ec_point_is_compat(points[i], group)) {\n            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);\n            return 0;\n        }\n    }\n    return group->meth->points_make_affine(group, num, points, ctx);\n}",
        "output": "0",
        "idx": 4649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n                         BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n\n                       cb, opaque, QEMU_AIO_READ);\n\n}\n",
        "output": "0",
        "idx": 4070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_tabs(int *tab_list)\n{\n    int last = 1;\n    int stop;\n\n    putchar('\\r');\n    while ((stop = *tab_list++) > 0) {\n\tif (last < stop) {\n\t    while (last++ < stop) {\n\t\tif (last > max_cols)\n\t\t    break;\n\t\tputchar(' ');\n\t    }\n\t}\n\tif (stop <= max_cols) {\n\t    tputs(tparm(set_tab, stop), 1, putch);\n\t    last = stop;\n\t} else {\n\t    break;\n\t}\n    }\n    putchar('\\r');\n}",
        "output": "1",
        "idx": 4632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n",
        "output": "1",
        "idx": 824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)\n\n{\n\n    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);\n\n    struct omap_uart_s *s = omap_uart_init(base, irq,\n\n                    fclk, iclk, txdma, rxdma, chr);\n\n    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,\n\n                    omap_uart_writefn, s);\n\n\n\n    s->ta = ta;\n\n    s->base = base;\n\n\n\n    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);\n\n\n\n    return s;\n\n}\n",
        "output": "0",
        "idx": 1888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n",
        "output": "0",
        "idx": 6129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void transport_flags_from_domain(AvahiServer *s, AvahiLookupFlags *flags, const char *domain) {\n    assert(flags);\n    assert(domain);\n\n    assert(!((*flags & AVAHI_LOOKUP_USE_MULTICAST) && (*flags & AVAHI_LOOKUP_USE_WIDE_AREA)));\n\n    if (*flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA))\n        return;\n\n    if (!s->wide_area_lookup_engine ||\n        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||\n        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||\n        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||\n        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))\n        *flags |= AVAHI_LOOKUP_USE_MULTICAST;\n    else\n        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;\n}",
        "output": "0",
        "idx": 3405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t __weak cpu_show_l1tf(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"Not affected\\n\");\n}",
        "output": "1",
        "idx": 3284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)\n\n{\n\n    switch(tag) {\n\n    case 0x4801:\n\n        track->track_id = get_be32(pb);\n\n        break;\n\n    case 0x4804:\n\n        get_buffer(pb, track->track_number, 4);\n\n        break;\n\n    case 0x4B01:\n\n        track->edit_rate.den = get_be32(pb);\n\n        track->edit_rate.num = get_be32(pb);\n\n        break;\n\n    case 0x4803:\n\n        get_buffer(pb, track->sequence_ref, 16);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 2543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,\n                                 hwaddr *plen, bool resolve_subpage)\n{\n    MemoryRegionSection *section;\n    Int128 diff;\n\n    section = address_space_lookup_region(d, addr, resolve_subpage);\n    /* Compute offset within MemoryRegionSection */\n    addr -= section->offset_within_address_space;\n\n    /* Compute offset within MemoryRegion */\n    *xlat = addr + section->offset_within_region;\n\n    diff = int128_sub(section->mr->size, int128_make64(addr));\n    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));\n    return section;\n}",
        "output": "1",
        "idx": 4529
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tsk_set_nagle(struct tipc_sock *tsk)\n{\n\tstruct sock *sk = &tsk->sk;\n\n\ttsk->maxnagle = 0;\n\tif (sk->sk_type != SOCK_STREAM)\n\t\treturn;\n\tif (tsk->nodelay)\n\t\treturn;\n\tif (!(tsk->peer_caps & TIPC_NAGLE))\n\t\treturn;\n\t/* Limit node local buffer size to avoid receive queue overflow */\n\tif (tsk->max_pkt == MAX_MSG_SIZE)\n\t\ttsk->maxnagle = 1500;\n\telse\n\t\ttsk->maxnagle = tsk->max_pkt;\n}",
        "output": "0",
        "idx": 1139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fourxm_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 12)\n\n        return 0;\n\n\n\n    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||\n\n        (AV_RL32(&p->buf[8]) != _4XMV_TAG))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n",
        "output": "0",
        "idx": 708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tconst char __user *fname;\n\tint ret;\n\n\tif (unlikely(sqe->ioprio || sqe->buf_index))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\t/* open.how should be already initialised */\n\tif (!(req->open.how.flags & O_PATH) && force_o_largefile())\n\t\treq->open.how.flags |= O_LARGEFILE;\n\n\treq->open.dfd = READ_ONCE(sqe->fd);\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\treq->open.filename = getname(fname);\n\tif (IS_ERR(req->open.filename)) {\n\t\tret = PTR_ERR(req->open.filename);\n\t\treq->open.filename = NULL;\n\t\treturn ret;\n\t}\n\treq->open.nofile = rlimit(RLIMIT_NOFILE);\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}",
        "output": "0",
        "idx": 146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_calloc(mrb_state *mrb, size_t nelem, size_t len)\n{\n  void *p;\n\n  if (nelem > 0 && len > 0 &&\n      nelem <= SIZE_MAX / len) {\n    size_t size;\n    size = nelem * len;\n    p = mrb_realloc(mrb, 0, size);\n\n    if (p) {\n      memset(p, 0, size);\n    }\n  }\n  else {\n    p = NULL;\n  }\n\n  return p;\n}",
        "output": "0",
        "idx": 4209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n{\n    IVI45DecContext *ctx = avctx->priv_data;\n    ivi_free_buffers(&ctx->planes[0]);\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n    av_frame_free(&ctx->p_frame);\n    return 0;\n}",
        "output": "1",
        "idx": 2974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iscsi_unmap_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to unmap data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n",
        "output": "0",
        "idx": 5873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stellaris_enet_can_receive(void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return 1;\n\n\n\n    return (s->np < 31);\n\n}\n",
        "output": "0",
        "idx": 3203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n",
        "output": "1",
        "idx": 1198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void exif_iif_add_tag(image_info_type *image_info, int section_index, char *name, int tag, int format, size_t length, void* value)\n{\n\texif_iif_add_value(image_info, section_index, name, tag, format, (int)length, value, image_info->motorola_intel);\n}",
        "output": "1",
        "idx": 1758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getRealPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buff[MAXPATHLEN];\n\tchar *filename;\n\tzend_error_handling error_handling;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t}\n\t\n\tif (intern->orig_path) {\n\t\tfilename = intern->orig_path;\n\t} else { \n\t\tfilename = intern->file_name;\n\t}\n\n\n\tif (filename && VCWD_REALPATH(filename, buff)) {\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(buff, F_OK)) {\n\t\t\tRETVAL_FALSE;\n\t\t} else\n#endif\n\t\tRETVAL_STRING(buff, 1);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 4735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\n\tif (!fpl)\n\t\treturn NULL;\n\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t}\n\treturn new_fpl;\n}",
        "output": "1",
        "idx": 2528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_background_color(NCURSES_SP_DCLx int bg, NCURSES_SP_OUTC outc)\n{\n#ifdef USE_TERM_DRIVER\n    CallDriver_3(SP_PARM, td_color, FALSE, bg, outc);\n#else\n    if (set_a_background) {\n\tTPUTS_TRACE(\"set_a_background\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_a_background, bg),\n\t\t\t\t1, outc);\n    } else {\n\tTPUTS_TRACE(\"set_background\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_background, toggled_colors(bg)),\n\t\t\t\t1, outc);\n    }\n#endif\n}",
        "output": "1",
        "idx": 1396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                  const uint8_t *src, int srcW, int xInc)\n\n{\n\n    int i;\n\n    unsigned int xpos=0;\n\n    for (i=0;i<dstWidth;i++) {\n\n        register unsigned int xx=xpos>>16;\n\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n        xpos+=xInc;\n\n    }\n\n\n\n}",
        "output": "1",
        "idx": 1777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n",
        "output": "0",
        "idx": 3701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "single_encode(float8 x, char *str)\n{\n\tint\t\t\tndig = DBL_DIG + extra_float_digits;\n\n\tif (ndig < 1)\n\t\tndig = 1;\n\n\tsprintf(str, \"%.*g\", ndig, x);\n\treturn TRUE;\n}\t/* single_encode() */",
        "output": "0",
        "idx": 97
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_prepare_syntax()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  char query[MAX_TEST_QUERY_LENGTH];\n\n  myheader(\"test_prepare_syntax\");\n\n  rc= mysql_query(mysql, \"DROP TABLE IF EXISTS test_prepare_syntax\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"CREATE TABLE test_prepare_syntax(\"\n                         \"id int, name varchar(50), extra int)\");\n  myquery(rc);\n\n  strmov(query, \"INSERT INTO test_prepare_syntax VALUES(?\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt_r(stmt);\n\n  strmov(query, \"SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt_r(stmt);\n\n  /* now fetch the results ..*/\n  rc= mysql_commit(mysql);\n  myquery(rc);\n}",
        "output": "0",
        "idx": 2227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)\n{\n  if (!input.empty()) {\n    char *endptr;\n    *output = strtol(input.c_str(), &endptr, 10);\n    if (endptr) {\n      if (endptr == input.c_str()) return -EINVAL;\n      while (*endptr && isspace(*endptr)) // ignore white space\n        endptr++;\n      if (*endptr) {\n        return -EINVAL;\n      }\n    }\n    if(*output > upper_bound) {\n      *output = upper_bound;\n    }\n    if(*output < lower_bound) {\n      *output = lower_bound;\n    }\n  } else {\n    *output = default_val;\n  }\n\n  return 0;\n}",
        "output": "1",
        "idx": 4920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(size_t) (*p++ << 24);\n  *quantum|=(size_t) (*p++ << 16);\n  *quantum|=(size_t) (*p++ << 8);\n  *quantum|=(size_t) (*p++ << 0);\n  return(p);\n}",
        "output": "1",
        "idx": 5425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {\n    // Accumulate the byte measurement from previous upstream request during a retry.\n    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());\n    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());\n    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());\n    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());\n    upstream_bytes_meter_ = upstream_bytes_meter;\n  }",
        "output": "0",
        "idx": 4150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_s390_notify(void *opaque, uint16_t vector)\n\n{\n\n    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;\n\n    uint64_t token = s390_virtio_device_vq_token(dev, vector);\n\n\n\n    /* XXX kvm dependency! */\n\n    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);\n\n}\n",
        "output": "0",
        "idx": 4487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init init_default_flow_dissectors(void)\n{\n\tskb_flow_dissector_init(&flow_keys_dissector,\n\t\t\t\tflow_keys_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_keys));\n\tskb_flow_dissector_init(&flow_keys_dissector_symmetric,\n\t\t\t\tflow_keys_dissector_symmetric_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_symmetric_keys));\n\tskb_flow_dissector_init(&flow_keys_basic_dissector,\n\t\t\t\tflow_keys_basic_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_basic_dissector_keys));\n\treturn 0;\n}",
        "output": "0",
        "idx": 2346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "print_arrays_for(char *set)\n{\n  FILE *f;\n\n  sprintf(buf, \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"\\\n/* The %s character set.  Generated automatically by configure and\\n\\\n * the %s program\\n\\\n */\\n\\n\",\n\t set, prog);\n\n  /* it would be nice if this used the code in mysys/charset.c, but... */\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n\n  fclose(f);\n\n  return;\n}",
        "output": "1",
        "idx": 4574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\n\t*cp = '\\0';\n\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\n\treturn (tp->e_name);\n}",
        "output": "1",
        "idx": 4026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)\n{\n\treturn !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);\n}",
        "output": "0",
        "idx": 1869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static abi_long do_socket(int domain, int type, int protocol)\n\n{\n\n    int target_type = type;\n\n    int ret;\n\n\n\n    ret = target_to_host_sock_type(&type);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (domain == PF_NETLINK)\n\n        return -TARGET_EAFNOSUPPORT;\n\n\n\n    if (domain == AF_PACKET ||\n\n        (domain == AF_INET && type == SOCK_PACKET)) {\n\n        protocol = tswap16(protocol);\n\n    }\n\n\n\n    ret = get_errno(socket(domain, type, protocol));\n\n    if (ret >= 0) {\n\n        ret = sock_flags_fixup(ret, target_type);\n\n        if (type == SOCK_PACKET) {\n\n            /* Manage an obsolete case :\n\n             * if socket type is SOCK_PACKET, bind by name\n\n             */\n\n            fd_trans_register(ret, &target_packet_trans);\n\n        }\n\n    }\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 1791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */",
        "output": "1",
        "idx": 412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n",
        "output": "0",
        "idx": 1721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, setFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &intern->flags) == FAILURE) {\n\t\treturn;\n\t}\n} /* }}} */",
        "output": "0",
        "idx": 2863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n\n    return true;\n}",
        "output": "1",
        "idx": 5886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} /* }}} */",
        "output": "1",
        "idx": 1287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gs_grab_get_keyboard (GSGrab    *grab,\n                      GdkWindow *window,\n                      GdkScreen *screen)\n{\n        GdkGrabStatus status;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        gs_debug (\"Grabbing keyboard widget=%X\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->keyboard_grab_window = window;\n                grab->priv->keyboard_grab_screen = screen;\n        } else {\n                gs_debug (\"Couldn't grab keyboard!  (%s)\", grab_string (status));\n        }\n\n        return status;\n}",
        "output": "1",
        "idx": 505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lou_setDataPath (char *path)\n{\n  dataPathPtr = NULL;\n  if (path == NULL)\n    return NULL;\n  strcpy (dataPath, path);\n  dataPathPtr = dataPath;\n  return dataPathPtr;\n}",
        "output": "0",
        "idx": 1704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 3337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n",
        "output": "1",
        "idx": 6198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n",
        "output": "0",
        "idx": 2215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void line6_toneport_disconnect(struct usb_line6 *line6)\n{\n\tstruct usb_line6_toneport *toneport =\n\t\t(struct usb_line6_toneport *)line6;\n\n\tcancel_delayed_work_sync(&toneport->pcm_work);\n\n\tif (toneport_has_led(toneport))\n\t\ttoneport_remove_leds(toneport);\n}",
        "output": "1",
        "idx": 5913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n",
        "output": "0",
        "idx": 1555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ms_fast_dispatch(Message *m) override {\n    Session *s = static_cast<Session*>(m->get_connection()->get_priv());\n    if (!s) {\n      s = new Session(m->get_connection());\n      m->get_connection()->set_priv(s->get());\n    }\n    s->put();\n    s->count++;\n    lderr(g_ceph_context) << __func__ << \" conn: \" << m->get_connection() << \" session \" << s << \" count: \" << s->count << dendl;\n    if (is_server) {\n      if (loopback)\n        assert(m->get_source().is_osd());\n      else\n        reply_message(m);\n    } else if (loopback) {\n      assert(m->get_source().is_client());\n    }\n    m->put();\n    Mutex::Locker l(lock);\n    got_new = true;\n    cond.Signal();\n  }",
        "output": "0",
        "idx": 4798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_open_brace(AVBPrint *dst, const char **inp, int *an, int *closing_brace_missing)\n{\n    int len = 0;\n    const char *in = *inp;\n\n    *an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n\n    if (!*closing_brace_missing) {\n        if (   (*an != 1 && in[1] == '\\\\')\n            || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {\n            char *bracep = strchr(in+2, '}');\n            if (bracep) {\n                *inp = bracep;\n                return;\n            } else\n                *closing_brace_missing = 1;\n        }\n    }\n\n    av_bprint_chars(dst, *in, 1);\n}",
        "output": "1",
        "idx": 922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n",
        "output": "1",
        "idx": 4001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "calc_crc32( u32  crc,  u8  *p,  u32  len )\n{\n\twhile( len-- )\n\t\tcrc = CRC32( *p++, crc );\n\n\treturn  crc;\n}",
        "output": "0",
        "idx": 3263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " */\nunsigned int skb_gso_transport_seglen(const struct sk_buff *skb)\n{\n\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);\n\tunsigned int thlen = 0;\n\n\tif (skb->encapsulation) {\n\t\tthlen = skb_inner_transport_header(skb) -\n\t\t\tskb_transport_header(skb);\n\n\t\tif (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))\n\t\t\tthlen += inner_tcp_hdrlen(skb);\n\t} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {\n\t\tthlen = tcp_hdrlen(skb);\n\t} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {\n\t\tthlen = sizeof(struct sctphdr);\n\t}\n\t/* UFO sets gso_size to the size of the fragmentation\n\t * payload, i.e. the size of the L4 (UDP) header is already\n\t * accounted for.\n\t */\n\treturn thlen + shinfo->gso_size;",
        "output": "0",
        "idx": 5219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_send_server_certificate(SSL *s)\n{\n    unsigned long l;\n    X509 *x;\n\n    if (s->state == SSL3_ST_SW_CERT_A) {\n        x = ssl_get_server_send_cert(s);\n        if (x == NULL) {\n            /* VRS: allow null cert if auth == KRB5 */\n            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||\n                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {\n                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,\n                       ERR_R_INTERNAL_ERROR);\n                return (0);\n            }\n        }\n\n        l = ssl3_output_cert_chain(s, x);\n        if (!l) {\n            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n            return (0);\n        }\n        s->state = SSL3_ST_SW_CERT_B;\n        s->init_num = (int)l;\n        s->init_off = 0;\n    }\n\n    /* SSL3_ST_SW_CERT_B */\n    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));\n}",
        "output": "0",
        "idx": 3487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t/* Get the driver statistics */\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t/* Zero out the driver statistics */\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknow cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\n\t}\t\t\t// switch\n\n\treturn status;\n}\t\t\t\t// skfp_ioctl",
        "output": "1",
        "idx": 30
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=qcow2\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}\n",
        "output": "0",
        "idx": 4114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int voc_probe(AVProbeData *p)\n\n{\n\n    int version, check;\n\n\n\n    if (p->buf_size < 26)\n\n        return 0;\n\n    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))\n\n        return 0;\n\n    version = p->buf[22] | (p->buf[23] << 8);\n\n    check = p->buf[24] | (p->buf[25] << 8);\n\n    if (~version + 0x1234 != check)\n\n        return 10;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n",
        "output": "0",
        "idx": 6152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n",
        "output": "0",
        "idx": 5108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n\n{\n\n    int ret;\n\n\n\n    s->ext_audio_mask = 0;\n\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n\n        return ret;\n\n    s->gb_in = s->gb;\n\n\n\n    if ((ret = parse_frame_header(s)) < 0)\n\n        return ret;\n\n    if ((ret = alloc_sample_buffer(s)) < 0)\n\n        return ret;\n\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n\n        return ret;\n\n    if ((ret = parse_optional_info(s)) < 0)\n\n        return ret;\n\n\n\n    // Workaround for DTS in WAV\n\n    if (s->frame_size > size && s->frame_size < size + 4)\n\n        s->frame_size = size;\n\n\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 2419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TiledInputFile::numYTiles (int ly) const\n{\n    if (ly < 0 || ly >= _data->numYLevels)\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Error calling numYTiles() on image \"\n\t\t\t    \"file \\\"\" << _data->_streamData->is->fileName() << \"\\\" \"\n\t\t\t    \"(Argument is not in valid range).\");\n    }\n    \n    return _data->numYTiles[ly];\n}",
        "output": "0",
        "idx": 696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    int i;\n\n\n\n    fprintf(stderr, \"fis:\");\n\n    for (i = 0; i < cmd_len; i++) {\n\n        if ((i & 0xf) == 0) {\n\n            fprintf(stderr, \"\\n%02x:\",i);\n\n        }\n\n        fprintf(stderr, \"%02x \",fis[i]);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n}\n",
        "output": "1",
        "idx": 4784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)\n\n{\n\n    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);\n\n    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);\n\n}\n",
        "output": "0",
        "idx": 5463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}",
        "output": "1",
        "idx": 3835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,\n                         const TfLiteTensor* rhs) {\n  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);\n  if (rhs->type == kTfLiteInt8) {\n    // Get the quantization params from the RHS tensor.\n    transposed_rhs->params.scale = rhs->params.scale;\n    transposed_rhs->params.zero_point = rhs->params.zero_point;\n  }\n  return transposed_rhs;\n}",
        "output": "1",
        "idx": 5338
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hostkey_method_ssh_rsa_init(LIBSSH2_SESSION * session,\n                            const unsigned char *hostkey_data,\n                            size_t hostkey_data_len,\n                            void **abstract)\n{\n    libssh2_rsa_ctx *rsactx;\n    const unsigned char *s, *e, *n;\n    unsigned long len, e_len, n_len;\n    int ret;\n\n    (void) hostkey_data_len;\n\n    if(*abstract) {\n        hostkey_method_ssh_rsa_dtor(session, abstract);\n        *abstract = NULL;\n    }\n\n    s = hostkey_data;\n    len = _libssh2_ntohu32(s);\n    s += 4;\n\n    if(len != 7 || strncmp((char *) s, \"ssh-rsa\", 7) != 0) {\n        return -1;\n    }\n    s += 7;\n\n    e_len = _libssh2_ntohu32(s);\n    s += 4;\n\n    e = s;\n    s += e_len;\n    n_len = _libssh2_ntohu32(s);\n    s += 4;\n    n = s;\n\n    ret = _libssh2_rsa_new(&rsactx, e, e_len, n, n_len, NULL, 0,\n                           NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0);\n    if(ret) {\n        return -1;\n    }\n\n    *abstract = rsactx;\n\n    return 0;\n}",
        "output": "1",
        "idx": 4875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n",
        "output": "1",
        "idx": 4979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {\n  ASSERT(outbound_frames_ >= 1);\n  --outbound_frames_;\n  delete fragment;\n}",
        "output": "1",
        "idx": 3912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void coroutine_fn block_job_pause_point(BlockJob *job)\n\n{\n\n    assert(job && block_job_started(job));\n\n\n\n    if (!block_job_should_pause(job)) {\n\n        return;\n\n    }\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    if (job->driver->pause) {\n\n        job->driver->pause(job);\n\n    }\n\n\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n\n        job->paused = true;\n\n        job->busy = false;\n\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n\n        job->busy = true;\n\n        job->paused = false;\n\n    }\n\n\n\n    if (job->driver->resume) {\n\n        job->driver->resume(job);\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_bucket_policy(RGWRados *store,\n                              struct req_state *s,\n                              RGWBucketInfo& bucket_info,\n                              map<string, bufferlist>& bucket_attrs,\n                              RGWAccessControlPolicy *policy,\n                              rgw_bucket& bucket)\n{\n  if (!s->system_request && bucket_info.flags & BUCKET_SUSPENDED) {\n    ldout(s->cct, 0) << \"NOTICE: bucket \" << bucket_info.bucket.name << \" is suspended\" << dendl;\n    return -ERR_USER_SUSPENDED;\n  }\n\n  if (bucket.name.empty()) {\n    return 0;\n  }\n\n  int ret = get_bucket_policy_from_attr(s->cct, store, bucket_info, bucket_attrs, policy);\n  if (ret == -ENOENT) {\n      ret = -ERR_NO_SUCH_BUCKET;\n  }\n\n  return ret;\n}",
        "output": "0",
        "idx": 1328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n\n    return schema.detach();\n  }",
        "output": "1",
        "idx": 4175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dealloc(xmlSchemaPtr schema)\n{\n  NOKOGIRI_DEBUG_START(schema);\n  xmlSchemaFree(schema);\n  NOKOGIRI_DEBUG_END(schema);\n}",
        "output": "0",
        "idx": 5763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svg_progress(void *cbk, u64 done, u64 total)\n{\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;\n\n\t/*notify MediaEvent*/\n\tif (parser->load && parser->load->is) {\n\t\tparser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);\n\t\tif (done == total) {\n\t\t\tparser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);\n\t\t}\n\t}\n\tgf_set_progress(\"SVG (Dynamic Attribute List) Parsing\", done, total);\n}",
        "output": "0",
        "idx": 5715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_num(ByteIOContext *pb, int *len)\n\n{\n\n    int n, n1;\n\n\n\n    n = get_be16(pb);\n\n    (*len)-=2;\n\n//    n &= 0x7FFF;\n\n    if (n >= 0x4000) {\n\n        return n - 0x4000;\n\n    } else {\n\n        n1 = get_be16(pb);\n\n        (*len)-=2;\n\n        return (n << 16) | n1;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_clip_path (void)\n{\n    RsvgClipPath *clip_path;\n\n    clip_path = g_new (RsvgClipPath, 1);\n    _rsvg_node_init (&clip_path->super);\n    clip_path->units = userSpaceOnUse;\n    clip_path->super.set_atts = rsvg_clip_path_set_atts;\n    clip_path->super.free = _rsvg_node_free;\n    return &clip_path->super;\n}",
        "output": "1",
        "idx": 5718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n",
        "output": "1",
        "idx": 21
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int queue_get(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *head = &pn->pn_queue;\n\tstruct queue *q = head->q_next;\n\n\tif (q == head)\n\t\treturn 0;\n\n\tassert(q->q_len <= len);\n\tmemcpy(buf, q->q_buf, q->q_len);\n\n\tqueue_del(q);\n\tqueue_add(&pn->pn_queue_free, q);\n\n\treturn q->q_len;\n}",
        "output": "0",
        "idx": 5688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mce_disable_bank(int bank)\n{\n\tif (bank >= mca_cfg.banks) {\n\t\tpr_warn(FW_BUG\n\t\t\t\"Ignoring request to disable invalid MCA bank %d.\\n\",\n\t\t\tbank);\n\t\treturn;\n\t}\n\tset_bit(bank, mce_banks_ce_disabled);\n\ton_each_cpu(__mce_disable_bank, &bank, 1);\n}",
        "output": "0",
        "idx": 1418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hasstop (GPtrArray * lookin)\n{\n    unsigned int i;\n    for (i = 0; i < lookin->len; i++) {\n        if (!strcmp (((RsvgNode *) g_ptr_array_index (lookin, i))->type->str, \"stop\"))\n            return 1;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 2481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}",
        "output": "1",
        "idx": 5622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool numa_is_active_node(int nid, struct numa_group *ng)\n{\n\treturn group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;\n}",
        "output": "0",
        "idx": 2003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct link_encoder *dcn10_link_encoder_create(\n\tconst struct encoder_init_data *enc_init_data)\n{\n\tstruct dcn10_link_encoder *enc10 =\n\t\tkzalloc(sizeof(struct dcn10_link_encoder), GFP_KERNEL);\n\n\tif (!enc10)\n\t\treturn NULL;\n\n\tdcn10_link_encoder_construct(enc10,\n\t\t\t\t      enc_init_data,\n\t\t\t\t      &link_enc_feature,\n\t\t\t\t      &link_enc_regs[enc_init_data->transmitter],\n\t\t\t\t      &link_enc_aux_regs[enc_init_data->channel - 1],\n\t\t\t\t      &link_enc_hpd_regs[enc_init_data->hpd_source],\n\t\t\t\t      &le_shift,\n\t\t\t\t      &le_mask);\n\n\treturn &enc10->base;\n}",
        "output": "0",
        "idx": 4053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 2877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void zlib_stateful_finish(COMP_CTX *ctx)\n\t{\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\n\t}",
        "output": "1",
        "idx": 4264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string to_string(const MaskedIP& m) {\n  stringstream ss;\n  ss << m;\n  return ss.str();\n}",
        "output": "0",
        "idx": 3526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hexprint(FILE *out, const unsigned char *buf, int buflen)\n\t{\n\tint i;\n\tfprintf(out, \"\\t\");\n\tfor (i = 0; i < buflen; i++)\n\t\tfprintf(out, \"%02X\", buf[i]);\n\tfprintf(out, \"\\n\");\n\t}",
        "output": "1",
        "idx": 37
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)\n{\n  if (!thread_check()) {\n\tnpw_printf(\"WARNING: NPN_GetURLNotify not called from the main thread\\n\");\n\treturn NPERR_INVALID_INSTANCE_ERROR;\n  }\n\t\n  if (instance == NULL)\n\treturn NPERR_INVALID_INSTANCE_ERROR;\n\n  PluginInstance *plugin = PLUGIN_INSTANCE(instance);\n  if (plugin == NULL)\n\treturn NPERR_INVALID_INSTANCE_ERROR;\n\n  D(bugiI(\"NPN_GetURLNotify instance=%p\\n\", instance));\n  npw_plugin_instance_ref(plugin);\n  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);\n  npw_plugin_instance_unref(plugin);\n  D(bugiD(\"NPN_GetURLNotify return: %d [%s]\\n\", ret, string_of_NPError(ret)));\n  return ret;\n}",
        "output": "0",
        "idx": 5160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    return OK;\n}",
        "output": "1",
        "idx": 4652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n",
        "output": "0",
        "idx": 1470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, prev)\n{\n\tspl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);\n}",
        "output": "1",
        "idx": 1359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\n\tmsg->msg_namelen = 0;\n\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\n\tkfree_skb(skb);\nend:\n\treturn err;\n}",
        "output": "1",
        "idx": 73
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "absl::optional<std::string> canonicalizePath(absl::string_view original_path) {\n  std::string canonical_path;\n  url::Component in_component(0, original_path.size());\n  url::Component out_component;\n  url::StdStringCanonOutput output(&canonical_path);\n  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {\n    return absl::nullopt;\n  } else {\n    output.Complete();\n    return absl::make_optional(std::move(canonical_path));\n  }\n}",
        "output": "1",
        "idx": 1119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_xvmc_field_end(MpegEncContext *s)\n\n{\n\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n\n    assert(render);\n\n\n\n    if (render->filled_mv_blocks_num > 0)\n\n        ff_mpeg_draw_horiz_band(s, 0, 0);\n\n}\n",
        "output": "1",
        "idx": 6216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int test_x509_time_print(int idx)\n{\n    BIO *m;\n    int ret = 0, rv;\n    char *pp;\n    const char *readable;\n\n    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))\n        goto err;\n\n    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);\n    readable = x509_print_tests[idx].readable;\n\n    if (rv == 0 && !TEST_str_eq(readable, \"Bad time value\")) {\n        /* only if the test case intends to fail... */\n        goto err;\n    }\n    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)\n        || !TEST_int_eq(rv, (int)strlen(readable))\n        || !TEST_strn_eq(pp, readable, rv))\n        goto err;\n\n    ret = 1;\n err:\n    BIO_free(m);\n    return ret;\n}",
        "output": "0",
        "idx": 2249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n",
        "output": "1",
        "idx": 5700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void help(void)\n\n{\n\n    printf(\"dct-test [-i] [<test-number>]\\n\"\n\n           \"test-number 0 -> test with random matrixes\\n\"\n\n           \"            1 -> test with random sparse matrixes\\n\"\n\n           \"            2 -> do 3. test from mpeg4 std\\n\"\n\n           \"-i          test IDCT implementations\\n\"\n\n           \"-4          test IDCT248 implementations\\n\");\n\n    exit(1);\n\n}\n",
        "output": "1",
        "idx": 3920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 4428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wkbReadInt(wkbObj *w)\n{\n  int i;\n  memcpy(&i, w->ptr, sizeof(int));\n  w->ptr += sizeof(int);\n  return i;\n}",
        "output": "0",
        "idx": 2722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n",
        "output": "1",
        "idx": 3821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 6104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t clusterip_proc_write(struct file *file, const char __user *input,\n\t\t\t\tsize_t size, loff_t *ofs)\n{\n\tstruct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;\n#define PROC_WRITELEN\t10\n\tchar buffer[PROC_WRITELEN+1];\n\tunsigned long nodenum;\n\n\tif (copy_from_user(buffer, input, PROC_WRITELEN))\n\t\treturn -EFAULT;\n\n\tif (*buffer == '+') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL, 10);\n\t\tif (clusterip_add_node(c, nodenum))\n\t\t\treturn -ENOMEM;\n\t} else if (*buffer == '-') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL,10);\n\t\tif (clusterip_del_node(c, nodenum))\n\t\t\treturn -ENOENT;\n\t} else\n\t\treturn -EIO;\n\n\treturn size;\n}",
        "output": "1",
        "idx": 459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sasl_disconnected(IRC_SERVER_REC *server)\n{\n\tg_return_if_fail(server != NULL);\n\n\tif (!IS_IRC_SERVER(server)) {\n\t\treturn;\n\t}\n\n\tsasl_timeout_stop(server);\n}",
        "output": "0",
        "idx": 3706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n\n    return nDecryptResult == 0;\n}",
        "output": "1",
        "idx": 1557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n\n\n    if (!virtqueue_pop(s->vq, &req->elem)) {\n\n        virtio_blk_free_request(req);\n\n        return NULL;\n\n    }\n\n\n\n    return req;\n\n}\n",
        "output": "0",
        "idx": 345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CAMLprim value caml_string_get(value str, value index)\n{\n  intnat idx = Long_val(index);\n  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();\n  return Val_int(Byte_u(str, idx));\n}",
        "output": "0",
        "idx": 2431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "link_to_name (char const *link_name, char const *link_target)\n{\n  int res = link (link_target, link_name);\n  if (res < 0 && create_dir_flag)\n    {\n      create_all_directories (link_name);\n      res = link (link_target, link_name);\n    }\n  if (res == 0)\n    {\n      if (verbose_flag)\n\terror (0, 0, _(\"%s linked to %s\"),\n\t       link_target, link_name);\n    }\n  else if (link_flag)\n    {\n      error (0, errno, _(\"cannot link %s to %s\"),\n\t     link_target, link_name);\n    }\n  return res;\n}",
        "output": "0",
        "idx": 1951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool netlink_net_capable(const struct sk_buff *skb, int cap)\n{\n\treturn netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);\n}",
        "output": "0",
        "idx": 4124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n",
        "output": "1",
        "idx": 2349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void destroy_compound_hugetlb_page_for_demote(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\t__destroy_compound_gigantic_page(page, order, true);\n}",
        "output": "0",
        "idx": 1
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_hello_subtlv(const unsigned char *a, int alen,\n                   unsigned int *hello_send_us)\n{\n    int type, len, i = 0, ret = 0;\n\n    while(i < alen) {\n        type = a[0];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \"Received truncated sub-TLV on Hello message.\");\n            return -1;\n        }\n        len = a[i + 1];\n        if(i + len > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \"Received truncated sub-TLV on Hello message.\");\n            return -1;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing to do. */\n        } else if(type == SUBTLV_TIMESTAMP) {\n            if(len >= 4) {\n                DO_NTOHL(*hello_send_us, a + i + 2);\n                ret = 1;\n            } else {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \"Received incorrect RTT sub-TLV on Hello message.\");\n            }\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \"Received unknown Hello sub-TLV type %d.\", type);\n        }\n\n        i += len + 2;\n    }\n    return ret;\n}",
        "output": "1",
        "idx": 485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(FormatTest, Print) {\n#if FMT_USE_FILE_DESCRIPTORS\n  EXPECT_WRITE(stdout, fmt::print(\"Don't {}!\", \"panic\"), \"Don't panic!\");\n  EXPECT_WRITE(stderr,\n      fmt::print(stderr, \"Don't {}!\", \"panic\"), \"Don't panic!\");\n#endif\n}",
        "output": "0",
        "idx": 5927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_end_element (void *data, const xmlChar * name)\n{\n    RsvgHandle *ctx = (RsvgHandle *) data;\n\n    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {\n        if (ctx->priv->handler->end_element != NULL)\n            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);\n        ctx->priv->handler_nest--;\n    } else {\n        const char *tempname;\n        for (tempname = (const char *) name; *tempname != '\\0'; tempname++)\n            if (*tempname == ':')\n                name = (const xmlChar *) (tempname + 1);\n\n        if (ctx->priv->handler != NULL) {\n            ctx->priv->handler->free (ctx->priv->handler);\n            ctx->priv->handler = NULL;\n        }\n\n        if (ctx->priv->currentnode\n            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))\n            rsvg_pop_def_group (ctx);\n\n        if (ctx->priv->treebase && !strcmp ((const char *)name, \"svg\"))\n            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);\n    }\n}",
        "output": "1",
        "idx": 5771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n\n    unsigned fd = 0;\n    while (fd <= 99999) /* paranoia check */\n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            /* in case the line is not terminated, terminate it */\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    fclose(fp);\n    return true;\n}",
        "output": "1",
        "idx": 5784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n",
        "output": "1",
        "idx": 1451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_start_pvclock_update(struct kvm *kvm)\n{\n\tkvm_make_mclock_inprogress_request(kvm);\n\n\t/* no guest entries from this point */\n\t__kvm_start_pvclock_update(kvm);\n}",
        "output": "0",
        "idx": 6268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}",
        "output": "0",
        "idx": 1435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}",
        "output": "1",
        "idx": 1228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n",
        "output": "1",
        "idx": 881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}",
        "output": "1",
        "idx": 1983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n",
        "output": "0",
        "idx": 2147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n",
        "output": "1",
        "idx": 1193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,\n                                             EC_POINT *point, const BIGNUM *x,\n                                             const BIGNUM *y, const BIGNUM *z,\n                                             BN_CTX *ctx)\n{\n    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {\n        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,\n              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (!ec_point_is_compat(point, group)) {\n        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,\n              EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,\n                                                              y, z, ctx);\n}",
        "output": "0",
        "idx": 2208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void create_default_qtables(uint8_t *qtables, uint8_t q)\n\n{\n\n    int factor = q;\n\n    int i;\n\n\n\n    factor = av_clip(q, 1, 99);\n\n\n\n    if (q < 50)\n\n        q = 5000 / factor;\n\n    else\n\n        q = 200 - factor * 2;\n\n\n\n    for (i = 0; i < 128; i++) {\n\n        int val = (default_quantizers[i] * q + 50) / 100;\n\n\n\n        /* Limit the quantizers to 1 <= q <= 255. */\n\n        val = av_clip(val, 1, 255);\n\n        qtables[i] = val;\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1925
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}",
        "output": "1",
        "idx": 1524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n\n                                          bool tso_enable)\n\n{\n\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n\n    uint16_t l3_proto;\n\n\n\n    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n\n\n\n    if (!tso_enable) {\n\n        goto func_exit;\n\n    }\n\n\n\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n\n                          pkt->l4proto);\n\n\n\nfunc_exit:\n\n    return rc;\n\n}\n",
        "output": "0",
        "idx": 2095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n\n                      unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    const unsigned char *ps_end;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    ps_end = src + src_len;\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (ps_end - ps < 1)\n\n            return 0;\n\n        *pd++ = *ps++;\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (ps_end - ps < 1)\n\n            break;\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end || ps_end - ps < l)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end || ps_end - ps < 2)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return ps - src;\n\n}\n",
        "output": "1",
        "idx": 3707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}",
        "output": "1",
        "idx": 5474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    return MK_PLUGIN_RET_NOT_ME;\n}",
        "output": "1",
        "idx": 5580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)\n{\n\tgpointer res;\n\n\tmono_loader_lock ();\n\tres = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tmono_loader_unlock ();\n\n\treturn res;\n}",
        "output": "0",
        "idx": 1612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 6247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_bink_idct_c(DCTELEM *block)\n\n{\n\n    int i;\n\n    DCTELEM temp[64];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        bink_idct_col(&temp[i], &block[i]);\n\n    for (i = 0; i < 8; i++) {\n\n        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *ff_avio_child_next(void *obj, void *prev)\n\n{\n\n    AVIOContext *s = obj;\n\n    AVIOInternal *internal = s->opaque;\n\n    return prev ? NULL : internal->h;\n\n}\n",
        "output": "1",
        "idx": 4713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n",
        "output": "1",
        "idx": 2832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int buffer_empty(Buffer *buffer)\n\n{\n\n    return buffer->offset == 0;\n\n}\n",
        "output": "1",
        "idx": 1988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)\n{\n    static const char *const rfs = \"\";\n\n    if (pgs->icc_manager->device_named == NULL) {\n        pval->data = (const byte *) rfs;\n        pval->persistent = true;\n    } else {\n        pval->data = (const byte *) (pgs->icc_manager->device_named->name);\n        pval->persistent = false;\n    }\n    pval->size = strlen((const char *)pval->data);\n}",
        "output": "0",
        "idx": 219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_vfs_daemon_finalize (GObject *object)\n{\n  GVfsDaemon *daemon;\n\n  daemon = G_VFS_DAEMON (object);\n\n  /* There may be some jobs outstanding if we've been force unmounted. */\n  if (daemon->jobs)\n    g_warning (\"daemon->jobs != NULL when finalizing daemon!\");\n\n  if (daemon->name_watcher)\n    g_bus_unwatch_name (daemon->name_watcher);\n  \n  if (daemon->daemon_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));\n      g_object_unref (daemon->daemon_skeleton);\n    }\n  if (daemon->mountable_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));\n      g_object_unref (daemon->mountable_skeleton);\n    }\n  if (daemon->conn != NULL)\n    g_object_unref (daemon->conn);\n  \n  g_hash_table_destroy (daemon->registered_paths);\n  g_hash_table_destroy (daemon->client_connections);\n  g_mutex_clear (&daemon->lock);\n\n  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);\n}",
        "output": "1",
        "idx": 3338
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char* argv[])\n{\n    whoami = QUtil::getWhoami(argv[0]);\n\n    // For libtool's sake....\n    if (strncmp(whoami, \"lt-\", 3) == 0)\n    {\n\twhoami += 3;\n    }\n\n    if (argc != 3)\n    {\n\tusage();\n    }\n    char const* filename = argv[1];\n    int pageno = QUtil::string_to_int(argv[2]);\n\n    try\n    {\n\tQPDF pdf;\n\tpdf.processFile(filename);\n        std::vector<QPDFPageObjectHelper> pages =\n            QPDFPageDocumentHelper(pdf).getAllPages();\n        if ((pageno < 1) || (static_cast<size_t>(pageno) > pages.size()))\n        {\n            usage();\n        }\n\n        QPDFPageObjectHelper& page = pages.at(pageno-1);\n        ParserCallbacks cb;\n        page.parsePageContents(&cb);\n    }\n    catch (std::exception& e)\n    {\n\tstd::cerr << whoami << \": \" << e.what() << std::endl;\n\texit(2);\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 4583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n",
        "output": "1",
        "idx": 575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_filter_primitive_merge_node_free (RsvgNode * self)\n{\n    RsvgFilterPrimitive *upself;\n    upself = (RsvgFilterPrimitive *) self;\n    g_string_free (upself->in, TRUE);\n    _rsvg_node_free (self);\n}",
        "output": "0",
        "idx": 1984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))\n\n{\n\n    stream_printf(stream, \"Trace file \\\"%s\\\" %s.\\n\",\n\n                  trace_file_name, trace_file_enabled ? \"on\" : \"off\");\n\n}\n",
        "output": "1",
        "idx": 3655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jas_icclut8_destroy(jas_iccattrval_t *attrval)\n{\n\tjas_icclut8_t *lut8 = &attrval->data.lut8;\n\tif (lut8->clut)\n\t\tjas_free(lut8->clut);\n\tif (lut8->intabs)\n\t\tjas_free(lut8->intabs);\n\tif (lut8->intabsbuf)\n\t\tjas_free(lut8->intabsbuf);\n\tif (lut8->outtabs)\n\t\tjas_free(lut8->outtabs);\n\tif (lut8->outtabsbuf)\n\t\tjas_free(lut8->outtabsbuf);\n}",
        "output": "1",
        "idx": 4408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n",
        "output": "1",
        "idx": 5167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_tight_start(VncState *vs)\n{\n    buffer_reset(&vs->tight.tight);\n\n    // make the output buffer be the zlib buffer, so we can compress it later\n    vs->tight.tmp = vs->output;\n    vs->output = vs->tight.tight;\n}",
        "output": "1",
        "idx": 5015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline int btrfs_ioctl_ino_lookup(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\t struct btrfs_ioctl_ino_lookup_args *args;\n\t struct inode *inode;\n\t int ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = fdentry(file)->d_inode;\n\n\tif (args->treeid == 0)\n\t\targs->treeid = BTRFS_I(inode)->root->root_key.objectid;\n\n\tret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}",
        "output": "0",
        "idx": 5788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tcp_dst_prompt(packet_info *pinfo, gchar *result)\n{\n    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));\n\n    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, \"destination (%s%u)\", UTF8_RIGHTWARDS_ARROW, port);\n}",
        "output": "0",
        "idx": 5370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void cpu_sh4_invalidate_tlb(CPUSH4State *s)\n\n{\n\n    int i;\n\n\n\n    /* UTLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n    /* ITLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n\n\n    tlb_flush(s, 1);\n\n}\n",
        "output": "0",
        "idx": 2043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,\n\tint jpegSubsamp)\n{\n\tunsigned long retval=0;  int mcuw, mcuh, chromasf;\n\tif(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)\n\t\t_throw(\"tjBufSize(): Invalid argument\");\n\n\t/* This allows for rare corner cases in which a JPEG image can actually be\n\t   larger than the uncompressed input (we wouldn't mention it if it hadn't\n\t   happened before.) */\n\tmcuw=tjMCUWidth[jpegSubsamp];\n\tmcuh=tjMCUHeight[jpegSubsamp];\n\tchromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);\n\tretval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;\n\n\tbailout:\n\treturn retval;\n}",
        "output": "0",
        "idx": 2527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n",
        "output": "1",
        "idx": 4759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pinctrl_get_list_and_count(const struct device_node *np,\n\t\t\t\t      const char *list_name,\n\t\t\t\t      const __be32 **list,\n\t\t\t\t      int *cells_size,\n\t\t\t\t      int *nr_elements)\n{\n\tint size;\n\n\t*cells_size = 0;\n\t*nr_elements = 0;\n\n\t*list = of_get_property(np, list_name, &size);\n\tif (!*list)\n\t\treturn -ENOENT;\n\n\t*cells_size = pinctrl_find_cells_size(np);\n\tif (*cells_size < 0)\n\t\treturn -ENOENT;\n\n\t/* First element is always the index within the pinctrl device */\n\t*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 5457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool dl_param_changed(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t\tdl_se->dl_deadline != attr->sched_deadline ||\n\t\tdl_se->dl_period != attr->sched_period ||\n\t\tdl_se->flags != attr->sched_flags)\n\t\treturn true;\n\n\treturn false;\n}",
        "output": "0",
        "idx": 311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n",
        "output": "0",
        "idx": 4143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n",
        "output": "1",
        "idx": 6271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t/* call only for station! */\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tdata->flags = 0;\n\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,\n\t\tu32 inc, int testn)\n{\n\tint ret = 0, i;\n\tu32 j, tmp;\n\n\t*iret = 0;\n\n\tfor (i = 0, j = 0; i < testn; i++) {\n\t\tret |= WRITEL(sisusb->vrambase + j, j);\n\t\tj += inc;\n\t}\n\n\tfor (i = 0, j = 0; i < testn; i++) {\n\t\tret |= READL(sisusb->vrambase + j, &tmp);\n\t\tif (tmp != j)\n\t\t\treturn ret;\n\n\t\tj += inc;\n\t}\n\n\t*iret = 1;\n\treturn ret;\n}",
        "output": "0",
        "idx": 3802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n",
        "output": "1",
        "idx": 1449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/\n{\n    Py_ssize_t i;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    for (i = 0; i < self->unpickler->memo_size; i++) {\n        int status;\n        PyObject *key, *value;\n\n        value = self->unpickler->memo[i];\n        if (value == NULL)\n            continue;\n\n        key = PyLong_FromSsize_t(i);\n        if (key == NULL)\n            goto error;\n        status = PyDict_SetItem(new_memo, key, value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto error;\n    }\n    return new_memo;\n\nerror:\n    Py_DECREF(new_memo);\n    return NULL;\n}",
        "output": "1",
        "idx": 941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n",
        "output": "1",
        "idx": 2427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,\n\t\t\t\t\t     GAsyncResult *result,\n\t\t\t\t\t     gpointer      user_data)\n{\n\tFrWindow *window = user_data;\n\tGError   *error = NULL;\n\n\tif (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {\n\t\t_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);\n\t\tg_error_free (error);\n\t\treturn;\n\t}\n\n\tif (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {\n\t\tfr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);\n\t\tfr_archive_remove (window->priv->copy_from_archive,\n\t\t\t\t   window->priv->clipboard_data->files,\n\t\t\t\t   window->priv->compression,\n\t\t\t\t   window->priv->cancellable,\n\t\t\t\t   paste_from_archive_remove_ready_cb,\n\t\t\t\t   window);\n\t}\n\telse\n\t\tpaste_from_archive_completed_successfully (window);\n}",
        "output": "0",
        "idx": 736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void csi_X(struct vc_data *vc, unsigned int vpar)\n{\t\t\t\t\t  /* not vt100? */\n\tunsigned int count;\n\n\tif (!vpar)\n\t\tvpar++;\n\n\tcount = min(vpar, vc->vc_cols - vc->state.x);\n\n\tvc_uniscr_clear_line(vc, vc->state.x, count);\n\tscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);\n\tvc->vc_need_wrap = 0;\n}",
        "output": "0",
        "idx": 839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "link_info_done (NautilusDirectory *directory,\n\t\tNautilusFile *file,\n\t\tconst char *uri,\n\t\tconst char *name, \n\t\tconst char *icon,\n\t\tgboolean is_launcher,\n\t\tgboolean is_foreign)\n{\n\tfile->details->link_info_is_up_to_date = TRUE;\n\n\tnautilus_file_set_display_name (file, name, name, TRUE);\n\t\n\tfile->details->got_link_info = TRUE;\n\tg_free (file->details->custom_icon);\n\tif (uri) {\n\t\tif (file->details->activation_location) {\n\t\t\tg_object_unref (file->details->activation_location);\n\t\t\tfile->details->activation_location = NULL;\n\t\t}\n\t\tfile->details->got_custom_activation_location = TRUE;\n\t\tfile->details->activation_location = g_file_new_for_uri (uri);\n\t}\n\tfile->details->custom_icon = g_strdup (icon);\n\tfile->details->is_launcher = is_launcher;\n\tfile->details->is_foreign_link = is_foreign;\n\t\n\tnautilus_directory_async_state_changed (directory);\n}",
        "output": "1",
        "idx": 5353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n",
        "output": "1",
        "idx": 2074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_tee(const char *file_name)\n{\n  FILE* new_outfile;\n  if (opt_outfile)\n    end_tee();\n  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))\n  {\n    tee_fprintf(stdout, \"Error logging to file '%s'\\n\", file_name);\n    return;\n  }\n  OUTFILE = new_outfile;\n  strmake_buf(outfile, file_name);\n  tee_fprintf(stdout, \"Logging to file '%s'\\n\", file_name);\n  opt_outfile= 1;\n  return;\n}",
        "output": "0",
        "idx": 2098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_file_into_memory(\n    char const* filename,\n    PointerHolder<char>& file_buf, size_t& size)\n{\n    FILE* f = QUtil::safe_fopen(filename, \"rb\");\n    fseek(f, 0, SEEK_END);\n    size = QUtil::tell(f);\n    fseek(f, 0, SEEK_SET);\n    file_buf = PointerHolder<char>(true, new char[size]);\n    char* buf_p = file_buf.getPointer();\n    size_t bytes_read = 0;\n    size_t len = 0;\n    while ((len = fread(buf_p + bytes_read, 1, size - bytes_read, f)) > 0)\n    {\n        bytes_read += len;\n    }\n    if (bytes_read != size)\n    {\n        if (ferror(f))\n        {\n            throw std::runtime_error(\n                std::string(\"failure reading file \") + filename +\n                \" into memory: read \" +\n                QUtil::uint_to_string(bytes_read) + \"; wanted \" +\n                QUtil::uint_to_string(size));\n        }\n        else\n        {\n            throw std::logic_error(\n                std::string(\"premature eof reading file \") + filename +\n                \" into memory: read \" +\n                QUtil::uint_to_string(bytes_read) + \"; wanted \" +\n                QUtil::uint_to_string(size));\n        }\n    }\n    fclose(f);\n}",
        "output": "1",
        "idx": 3172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLitePackParams* data =\n      reinterpret_cast<TfLitePackParams*>(node->builtin_data);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  switch (output->type) {\n    case kTfLiteFloat32: {\n      return PackImpl<float>(context, node, output, data->values_count,\n                             data->axis);\n    }\n    case kTfLiteUInt8: {\n      return PackImpl<uint8_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt8: {\n      return PackImpl<int8_t>(context, node, output, data->values_count,\n                              data->axis);\n    }\n    case kTfLiteInt16: {\n      return PackImpl<int16_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt32: {\n      return PackImpl<int32_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt64: {\n      return PackImpl<int64_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by pack.\",\n                           TfLiteTypeGetName(output->type));\n      return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 5653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err paen_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\n\tif (ptr->blocks_and_symbols) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);\n\t\tif (e) return e;\n\t\tptr->size += ptr->blocks_and_symbols->size;\n\t}\n\tif (ptr->FEC_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->FEC_symbol_locations->size;\n\t}\n\tif (ptr->File_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->File_symbol_locations->size;\n\t}\n\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 3158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)\n{\n\treturn head->next;\n}",
        "output": "1",
        "idx": 4886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n",
        "output": "0",
        "idx": 4955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 2809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void elevator_exit(struct request_queue *q, struct elevator_queue *e)\n{\n\tmutex_lock(&e->sysfs_lock);\n\tif (e->type->ops.exit_sched)\n\t\tblk_mq_exit_sched(q, e);\n\tmutex_unlock(&e->sysfs_lock);\n\n\tkobject_put(&e->kobj);\n}",
        "output": "1",
        "idx": 1933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fdprint_message(\n    int       fd,\n    message_t *message)\n{\n    char *msg;\n\n    if (message == NULL)\n\treturn NULL;\n\n    msg = sprint_message(message);\n    full_write(fd, msg, strlen(msg));\n    g_free(msg);\n    return message;\n}",
        "output": "0",
        "idx": 55
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\n\tp = (const char __user *)current->mm->arg_start;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\t/*\n\t * we need some kernel buffer to hold the userspace args.  Just\n\t * allocate one big one rather than allocating one of the right size\n\t * for every single argument inside audit_log_single_execve_arg()\n\t * should be <8k allocation so should be pretty safe.\n\t */\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}",
        "output": "1",
        "idx": 4534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // Lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}",
        "output": "1",
        "idx": 2998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,\n                                                                     ULONG ulAttribute,\n                                                                     void* pBuffer, ULONG cbBuffer)\n{\n\tMechCred* creds;\n\n\tcreds = sspi_SecureHandleGetLowerPointer(phCredential);\n\n\tif (!creds)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tfor (size_t i = 0; i < MECH_COUNT; i++)\n\t{\n\t\tMechCred* cred = &creds[i];\n\n\t\tif (!cred->valid)\n\t\t\tcontinue;\n\n\t\tWINPR_ASSERT(cred->mech);\n\t\tWINPR_ASSERT(cred->mech->pkg);\n\t\tWINPR_ASSERT(cred->mech->pkg->table);\n\t\tWINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);\n\t\tcred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,\n\t\t                                                    cbBuffer);\n\t}\n\n\treturn SEC_E_OK;\n}",
        "output": "1",
        "idx": 200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)\n\n{\n\n    int16_t tmp[146 + 60], *ptr0, *ptr1;\n\n    const int16_t *filter;\n\n    int i, t, off;\n\n\n\n    t = dec->offset2[quart];\n\n    if(t == 127){\n\n        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));\n\n        return;\n\n    }\n\n    for(i = 0; i < 146; i++)\n\n        tmp[i] = dec->filtbuf[i];\n\n    off = (t / 25) + dec->offset1[quart >> 1] + 18;\n\n\n    ptr0 = tmp + 145 - off;\n\n    ptr1 = tmp + 146;\n\n    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;\n\n    for(i = 0; i < 60; i++){\n\n        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;\n\n        ptr0++;\n\n        dec->newvec[i] = t;\n\n        ptr1[i] = t;\n\n    }\n\n}",
        "output": "1",
        "idx": 1861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n",
        "output": "1",
        "idx": 2380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_option (int argc, char *argv[])\n{\n    int n = 0, ind = 0;\n    const char optstr[] = \"+:d:Dhv\";\n    struct option lopt[] = \\\n    {\n        { \"help\", no_argument, NULL, 'h' },\n        { \"version\", no_argument, NULL, 'v' },\n        { 0, 0, 0, 0 }\n    };\n\n    opterr = optind = mode = 0;\n    while ((n = getopt_long (argc, argv, optstr, lopt, &ind)) != -1)\n    {\n        switch (n)\n        {\n        case 'd':\n            mode |= DEBUG;\n            debug_level = atoi (optarg);\n            break;\n\n        case 'D':\n            mode |= DAEMON;\n            break;\n\n        case 'h':\n            printh ();\n            exit (0);\n\n        case 'v':\n            printf (\"%s version %s\\n\", prog, VERSION);\n            exit (0);\n\n        case ':':\n            errx (-1, \"option `%c' takes an argument, see: --help\", optopt);\n\n        default:\n            errx (-1, \"unknown option `%c', see: --help\", optopt);\n        }\n    }\n\n    return optind;\n}",
        "output": "0",
        "idx": 50
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Item_param::add_as_clone(THD *thd)\n{\n  LEX *lex= thd->lex;\n  uint master_pos= pos_in_query + lex->clone_spec_offset;\n  List_iterator_fast<Item_param> it(lex->param_list);\n  Item_param *master_param;\n  while ((master_param = it++))\n  {\n    if (master_pos == master_param->pos_in_query)\n      return master_param->register_clone(this);\n  }\n  DBUG_ASSERT(false);\n  return false;\n}",
        "output": "0",
        "idx": 1240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have\n     * been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 3256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ccid_initfn(USBDevice *dev)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n\n\n    s->bus = ccid_bus_new(&dev->qdev);\n\n    s->card = NULL;\n\n    s->cardinfo = NULL;\n\n    s->migration_state = MIGRATION_NONE;\n\n    s->migration_target_ip = 0;\n\n    s->migration_target_port = 0;\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->notify_slot_change = false;\n\n    s->powered = true;\n\n    s->pending_answers_num = 0;\n\n    s->last_answer_error = 0;\n\n    s->bulk_in_pending_start = 0;\n\n    s->bulk_in_pending_end = 0;\n\n    s->current_bulk_in = NULL;\n\n    ccid_reset_error_status(s);\n\n    s->bulk_out_pos = 0;\n\n    ccid_reset_parameters(s);\n\n    ccid_reset(s);\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 1320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,\n                    int32 input_beta_multiplier, int32 input_beta_left_shift,\n                    int diff_min, uint8* output_data,\n                    const RuntimeShape& output_shape) {\n  SoftmaxParams params;\n  params.input_multiplier = input_beta_multiplier;\n  params.input_left_shift = input_beta_left_shift;\n  params.diff_min = diff_min;\n  Softmax(params, input_shape, input_data, output_shape, output_data);\n}",
        "output": "0",
        "idx": 960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)\n{\n    int i;\n\n    callbacks++;\n    if (noout)\n\treturn;\n    fprintf(stdout, \"SAX.startElement(%s\", (char *) name);\n    if (atts != NULL) {\n        for (i = 0;(atts[i] != NULL);i++) {\n\t    fprintf(stdout, \", %s='\", atts[i++]);\n\t    if (atts[i] != NULL)\n\t        fprintf(stdout, \"%s'\", atts[i]);\n\t}\n    }\n    fprintf(stdout, \")\\n\");\n}",
        "output": "0",
        "idx": 511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = avio_rl64(pb);\n    int ret;\n\n    if (size > INT64_MAX)\n        return AVERROR_INVALIDDATA;\n\n    if (asf->is_header)\n        asf->unknown_size = size;\n    asf->is_header = 0;\n    if (!g->is_subobject) {\n        if (!(ret = strcmp(g->name, \"Header Extension\")))\n            avio_skip(pb, 22); // skip reserved fields and Data Size\n        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,\n                                            asf->unknown_size)) < 0)\n            return ret;\n    } else {\n        if (size < 24) {\n            av_log(s, AV_LOG_ERROR, \"Too small size %\"PRIu64\" (< 24).\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        avio_skip(pb, size - 24);\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 5190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "poolCopyString(STRING_POOL *pool, const XML_Char *s) {\n  do {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n  } while (*s++);\n  s = pool->start;\n  poolFinish(pool);\n  return s;\n}",
        "output": "0",
        "idx": 2729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dce80_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (dce80_construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ffserver_set_int_param(int *dest, const char *value, int factor,\n\n                                  int min, int max, FFServerConfig *config,\n\n                                  const char *error_msg, ...)\n\n{\n\n    int tmp;\n\n    char *tailp;\n\n    if (!value || !value[0])\n\n        goto error;\n\n    errno = 0;\n\n    tmp = strtol(value, &tailp, 0);\n\n    if (tmp < min || tmp > max)\n\n        goto error;\n\n    if (factor) {\n\n        if (FFABS(tmp) > INT_MAX / FFABS(factor))\n\n            goto error;\n\n        tmp *= factor;\n\n    }\n\n    if (tailp[0] || errno)\n\n        goto error;\n\n    if (dest)\n\n        *dest = tmp;\n\n    return 0;\n\n  error:\n\n    if (config) {\n\n        va_list vl;\n\n        va_start(vl, error_msg);\n\n        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, error_msg, vl);\n\n        va_end(vl);\n\n    }\n\n    return AVERROR(EINVAL);\n\n}\n",
        "output": "0",
        "idx": 874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compare_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,\n                                const smartlist_t *policy)\n{\n  if (!policy) {\n    /* no policy? accept all. */\n    return ADDR_POLICY_ACCEPTED;\n  } else if (tor_addr_is_null(addr)) {\n    tor_assert(port != 0);\n    return compare_unknown_tor_addr_to_addr_policy(port, policy);\n  } else if (port == 0) {\n    return compare_known_tor_addr_to_addr_policy_noport(addr, policy);\n  } else {\n    return compare_known_tor_addr_to_addr_policy(addr, port, policy);\n  }\n}",
        "output": "1",
        "idx": 4460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_physical_fs(const struct statfs *sfs) {\n        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);\n}",
        "output": "0",
        "idx": 4103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *gf_seng_get_base64_iod(GF_SceneEngine *seng)\n{\n\tu32 size, size64;\n\tu8 *buffer, *buf64;\n\tu32 i=0;\n\tGF_StreamContext*sc = NULL;\n\n\tif (!seng->ctx->root_od) return NULL;\n\n\twhile ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {\n\t\tif ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))\n\t\t\tbreak;\n\t}\n\tif (!sc) return NULL;\n\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);\n\tbuf64 = gf_malloc(size*2);\n\tsize64 = gf_base64_encode( buffer, size, buf64, size*2);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\treturn buf64;\n}",
        "output": "1",
        "idx": 129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)\n{\n\tenum rtrs_clt_state old_state;\n\tint err = -EBUSY;\n\tbool changed;\n\n\tchanged = rtrs_clt_change_state_get_old(clt_path,\n\t\t\t\t\t\t RTRS_CLT_RECONNECTING,\n\t\t\t\t\t\t &old_state);\n\tif (changed) {\n\t\tclt_path->reconnect_attempts = 0;\n\t\tqueue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);\n\t}\n\tif (changed || old_state == RTRS_CLT_RECONNECTING) {\n\t\t/*\n\t\t * flush_delayed_work() queues pending work for immediate\n\t\t * execution, so do the flush if we have queued something\n\t\t * right now or work is pending.\n\t\t */\n\t\tflush_delayed_work(&clt_path->reconnect_dwork);\n\t\terr = (READ_ONCE(clt_path->state) ==\n\t\t       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);\n\t}\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n",
        "output": "0",
        "idx": 3116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;",
        "output": "1",
        "idx": 5696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n",
        "output": "0",
        "idx": 4091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)\n{\n\tint i, errno;\n\tstruct new_utsname *u;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->nodename);\n\tif (i > len)\n\t\ti = len;\n\terrno = 0;\n\tif (copy_to_user(name, u->nodename, i))\n\t\terrno = -EFAULT;\n\tup_read(&uts_sem);\n\treturn errno;\n}",
        "output": "0",
        "idx": 452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 4776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  // If this is an inline header, we can't addViaMove, because we'll overwrite\n  // the existing value.\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}",
        "output": "1",
        "idx": 3507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int video_open(VideoState *is){\n\n    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    int w,h;\n\n\n\n    if(is_full_screen) flags |= SDL_FULLSCREEN;\n\n    else               flags |= SDL_RESIZABLE;\n\n\n\n    if (is_full_screen && fs_screen_width) {\n\n        w = fs_screen_width;\n\n        h = fs_screen_height;\n\n    } else if(!is_full_screen && screen_width){\n\n        w = screen_width;\n\n        h = screen_height;\n\n    }else if (is->video_st && is->video_st->codec->width){\n\n        w = is->video_st->codec->width;\n\n        h = is->video_st->codec->height;\n\n    } else {\n\n        w = 640;\n\n        h = 480;\n\n    }\n\n#ifndef SYS_DARWIN\n\n    screen = SDL_SetVideoMode(w, h, 0, flags);\n\n#else\n\n    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */\n\n    screen = SDL_SetVideoMode(w, h, 24, flags);\n\n#endif\n\n    if (!screen) {\n\n        fprintf(stderr, \"SDL: could not set video mode - exiting\\n\");\n\n        return -1;\n\n    }\n\n    SDL_WM_SetCaption(\"FFplay\", \"FFplay\");\n\n\n\n    is->width = screen->w;\n\n    is->height = screen->h;\n\n\n\n    return 0;\n\n}\n",
        "output": "0",
        "idx": 5838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t qemu_net_queue_send_iov(NetQueue *queue,\n                                NetClientState *sender,\n                                unsigned flags,\n                                const struct iovec *iov,\n                                int iovcnt,\n                                NetPacketSent *sent_cb)\n{\n    ssize_t ret;\n\n    if (queue->delivering || !qemu_can_send_packet(sender)) {\n        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);\n        return 0;\n    }\n\n    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);\n    if (ret == 0) {\n        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);\n        return 0;\n    }\n\n    qemu_net_queue_flush(queue);\n\n    return ret;\n}",
        "output": "0",
        "idx": 1196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)\n{\n    return false;\n}",
        "output": "0",
        "idx": 1043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)\n{\n\treturn (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);\n}",
        "output": "0",
        "idx": 1136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n",
        "output": "1",
        "idx": 4572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n",
        "output": "0",
        "idx": 3157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){\n\n    int i,j,xy,yz;\n\n    int res;\n\n    for(i=0; i<8; i++){\n\n        for(j=1; j<7; j++){\n\n            xy = j * stride + i;\n\n            yz = j * 8 + i;\n\n            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];\n\n            res +=2;\n\n            res >>=2;\n\n            dest[xy] = (uint8_t)res;\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 4742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(ExpressionFloorTest, IntArg) {\n    assertEvaluates(Value(0), Value(0));\n    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));\n    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));\n}",
        "output": "0",
        "idx": 3734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_unmarked (struct MHD_PostProcessor *pp)\n{\n  if ( (NULL != pp->content_name) &&\n       (0 == (pp->have & NE_content_name)) )\n  {\n    free (pp->content_name);\n    pp->content_name = NULL;\n  }\n  if ( (NULL != pp->content_type) &&\n       (0 == (pp->have & NE_content_type)) )\n  {\n    free (pp->content_type);\n    pp->content_type = NULL;\n  }\n  if ( (NULL != pp->content_filename) &&\n       (0 == (pp->have & NE_content_filename)) )\n  {\n    free (pp->content_filename);\n    pp->content_filename = NULL;\n  }\n  if ( (NULL != pp->content_transfer_encoding) &&\n       (0 == (pp->have & NE_content_transfer_encoding)) )\n  {\n    free (pp->content_transfer_encoding);\n    pp->content_transfer_encoding = NULL;\n  }\n}",
        "output": "0",
        "idx": 5278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\t/* Solaris writes POSIX.1e access and default ACLs together */\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "output": "1",
        "idx": 4424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ruby_scan_oct(const char *start, size_t len, size_t *retlen)\n{\n    register const char *s = start;\n    register unsigned long retval = 0;\n\n    while (len-- && *s >= '0' && *s <= '7') {\n\tretval <<= 3;\n\tretval |= *s++ - '0';\n    }\n    *retlen = (int)(s - start);\t/* less than len */\n    return retval;\n}",
        "output": "0",
        "idx": 2707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n",
        "output": "1",
        "idx": 3787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n",
        "output": "0",
        "idx": 3582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_class_has_default_constructor (MonoClass *klass)\n{\n\tMonoMethod *method;\n\tint i;\n\n\tmono_class_setup_methods (klass);\n\tif (klass->exception_type)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tmethod = klass->methods [i];\n\t\tif (mono_method_is_constructor (method) &&\n\t\t\tmono_method_signature (method) &&\n\t\t\tmono_method_signature (method)->param_count == 0 &&\n\t\t\t(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}",
        "output": "0",
        "idx": 2289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = send(vs->csock, (const void *)data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n",
        "output": "1",
        "idx": 3968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qdev_prop_check_globals(void)\n\n{\n\n    GList *l;\n\n    int ret = 0;\n\n\n\n    for (l = global_props; l; l = l->next) {\n\n        GlobalProperty *prop = l->data;\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n",
        "output": "0",
        "idx": 3513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tpa6130a2_power(struct tpa6130a2_data *data, bool enable)\n{\n\tint ret;\n\n\tif (enable) {\n\t\tret = regulator_enable(data->supply);\n\t\tif (ret != 0) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"Failed to enable supply: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t/* Power on */\n\t\tif (data->power_gpio >= 0)\n\t\t\tgpio_set_value(data->power_gpio, 1);\n\t} else {\n\t\t/* Power off */\n\t\tif (data->power_gpio >= 0)\n\t\t\tgpio_set_value(data->power_gpio, 0);\n\n\t\tret = regulator_disable(data->supply);\n\t\tif (ret != 0) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"Failed to disable supply: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* device regs does not match the cache state anymore */\n\t\tregcache_mark_dirty(data->regmap);\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void GetRootMeanSquarePixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum;\n\n  SkipList\n    *list;\n\n  ssize_t\n    channel;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the root mean square value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) (list->nodes[color].count*color*color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum);\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}",
        "output": "0",
        "idx": 5680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_compat_bearer_set(struct sk_buff *skb,\n\t\t\t\t     struct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *bearer;\n\tstruct tipc_link_config *lc;\n\n\tlc = (struct tipc_link_config *)TLV_DATA(msg->req);\n\n\tbearer = nla_nest_start(skb, TIPC_NLA_BEARER);\n\tif (!bearer)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))\n\t\treturn -EMSGSIZE;\n\n\tprop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\n\tif (!prop)\n\t\treturn -EMSGSIZE;\n\n\t__tipc_add_link_prop(skb, msg, lc);\n\tnla_nest_end(skb, prop);\n\tnla_nest_end(skb, bearer);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evdns_shutdown(int fail_requests)\n{\n\tif (current_base) {\n\t\tstruct evdns_base *b = current_base;\n\t\tcurrent_base = NULL;\n\t\tevdns_base_free(b, fail_requests);\n\t}\n\tevdns_log_fn = NULL;\n}",
        "output": "0",
        "idx": 339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, current)\n{\n\tspl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_ptr_llist_element *element = intern->traverse_pointer;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (element == NULL || element->data == NULL) {\n\t\tRETURN_NULL();\n\t} else {\n\t\tzval *data    = (zval *)element->data;\n\t\tRETURN_ZVAL(data, 1, 0);\n\t}\n}",
        "output": "1",
        "idx": 4581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n",
        "output": "1",
        "idx": 5291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qemu_rdma_get_fd(void *opaque)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n\n\n    return rdma->comp_channel->fd;\n\n}\n",
        "output": "1",
        "idx": 5324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int win_chr_write(CharDriverState *chr, const uint8_t *buf, int len1)\n{\n    WinCharState *s = chr->opaque;\n    DWORD len, ret, size, err;\n\n    len = len1;\n    ZeroMemory(&s->osend, sizeof(s->osend));\n    s->osend.hEvent = s->hsend;\n    while (len > 0) {\n        if (s->hsend)\n            ret = WriteFile(s->hcom, buf, len, &size, &s->osend);\n        else\n            ret = WriteFile(s->hcom, buf, len, &size, NULL);\n        if (!ret) {\n            err = GetLastError();\n            if (err == ERROR_IO_PENDING) {\n                ret = GetOverlappedResult(s->hcom, &s->osend, &size, TRUE);\n                if (ret) {\n                    buf += size;\n                    len -= size;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            buf += size;\n            len -= size;\n        }\n    }\n    return len1 - len;\n}",
        "output": "0",
        "idx": 4808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n",
        "output": "1",
        "idx": 5729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int airo_get_frag(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.fragThresh);\n\tvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 6325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\n\treturn &rt->dst;\n}",
        "output": "1",
        "idx": 2004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ArgParser::argShowEncryptionKey()\n{\n    o.show_encryption_key = true;\n}",
        "output": "0",
        "idx": 3471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold void avcodec_register(AVCodec *codec)\n\n{\n\n    AVCodec **p;\n\n    avcodec_init();\n\n    p = &first_avcodec;\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n    *p          = codec;\n\n    codec->next = NULL;\n\n\n\n    if (codec->init_static_data)\n\n        codec->init_static_data(codec);\n\n}\n",
        "output": "0",
        "idx": 1114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "server_get_network (server *serv, gboolean fallback)\n{\n\t/* check the network list */\n\tif (serv->network)\n\t\treturn ((ircnet *)serv->network)->name;\n\n\t/* check the network name given in 005 NETWORK=... */\n\tif (serv->server_session && *serv->server_session->channel)\n\t\treturn serv->server_session->channel;\n\n\tif (fallback)\n\t\treturn serv->servername;\n\n\treturn NULL;\n}",
        "output": "0",
        "idx": 833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ide_dma_submit_check(IDEState *s,\n\n          BlockDriverCompletionFunc *dma_cb)\n\n{\n\n    if (s->bus->dma->aiocb)\n\n\treturn;\n\n    dma_cb(s, -1);\n\n}\n",
        "output": "1",
        "idx": 865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {\n  return QInt32(static_cast<int32_t>(a.value) + b.value);\n}",
        "output": "0",
        "idx": 2820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n",
        "output": "1",
        "idx": 142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}",
        "output": "1",
        "idx": 5385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n",
        "output": "1",
        "idx": 3579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}",
        "output": "1",
        "idx": 308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n",
        "output": "1",
        "idx": 6091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
        "output": "0",
        "idx": 6252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n",
        "output": "1",
        "idx": 206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {\n  // We must check if the 'cached_route_' optional is populated since this function can be called\n  // early via sendLocalReply(), before the cached route is populated.\n  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {\n    return &cached_route_.value()->routeEntry()->upgradeMap();\n  }\n\n  return nullptr;\n}",
        "output": "0",
        "idx": 5806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 1794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n",
        "output": "1",
        "idx": 1779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)\n{\n\tif (enable && !_metadata_locking)\n\t\treturn -EPERM;\n\n\t_metadata_locking = enable ? 1 : 0;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)\n\n{\n\n    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));\n\n\n\n    if (!p_new)\n\n        return -1;\n\n\n\n    p_new->data = p_data;\n\n\n\n    if (!queue->p_head)\n\n        queue->p_head = p_new;\n\n    else\n\n        queue->p_tail->next = p_new;\n\n    queue->p_tail = p_new;\n\n\n\n    ++queue->size;\n\n    return 0;\n\n}\n",
        "output": "1",
        "idx": 6162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n",
        "output": "0",
        "idx": 679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_register_kafka(void)\n{\n\n    int protocol_handle;\n\n    compute_kafka_api_names();\n\n    protocol_handle = proto_register_protocol(\"Kafka\", \"Kafka\", \"kafka\");\n    proto_register_kafka_protocol_fields(protocol_handle);\n    proto_register_kafka_protocol_subtrees(protocol_handle);\n    proto_register_kafka_expert_module(protocol_handle);\n    proto_register_kafka_preferences(protocol_handle);\n\n    proto_kafka = protocol_handle;\n\n}",
        "output": "0",
        "idx": 2601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n",
        "output": "1",
        "idx": 1073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n",
        "output": "1",
        "idx": 4890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n\n    return i->next;\n}",
        "output": "1",
        "idx": 2594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    unsigned long page_index;\n\n    int ret;\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n    page_index = ram_addr >> TARGET_PAGE_BITS;\n\n    if (!modified_ram_pages_table[page_index]) {\n\n#if 0\n\n        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);\n\n#endif\n\n        modified_ram_pages_table[page_index] = 1;\n\n        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;\n\n        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {\n\n            /* flush */\n\n#ifdef _WIN32\n\n            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                                  &nb_modified_ram_pages,\n\n                                  sizeof(nb_modified_ram_pages),\n\n                                  NULL, 0, &temp, NULL);\n\n#else\n\n            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                        &nb_modified_ram_pages);\n\n#endif\n\n            kqemu_reset_modified_ram_pages();\n\n        }\n\n    }\n\n}\n",
        "output": "0",
        "idx": 1593
    }
]